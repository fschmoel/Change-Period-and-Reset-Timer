In archive libArduinoLibraries.a:

File.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .group        00000008  00000000  00000000  00000034  2**2
                  CONTENTS, READONLY, EXCLUDE, GROUP, LINK_ONCE_DISCARD
  1 .group        00000008  00000000  00000000  0000003c  2**2
                  CONTENTS, READONLY, EXCLUDE, GROUP, LINK_ONCE_DISCARD
  2 .text         00000000  00000000  00000000  00000044  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .data         00000000  00000000  00000000  00000044  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00000000  00000000  00000000  00000044  2**0
                  ALLOC
  5 .stab         00001098  00000000  00000000  00000044  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .stabstr      00003329  00000000  00000000  000010dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .text._ZN4File9availableEv 00000016  00000000  00000000  00004405  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text._ZN4File5writeEPKhj 00000008  00000000  00000000  0000441b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text._ZN4File5flushEv 00000008  00000000  00000000  00004423  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text._ZN6SdFile4readEv 0000002e  00000000  00000000  0000442b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text._ZN4File4readEv 00000008  00000000  00000000  00004459  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text._ZN4File4peekEv 00000038  00000000  00000000  00004461  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text._ZN4File4seekEm 00000008  00000000  00000000  00004499  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text._ZN4File8positionEv 00000012  00000000  00000000  000044a1  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text._ZN4File4sizeEv 00000012  00000000  00000000  000044b3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 16 .text._ZN4File5closeEv 00000008  00000000  00000000  000044c5  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 17 .text._ZN4FilecvbEv 0000000e  00000000  00000000  000044cd  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 18 .text._ZN4File5writeEh 00000008  00000000  00000000  000044db  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 19 .text._ZN4File5writeEPKc 00000008  00000000  00000000  000044e3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 20 .rodata._ZTV4File 00000012  00000000  00000000  000044eb  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 21 .comment      00000012  00000000  00000000  000044fd  2**0
                  CONTENTS, READONLY

Disassembly of section .text._ZN4File9availableEv:

00000000 <_ZN4File9availableEv>:
void File::write(uint8_t val) {
  SD.file.write(val);
}

void File::write(const char *str) {
  SD.file.write(str);
   0:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   8:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   c:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  10:	82 1b       	sub	r24, r18
  12:	93 0b       	sbc	r25, r19
  14:	08 95       	ret

Disassembly of section .text._ZN4File5writeEPKhj:

00000000 <_ZN4File5writeEPKhj>:
   0:	80 e0       	ldi	r24, 0x00	; 0
   2:	90 e0       	ldi	r25, 0x00	; 0
   4:	0c 94 00 00 	jmp	0	; 0x0 <_ZN4File5writeEPKhj>

Disassembly of section .text._ZN4File5flushEv:

00000000 <_ZN4File5flushEv>:
   0:	80 e0       	ldi	r24, 0x00	; 0
   2:	90 e0       	ldi	r25, 0x00	; 0
   4:	0c 94 00 00 	jmp	0	; 0x0 <_ZN4File5flushEv>

Disassembly of section .text._ZN6SdFile4readEv:

00000000 <_ZN6SdFile4readEv>:
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	1f 92       	push	r1
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	41 e0       	ldi	r20, 0x01	; 1
   c:	50 e0       	ldi	r21, 0x00	; 0
   e:	be 01       	movw	r22, r28
  10:	6f 5f       	subi	r22, 0xFF	; 255
  12:	7f 4f       	sbci	r23, 0xFF	; 255
  14:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile4readEv>
  18:	01 97       	sbiw	r24, 0x01	; 1
  1a:	01 f4       	brne	.+0      	; 0x1c <_ZN6SdFile4readEv+0x1c>
  1c:	89 81       	ldd	r24, Y+1	; 0x01
  1e:	90 e0       	ldi	r25, 0x00	; 0
  20:	0f 90       	pop	r0
  22:	df 91       	pop	r29
  24:	cf 91       	pop	r28
  26:	08 95       	ret
  28:	8f ef       	ldi	r24, 0xFF	; 255
  2a:	9f ef       	ldi	r25, 0xFF	; 255
  2c:	00 c0       	rjmp	.+0      	; 0x2e <__zero_reg__+0x2d>

Disassembly of section .text._ZN4File4readEv:

00000000 <_ZN4File4readEv>:
   0:	80 e0       	ldi	r24, 0x00	; 0
   2:	90 e0       	ldi	r25, 0x00	; 0
   4:	0c 94 00 00 	jmp	0	; 0x0 <_ZN4File4readEv>

Disassembly of section .text._ZN4File4peekEv:

00000000 <_ZN4File4peekEv>:
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	80 e0       	ldi	r24, 0x00	; 0
   6:	90 e0       	ldi	r25, 0x00	; 0
   8:	0e 94 00 00 	call	0	; 0x0 <_ZN4File4peekEv>
   c:	ec 01       	movw	r28, r24
   e:	40 91 00 00 	lds	r20, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  12:	50 91 00 00 	lds	r21, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  16:	60 91 00 00 	lds	r22, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  1a:	70 91 00 00 	lds	r23, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  1e:	41 50       	subi	r20, 0x01	; 1
  20:	51 09       	sbc	r21, r1
  22:	61 09       	sbc	r22, r1
  24:	71 09       	sbc	r23, r1
  26:	80 e0       	ldi	r24, 0x00	; 0
  28:	90 e0       	ldi	r25, 0x00	; 0
  2a:	0e 94 00 00 	call	0	; 0x0 <_ZN4File4peekEv>
  2e:	ce 01       	movw	r24, r28
  30:	99 27       	eor	r25, r25
  32:	df 91       	pop	r29
  34:	cf 91       	pop	r28
  36:	08 95       	ret

Disassembly of section .text._ZN4File4seekEm:

00000000 <_ZN4File4seekEm>:
   0:	80 e0       	ldi	r24, 0x00	; 0
   2:	90 e0       	ldi	r25, 0x00	; 0
   4:	0c 94 00 00 	jmp	0	; 0x0 <_ZN4File4seekEm>

Disassembly of section .text._ZN4File8positionEv:

00000000 <_ZN4File8positionEv>:
   0:	60 91 00 00 	lds	r22, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	70 91 00 00 	lds	r23, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   8:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   c:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  10:	08 95       	ret

Disassembly of section .text._ZN4File4sizeEv:

00000000 <_ZN4File4sizeEv>:
   0:	60 91 00 00 	lds	r22, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	70 91 00 00 	lds	r23, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   8:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   c:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  10:	08 95       	ret

Disassembly of section .text._ZN4File5closeEv:

00000000 <_ZN4File5closeEv>:
   0:	80 e0       	ldi	r24, 0x00	; 0
   2:	90 e0       	ldi	r25, 0x00	; 0
   4:	0c 94 00 00 	jmp	0	; 0x0 <_ZN4File5closeEv>

Disassembly of section .text._ZN4FilecvbEv:

00000000 <_ZN4FilecvbEv>:
   0:	81 e0       	ldi	r24, 0x01	; 1
   2:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   6:	91 11       	cpse	r25, r1
   8:	00 c0       	rjmp	.+0      	; 0xa <_ZN4FilecvbEv+0xa>
   a:	80 e0       	ldi	r24, 0x00	; 0
   c:	08 95       	ret

Disassembly of section .text._ZN4File5writeEh:

00000000 <_ZN4File5writeEh>:
   0:	80 e0       	ldi	r24, 0x00	; 0
   2:	90 e0       	ldi	r25, 0x00	; 0
   4:	0c 94 00 00 	jmp	0	; 0x0 <_ZN4File5writeEh>

Disassembly of section .text._ZN4File5writeEPKc:

00000000 <_ZN4File5writeEPKc>:
   0:	80 e0       	ldi	r24, 0x00	; 0
   2:	90 e0       	ldi	r25, 0x00	; 0
   4:	0c 94 00 00 	jmp	0	; 0x0 <_ZN4File5writeEPKc>

SD.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000016e0  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000037bd  00000000  00000000  00001714  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text._Z19callback_pathExistsR6SdFilePchPv 00000052  00000000  00000000  00004ed1  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text._Z20callback_makeDirPathR6SdFilePchPv 0000005a  00000000  00000000  00004f23  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text._Z15callback_removeR6SdFilePchPv 0000000a  00000000  00000000  00004f7d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text._Z17callback_openPathR6SdFilePchPv 0000004c  00000000  00000000  00004f87  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text._Z14callback_rmdirR6SdFilePchPv 00000056  00000000  00000000  00004fd3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text._Z20getNextPathComponentPcPjS_ 00000086  00000000  00000000  00005029  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text._Z8walkPathPcR6SdFilePFhS1_S_hPvES2_ 00000122  00000000  00000000  000050af  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text._ZN7SDClass5beginEh 0000005a  00000000  00000000  000051d1  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text._ZN7SDClass4openEPch 00000032  00000000  00000000  0000522b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text._ZN7SDClass6existsEPc 00000016  00000000  00000000  0000525d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text._ZN7SDClass5mkdirEPc 00000016  00000000  00000000  00005273  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 16 .text._ZN7SDClass5rmdirEPc 00000016  00000000  00000000  00005289  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 17 .text._ZN7SDClass6removeEPc 00000016  00000000  00000000  0000529f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 18 .text.startup._GLOBAL__sub_I__Z20getNextPathComponentPcPjS_ 00000036  00000000  00000000  000052b5  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 19 .ctors        00000002  00000000  00000000  000052ec  2**1
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 20 .bss.SD       00000064  00000000  00000000  000052ee  2**0
                  ALLOC
 21 .comment      00000012  00000000  00000000  000052ee  2**0
                  CONTENTS, READONLY

Disassembly of section .text._Z19callback_pathExistsR6SdFilePchPv:

00000000 <_Z19callback_pathExistsR6SdFilePchPv>:
 * \brief Raw access to SD and SDHC flash memory cards.
 */
class Sd2Card {
 public:
  /** Construct an instance of Sd2Card. */
  Sd2Card(void) : errorCode_(0), inBlock_(0), partialBlockRead_(0), type_(0) {}
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	6c 97       	sbiw	r28, 0x1c	; 28
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
   c:	0f b6       	in	r0, 0x3f	; 63
   e:	f8 94       	cli
  10:	de bf       	out	0x3e, r29	; 62
  12:	0f be       	out	0x3f, r0	; 63
  14:	cd bf       	out	0x3d, r28	; 61
  16:	ab 01       	movw	r20, r22
  18:	20 e0       	ldi	r18, 0x00	; 0
  1a:	30 e0       	ldi	r19, 0x00	; 0
  1c:	3a 83       	std	Y+2, r19	; 0x02
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
  1e:	29 83       	std	Y+1, r18	; 0x01
  20:	1d 82       	std	Y+5, r1	; 0x05
  22:	21 e0       	ldi	r18, 0x01	; 1
  24:	bc 01       	movw	r22, r24
  26:	ce 01       	movw	r24, r28
  28:	01 96       	adiw	r24, 0x01	; 1
  2a:	0e 94 00 00 	call	0	; 0x0 <_Z19callback_pathExistsR6SdFilePchPv>
  2e:	18 2f       	mov	r17, r24
  30:	88 23       	and	r24, r24
  32:	01 f0       	breq	.+0      	; 0x34 <_Z19callback_pathExistsR6SdFilePchPv+0x34>

boolean SDClass::remove(char *filepath) {
  return walkPath(filepath, root, callback_remove);
}

  34:	ce 01       	movw	r24, r28
  36:	01 96       	adiw	r24, 0x01	; 1
  38:	0e 94 00 00 	call	0	; 0x0 <_Z19callback_pathExistsR6SdFilePchPv>
  3c:	81 2f       	mov	r24, r17
  3e:	6c 96       	adiw	r28, 0x1c	; 28
  40:	0f b6       	in	r0, 0x3f	; 63
  42:	f8 94       	cli
  44:	de bf       	out	0x3e, r29	; 62
  46:	0f be       	out	0x3f, r0	; 63
  48:	cd bf       	out	0x3d, r28	; 61
  4a:	df 91       	pop	r29
  4c:	cf 91       	pop	r28
  4e:	1f 91       	pop	r17
  50:	08 95       	ret

Disassembly of section .text._Z20callback_makeDirPathR6SdFilePchPv:

00000000 <_Z20callback_makeDirPathR6SdFilePchPv>:
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
   c:	cd b7       	in	r28, 0x3d	; 61
   e:	de b7       	in	r29, 0x3e	; 62
  10:	6c 97       	sbiw	r28, 0x1c	; 28
  12:	0f b6       	in	r0, 0x3f	; 63
  14:	f8 94       	cli
  16:	de bf       	out	0x3e, r29	; 62
  18:	0f be       	out	0x3f, r0	; 63
  1a:	cd bf       	out	0x3d, r28	; 61
  1c:	8c 01       	movw	r16, r24
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
  1e:	7b 01       	movw	r14, r22
  20:	80 e0       	ldi	r24, 0x00	; 0
  22:	90 e0       	ldi	r25, 0x00	; 0
  24:	9a 83       	std	Y+2, r25	; 0x02
  26:	89 83       	std	Y+1, r24	; 0x01
  28:	1d 82       	std	Y+5, r1	; 0x05
  2a:	c8 01       	movw	r24, r16
  2c:	0e 94 00 00 	call	0	; 0x0 <_Z20callback_makeDirPathR6SdFilePchPv>
  30:	81 11       	cpse	r24, r1
  32:	00 c0       	rjmp	.+0      	; 0x34 <_Z20callback_makeDirPathR6SdFilePchPv+0x34>
  34:	a7 01       	movw	r20, r14
  36:	b8 01       	movw	r22, r16
  38:	ce 01       	movw	r24, r28
  3a:	01 96       	adiw	r24, 0x01	; 1
  3c:	0e 94 00 00 	call	0	; 0x0 <_Z20callback_makeDirPathR6SdFilePchPv>
  40:	6c 96       	adiw	r28, 0x1c	; 28
  42:	0f b6       	in	r0, 0x3f	; 63
  44:	f8 94       	cli
  46:	de bf       	out	0x3e, r29	; 62
  48:	0f be       	out	0x3f, r0	; 63
  4a:	cd bf       	out	0x3d, r28	; 61
  4c:	df 91       	pop	r29
  4e:	cf 91       	pop	r28
  50:	1f 91       	pop	r17
  52:	0f 91       	pop	r16
  54:	ff 90       	pop	r15
  56:	ef 90       	pop	r14
  58:	08 95       	ret

Disassembly of section .text._Z15callback_removeR6SdFilePchPv:

00000000 <_Z15callback_removeR6SdFilePchPv>:
   0:	41 11       	cpse	r20, r1
   2:	0c 94 00 00 	jmp	0	; 0x0 <_Z15callback_removeR6SdFilePchPv>
   6:	81 e0       	ldi	r24, 0x01	; 1
   8:	08 95       	ret

Disassembly of section .text._Z17callback_openPathR6SdFilePchPv:

00000000 <_Z17callback_openPathR6SdFilePchPv>:
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	44 23       	and	r20, r20
   a:	01 f0       	breq	.+0      	; 0xc <_Z17callback_openPathR6SdFilePchPv+0xc>
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
   c:	e9 01       	movw	r28, r18
   e:	ab 01       	movw	r20, r22
  10:	bc 01       	movw	r22, r24
  12:	89 01       	movw	r16, r18
  14:	0a 5b       	subi	r16, 0xBA	; 186
  16:	1f 4f       	sbci	r17, 0xFF	; 255
  18:	ce 59       	subi	r28, 0x9E	; 158
  1a:	df 4f       	sbci	r29, 0xFF	; 255
  1c:	28 81       	ld	r18, Y
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
  1e:	c8 01       	movw	r24, r16
  20:	0e 94 00 00 	call	0	; 0x0 <_Z17callback_openPathR6SdFilePchPv>
  24:	88 81       	ld	r24, Y
  26:	99 81       	ldd	r25, Y+1	; 0x01
  28:	4b 97       	sbiw	r24, 0x1b	; 27
  2a:	01 f4       	brne	.+0      	; 0x2c <_Z17callback_openPathR6SdFilePchPv+0x2c>
  2c:	f8 01       	movw	r30, r16
  2e:	42 89       	ldd	r20, Z+18	; 0x12
  30:	53 89       	ldd	r21, Z+19	; 0x13
  32:	64 89       	ldd	r22, Z+20	; 0x14
  34:	75 89       	ldd	r23, Z+21	; 0x15
  36:	c8 01       	movw	r24, r16
  38:	0e 94 00 00 	call	0	; 0x0 <_Z17callback_openPathR6SdFilePchPv>
  3c:	80 e0       	ldi	r24, 0x00	; 0
  3e:	00 c0       	rjmp	.+0      	; 0x40 <_Z17callback_openPathR6SdFilePchPv+0x40>
  40:	81 e0       	ldi	r24, 0x01	; 1
  42:	df 91       	pop	r29
  44:	cf 91       	pop	r28
  46:	1f 91       	pop	r17
  48:	0f 91       	pop	r16
  4a:	08 95       	ret

Disassembly of section .text._Z14callback_rmdirR6SdFilePchPv:

00000000 <_Z14callback_rmdirR6SdFilePchPv>:
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	6c 97       	sbiw	r28, 0x1c	; 28
   a:	0f b6       	in	r0, 0x3f	; 63
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	44 23       	and	r20, r20
  16:	01 f0       	breq	.+0      	; 0x18 <_Z14callback_rmdirR6SdFilePchPv+0x18>
  18:	ab 01       	movw	r20, r22
  1a:	bc 01       	movw	r22, r24
  1c:	80 e0       	ldi	r24, 0x00	; 0
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
  1e:	90 e0       	ldi	r25, 0x00	; 0
  20:	9a 83       	std	Y+2, r25	; 0x02
  22:	89 83       	std	Y+1, r24	; 0x01
  24:	1d 82       	std	Y+5, r1	; 0x05
  26:	21 e0       	ldi	r18, 0x01	; 1
  28:	ce 01       	movw	r24, r28
  2a:	01 96       	adiw	r24, 0x01	; 1
  2c:	0e 94 00 00 	call	0	; 0x0 <_Z14callback_rmdirR6SdFilePchPv>
  30:	88 23       	and	r24, r24
  32:	01 f0       	breq	.+0      	; 0x34 <_Z14callback_rmdirR6SdFilePchPv+0x34>
  34:	ce 01       	movw	r24, r28
  36:	01 96       	adiw	r24, 0x01	; 1
  38:	0e 94 00 00 	call	0	; 0x0 <_Z14callback_rmdirR6SdFilePchPv>
  3c:	6c 96       	adiw	r28, 0x1c	; 28
  3e:	0f b6       	in	r0, 0x3f	; 63
  40:	f8 94       	cli
  42:	de bf       	out	0x3e, r29	; 62
  44:	0f be       	out	0x3f, r0	; 63
  46:	cd bf       	out	0x3d, r28	; 61
  48:	df 91       	pop	r29
  4a:	cf 91       	pop	r28
  4c:	08 95       	ret
  4e:	80 e0       	ldi	r24, 0x00	; 0
  50:	00 c0       	rjmp	.+0      	; 0x52 <_Z14callback_rmdirR6SdFilePchPv+0x52>
  52:	81 e0       	ldi	r24, 0x01	; 1
  54:	00 c0       	rjmp	.+0      	; 0x56 <__SREG__+0x17>

Disassembly of section .text._Z20getNextPathComponentPcPjS_:

00000000 <_Z20getNextPathComponentPcPjS_>:
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
   c:	7b 01       	movw	r14, r22
   e:	db 01       	movw	r26, r22
  10:	2d 91       	ld	r18, X+
  12:	3c 91       	ld	r19, X
  14:	fc 01       	movw	r30, r24
  16:	e2 0f       	add	r30, r18
  18:	f3 1f       	adc	r31, r19
  1a:	60 81       	ld	r22, Z
  1c:	6f 32       	cpi	r22, 0x2F	; 47
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
  1e:	01 f4       	brne	.+0      	; 0x20 <_Z20getNextPathComponentPcPjS_+0x20>
  20:	2f 5f       	subi	r18, 0xFF	; 255
  22:	3f 4f       	sbci	r19, 0xFF	; 255
  24:	8c 01       	movw	r16, r24
  26:	02 0f       	add	r16, r18
  28:	13 1f       	adc	r17, r19
  2a:	ea 01       	movw	r28, r20
  2c:	f0 e0       	ldi	r31, 0x00	; 0
  2e:	e0 e0       	ldi	r30, 0x00	; 0
  30:	d8 01       	movw	r26, r16
  32:	7d 91       	ld	r23, X+
  34:	8d 01       	movw	r16, r26
  36:	7f 32       	cpi	r23, 0x2F	; 47
  38:	01 f0       	breq	.+0      	; 0x3a <_Z20getNextPathComponentPcPjS_+0x3a>
  3a:	77 23       	and	r23, r23
  3c:	01 f0       	breq	.+0      	; 0x3e <_Z20getNextPathComponentPcPjS_+0x3e>
  3e:	2f 5f       	subi	r18, 0xFF	; 255
  40:	3f 4f       	sbci	r19, 0xFF	; 255
  42:	31 96       	adiw	r30, 0x01	; 1
  44:	79 93       	st	Y+, r23
  46:	ec 30       	cpi	r30, 0x0C	; 12
  48:	f1 05       	cpc	r31, r1
  4a:	01 f4       	brne	.+0      	; 0x4c <_Z20getNextPathComponentPcPjS_+0x4c>
  4c:	e4 0f       	add	r30, r20
  4e:	f5 1f       	adc	r31, r21
  50:	10 82       	st	Z, r1
  52:	fc 01       	movw	r30, r24
  54:	e2 0f       	add	r30, r18
  56:	f3 1f       	adc	r31, r19
  58:	40 81       	ld	r20, Z
  5a:	4f 32       	cpi	r20, 0x2F	; 47
  5c:	01 f4       	brne	.+0      	; 0x5e <_Z20getNextPathComponentPcPjS_+0x5e>
  5e:	2f 5f       	subi	r18, 0xFF	; 255
  60:	3f 4f       	sbci	r19, 0xFF	; 255
  62:	f7 01       	movw	r30, r14
  64:	31 83       	std	Z+1, r19	; 0x01
  66:	20 83       	st	Z, r18
  68:	28 0f       	add	r18, r24
  6a:	39 1f       	adc	r19, r25
  6c:	81 e0       	ldi	r24, 0x01	; 1
  6e:	d9 01       	movw	r26, r18
  70:	9c 91       	ld	r25, X
  72:	91 11       	cpse	r25, r1
  74:	00 c0       	rjmp	.+0      	; 0x76 <_Z20getNextPathComponentPcPjS_+0x76>
  76:	80 e0       	ldi	r24, 0x00	; 0
  78:	df 91       	pop	r29
  7a:	cf 91       	pop	r28
  7c:	1f 91       	pop	r17
  7e:	0f 91       	pop	r16
  80:	ff 90       	pop	r15
  82:	ef 90       	pop	r14
  84:	08 95       	ret

Disassembly of section .text._Z8walkPathPcR6SdFilePFhS1_S_hPvES2_:

00000000 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_>:
   0:	3f 92       	push	r3
   2:	4f 92       	push	r4
   4:	5f 92       	push	r5
   6:	6f 92       	push	r6
   8:	7f 92       	push	r7
   a:	8f 92       	push	r8
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
   c:	9f 92       	push	r9
   e:	af 92       	push	r10
  10:	bf 92       	push	r11
  12:	cf 92       	push	r12
  14:	df 92       	push	r13
  16:	ef 92       	push	r14
  18:	ff 92       	push	r15
  1a:	0f 93       	push	r16
  1c:	1f 93       	push	r17
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
  1e:	cf 93       	push	r28
  20:	df 93       	push	r29
  22:	cd b7       	in	r28, 0x3d	; 61
  24:	de b7       	in	r29, 0x3e	; 62
  26:	c7 54       	subi	r28, 0x47	; 71
  28:	d1 09       	sbc	r29, r1
  2a:	0f b6       	in	r0, 0x3f	; 63
  2c:	f8 94       	cli
  2e:	de bf       	out	0x3e, r29	; 62
  30:	0f be       	out	0x3f, r0	; 63
  32:	cd bf       	out	0x3d, r28	; 61
  34:	5c 01       	movw	r10, r24
  36:	6b 01       	movw	r12, r22
  38:	3a 01       	movw	r6, r20
  3a:	49 01       	movw	r8, r18
  3c:	80 e0       	ldi	r24, 0x00	; 0
  3e:	90 e0       	ldi	r25, 0x00	; 0
  40:	9e 8f       	std	Y+30, r25	; 0x1e
  42:	8d 8f       	std	Y+29, r24	; 0x1d
  44:	19 a2       	std	Y+33, r1	; 0x21
  46:	9a 83       	std	Y+2, r25	; 0x02
  48:	89 83       	std	Y+1, r24	; 0x01
  4a:	1d 82       	std	Y+5, r1	; 0x05
  4c:	28 96       	adiw	r28, 0x08	; 8
  4e:	1f ae       	std	Y+63, r1	; 0x3f
  50:	1e ae       	std	Y+62, r1	; 0x3e
  52:	28 97       	sbiw	r28, 0x08	; 8
  54:	8b 01       	movw	r16, r22
  56:	7e 01       	movw	r14, r28
  58:	8d e1       	ldi	r24, 0x1D	; 29
  5a:	e8 0e       	add	r14, r24
  5c:	f1 1c       	adc	r15, r1
  5e:	33 24       	eor	r3, r3
  60:	33 94       	inc	r3
  62:	ae 01       	movw	r20, r28
  64:	47 5c       	subi	r20, 0xC7	; 199
  66:	5f 4f       	sbci	r21, 0xFF	; 255
  68:	be 01       	movw	r22, r28
  6a:	6a 5b       	subi	r22, 0xBA	; 186
  6c:	7f 4f       	sbci	r23, 0xFF	; 255
  6e:	c5 01       	movw	r24, r10
  70:	0e 94 00 00 	call	0	; 0x0 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_>
  74:	48 2e       	mov	r4, r24
  76:	48 2f       	mov	r20, r24
  78:	43 25       	eor	r20, r3
  7a:	94 01       	movw	r18, r8
  7c:	be 01       	movw	r22, r28
  7e:	67 5c       	subi	r22, 0xC7	; 199
  80:	7f 4f       	sbci	r23, 0xFF	; 255
  82:	c8 01       	movw	r24, r16
  84:	f3 01       	movw	r30, r6
  86:	09 95       	icall
  88:	58 2e       	mov	r5, r24
  8a:	81 11       	cpse	r24, r1
  8c:	00 c0       	rjmp	.+0      	; 0x8e <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_+0x8e>
  8e:	0c 15       	cp	r16, r12
  90:	1d 05       	cpc	r17, r13
  92:	01 f4       	brne	.+0      	; 0x94 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_+0x94>
  94:	51 2c       	mov	r5, r1
  96:	85 2d       	mov	r24, r5
  98:	c9 5b       	subi	r28, 0xB9	; 185
  9a:	df 4f       	sbci	r29, 0xFF	; 255
  9c:	0f b6       	in	r0, 0x3f	; 63
  9e:	f8 94       	cli
  a0:	de bf       	out	0x3e, r29	; 62
  a2:	0f be       	out	0x3f, r0	; 63
  a4:	cd bf       	out	0x3d, r28	; 61
  a6:	df 91       	pop	r29
  a8:	cf 91       	pop	r28
  aa:	1f 91       	pop	r17
  ac:	0f 91       	pop	r16
  ae:	ff 90       	pop	r15
  b0:	ef 90       	pop	r14
  b2:	df 90       	pop	r13
  b4:	cf 90       	pop	r12
  b6:	bf 90       	pop	r11
  b8:	af 90       	pop	r10
  ba:	9f 90       	pop	r9
  bc:	8f 90       	pop	r8
  be:	7f 90       	pop	r7
  c0:	6f 90       	pop	r6
  c2:	5f 90       	pop	r5
  c4:	4f 90       	pop	r4
  c6:	3f 90       	pop	r3
  c8:	08 95       	ret
  ca:	c8 01       	movw	r24, r16
  cc:	0e 94 00 00 	call	0	; 0x0 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_>
  d0:	00 c0       	rjmp	.+0      	; 0xd2 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_+0xd2>
  d2:	44 20       	and	r4, r4
  d4:	01 f0       	breq	.+0      	; 0xd6 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_+0xd6>
  d6:	21 e0       	ldi	r18, 0x01	; 1
  d8:	ae 01       	movw	r20, r28
  da:	47 5c       	subi	r20, 0xC7	; 199
  dc:	5f 4f       	sbci	r21, 0xFF	; 255
  de:	b8 01       	movw	r22, r16
  e0:	c7 01       	movw	r24, r14
  e2:	0e 94 00 00 	call	0	; 0x0 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_>
  e6:	58 2e       	mov	r5, r24
  e8:	0c 15       	cp	r16, r12
  ea:	1d 05       	cpc	r17, r13
  ec:	01 f0       	breq	.+0      	; 0xee <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_+0xee>
  ee:	c8 01       	movw	r24, r16
  f0:	0e 94 00 00 	call	0	; 0x0 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_>
  f4:	51 10       	cpse	r5, r1
  f6:	00 c0       	rjmp	.+0      	; 0xf8 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_+0xf8>
  f8:	00 c0       	rjmp	.+0      	; 0xfa <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_+0xfa>
  fa:	0c 15       	cp	r16, r12
  fc:	1d 05       	cpc	r17, r13
  fe:	01 f0       	breq	.+0      	; 0x100 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_+0x100>
 100:	c8 01       	movw	r24, r16
 102:	0e 94 00 00 	call	0	; 0x0 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_>
 106:	55 24       	eor	r5, r5
 108:	53 94       	inc	r5
 10a:	00 c0       	rjmp	.+0      	; 0x10c <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_+0x10c>
 10c:	88 23       	and	r24, r24
 10e:	01 f0       	breq	.+0      	; 0x110 <_Z8walkPathPcR6SdFilePFhS1_S_hPvES2_+0x110>
 110:	8e 01       	movw	r16, r28
 112:	0f 5f       	subi	r16, 0xFF	; 255
 114:	1f 4f       	sbci	r17, 0xFF	; 255
 116:	90 2f       	mov	r25, r16
 118:	81 2f       	mov	r24, r17
 11a:	87 01       	movw	r16, r14
 11c:	e9 2e       	mov	r14, r25
 11e:	f8 2e       	mov	r15, r24
 120:	00 c0       	rjmp	.+0      	; 0x122 <__SREG__+0xe3>

Disassembly of section .text._ZN7SDClass5beginEh:

00000000 <_ZN7SDClass5beginEh>:
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	ec 01       	movw	r28, r24
   a:	46 2f       	mov	r20, r22
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
   c:	61 e0       	ldi	r22, 0x01	; 1
   e:	0e 94 00 00 	call	0	; 0x0 <_ZN7SDClass5beginEh>
  12:	81 11       	cpse	r24, r1
  14:	00 c0       	rjmp	.+0      	; 0x16 <_ZN7SDClass5beginEh+0x16>
  16:	90 e0       	ldi	r25, 0x00	; 0
  18:	00 c0       	rjmp	.+0      	; 0x1a <_ZN7SDClass5beginEh+0x1a>
  1a:	8e 01       	movw	r16, r28
  1c:	04 5f       	subi	r16, 0xF4	; 244
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
  1e:	1f 4f       	sbci	r17, 0xFF	; 255
  20:	41 e0       	ldi	r20, 0x01	; 1
  22:	be 01       	movw	r22, r28
  24:	c8 01       	movw	r24, r16
  26:	0e 94 00 00 	call	0	; 0x0 <_ZN7SDClass5beginEh>
  2a:	88 23       	and	r24, r24
  2c:	01 f0       	breq	.+0      	; 0x2e <_ZN7SDClass5beginEh+0x2e>
  2e:	b8 01       	movw	r22, r16
  30:	ce 01       	movw	r24, r28
  32:	8a 96       	adiw	r24, 0x2a	; 42
  34:	0e 94 00 00 	call	0	; 0x0 <_ZN7SDClass5beginEh>
  38:	91 e0       	ldi	r25, 0x01	; 1
  3a:	88 23       	and	r24, r24
  3c:	01 f0       	breq	.+0      	; 0x3e <_ZN7SDClass5beginEh+0x3e>
  3e:	89 2f       	mov	r24, r25
  40:	df 91       	pop	r29
  42:	cf 91       	pop	r28
  44:	1f 91       	pop	r17
  46:	0f 91       	pop	r16
  48:	08 95       	ret
  4a:	40 e0       	ldi	r20, 0x00	; 0
  4c:	be 01       	movw	r22, r28
  4e:	c8 01       	movw	r24, r16
  50:	0e 94 00 00 	call	0	; 0x0 <_ZN7SDClass5beginEh>
  54:	88 23       	and	r24, r24
  56:	01 f0       	breq	.+0      	; 0x58 <_ZN7SDClass5beginEh+0x58>
  58:	00 c0       	rjmp	.+0      	; 0x5a <__SREG__+0x1b>

Disassembly of section .text._ZN7SDClass4openEPch:

00000000 <_ZN7SDClass4openEPch>:
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
   6:	ca 01       	movw	r24, r20
   8:	fb 01       	movw	r30, r22
   a:	ee 59       	subi	r30, 0x9E	; 158
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
   c:	ff 4f       	sbci	r31, 0xFF	; 255
   e:	30 e0       	ldi	r19, 0x00	; 0
  10:	31 83       	std	Z+1, r19	; 0x01
  12:	20 83       	st	Z, r18
  14:	f8 97       	sbiw	r30, 0x38	; 56
  16:	9b 01       	movw	r18, r22
  18:	40 e0       	ldi	r20, 0x00	; 0
  1a:	50 e0       	ldi	r21, 0x00	; 0
  1c:	bf 01       	movw	r22, r30
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
  1e:	0e 94 00 00 	call	0	; 0x0 <_ZN7SDClass4openEPch>
  22:	80 e0       	ldi	r24, 0x00	; 0
  24:	90 e0       	ldi	r25, 0x00	; 0
  26:	99 83       	std	Y+1, r25	; 0x01
  28:	88 83       	st	Y, r24
  2a:	ce 01       	movw	r24, r28
  2c:	df 91       	pop	r29
  2e:	cf 91       	pop	r28
  30:	08 95       	ret

Disassembly of section .text._ZN7SDClass6existsEPc:

00000000 <_ZN7SDClass6existsEPc>:
   0:	fb 01       	movw	r30, r22
   2:	bc 01       	movw	r22, r24
   4:	66 5d       	subi	r22, 0xD6	; 214
   6:	7f 4f       	sbci	r23, 0xFF	; 255
   8:	30 e0       	ldi	r19, 0x00	; 0
   a:	20 e0       	ldi	r18, 0x00	; 0
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
   c:	40 e0       	ldi	r20, 0x00	; 0
   e:	50 e0       	ldi	r21, 0x00	; 0
  10:	cf 01       	movw	r24, r30
  12:	0c 94 00 00 	jmp	0	; 0x0 <_ZN7SDClass6existsEPc>

Disassembly of section .text._ZN7SDClass5mkdirEPc:

00000000 <_ZN7SDClass5mkdirEPc>:
   0:	fb 01       	movw	r30, r22
   2:	bc 01       	movw	r22, r24
   4:	66 5d       	subi	r22, 0xD6	; 214
   6:	7f 4f       	sbci	r23, 0xFF	; 255
   8:	30 e0       	ldi	r19, 0x00	; 0
   a:	20 e0       	ldi	r18, 0x00	; 0
   c:	40 e0       	ldi	r20, 0x00	; 0
   e:	50 e0       	ldi	r21, 0x00	; 0
  10:	cf 01       	movw	r24, r30
  12:	0c 94 00 00 	jmp	0	; 0x0 <_ZN7SDClass5mkdirEPc>

Disassembly of section .text._ZN7SDClass5rmdirEPc:

00000000 <_ZN7SDClass5rmdirEPc>:
   0:	fb 01       	movw	r30, r22
   2:	bc 01       	movw	r22, r24
   4:	66 5d       	subi	r22, 0xD6	; 214
   6:	7f 4f       	sbci	r23, 0xFF	; 255
   8:	30 e0       	ldi	r19, 0x00	; 0
   a:	20 e0       	ldi	r18, 0x00	; 0
   c:	40 e0       	ldi	r20, 0x00	; 0
   e:	50 e0       	ldi	r21, 0x00	; 0
  10:	cf 01       	movw	r24, r30
  12:	0c 94 00 00 	jmp	0	; 0x0 <_ZN7SDClass5rmdirEPc>

Disassembly of section .text._ZN7SDClass6removeEPc:

00000000 <_ZN7SDClass6removeEPc>:
   0:	fb 01       	movw	r30, r22
   2:	bc 01       	movw	r22, r24
   4:	66 5d       	subi	r22, 0xD6	; 214
   6:	7f 4f       	sbci	r23, 0xFF	; 255
   8:	30 e0       	ldi	r19, 0x00	; 0
   a:	20 e0       	ldi	r18, 0x00	; 0
   c:	40 e0       	ldi	r20, 0x00	; 0
   e:	50 e0       	ldi	r21, 0x00	; 0
  10:	cf 01       	movw	r24, r30
  12:	0c 94 00 00 	jmp	0	; 0x0 <_ZN7SDClass6removeEPc>

Disassembly of section .text.startup._GLOBAL__sub_I__Z20getNextPathComponentPcPjS_:

00000000 <_GLOBAL__sub_I__Z20getNextPathComponentPcPjS_>:
   0:	e0 e0       	ldi	r30, 0x00	; 0
   2:	f0 e0       	ldi	r31, 0x00	; 0
   4:	15 82       	std	Z+5, r1	; 0x05
   6:	16 82       	std	Z+6, r1	; 0x06
   8:	11 86       	std	Z+9, r1	; 0x09
   a:	13 86       	std	Z+11, r1	; 0x0b
   c:	82 e0       	ldi	r24, 0x02	; 2
   e:	90 e0       	ldi	r25, 0x00	; 0
  10:	a0 e0       	ldi	r26, 0x00	; 0
  12:	b0 e0       	ldi	r27, 0x00	; 0
  14:	84 87       	std	Z+12, r24	; 0x0c
  16:	95 87       	std	Z+13, r25	; 0x0d
  18:	a6 87       	std	Z+14, r26	; 0x0e
  1a:	b7 87       	std	Z+15, r27	; 0x0f
  1c:	13 a2       	std	Z+35, r1	; 0x23
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
  1e:	80 e0       	ldi	r24, 0x00	; 0
  20:	90 e0       	ldi	r25, 0x00	; 0
  22:	93 a7       	std	Z+43, r25	; 0x2b
  24:	82 a7       	std	Z+42, r24	; 0x2a
  26:	16 a6       	std	Z+46, r1	; 0x2e
  28:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
  2c:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  30:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  34:	08 95       	ret

Sd2Card.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00001ddc  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00002a7b  00000000  00000000  00001e10  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text._ZL7spiSendh 0000000a  00000000  00000000  0000488b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text._ZL6spiRecv 0000000a  00000000  00000000  00004895  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text._ZN7Sd2Card14chipSelectHighEv 0000000a  00000000  00000000  0000489f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text._ZN7Sd2Card13chipSelectLowEv 0000000a  00000000  00000000  000048a9  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text._ZN7Sd2Card7readEndEv 00000044  00000000  00000000  000048b3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text._ZN7Sd2Card16partialBlockReadEh 00000018  00000000  00000000  000048f7  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text._ZN7Sd2Card10setSckRateEh 00000038  00000000  00000000  0000490f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text._ZN7Sd2Card11waitNotBusyEj 00000036  00000000  00000000  00004947  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text._ZN7Sd2Card11cardCommandEhm 0000009c  00000000  00000000  0000497d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text._ZN7Sd2Card4initEhh 0000019a  00000000  00000000  00004a19  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text._ZN7Sd2Card14waitStartBlockEv 0000004a  00000000  00000000  00004bb3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 16 .text._ZN7Sd2Card8readDataEmjjPh.part.5 00000116  00000000  00000000  00004bfd  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 17 .text._ZN7Sd2Card8readDataEmjjPh 00000020  00000000  00000000  00004d13  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 18 .text._ZN7Sd2Card9readBlockEmPh 00000020  00000000  00000000  00004d33  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 19 .text._ZN7Sd2Card12readRegisterEhPv 0000006a  00000000  00000000  00004d53  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 20 .text._ZN7Sd2Card8cardSizeEv 000000fc  00000000  00000000  00004dbd  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 21 .text._ZN7Sd2Card22eraseSingleBlockEnableEv 0000003e  00000000  00000000  00004eb9  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 22 .text._ZN7Sd2Card5eraseEmm 000000c4  00000000  00000000  00004ef7  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 23 .text._ZN7Sd2Card9writeDataEhPKh 0000005e  00000000  00000000  00004fbb  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 24 .text._ZN7Sd2Card10writeBlockEmPKh 0000009a  00000000  00000000  00005019  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 25 .text._ZN7Sd2Card9writeDataEPKh 00000040  00000000  00000000  000050b3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 26 .text._ZN7Sd2Card10writeStartEmm 0000009c  00000000  00000000  000050f3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 27 .text._ZN7Sd2Card9writeStopEv 00000042  00000000  00000000  0000518f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 28 .comment      00000012  00000000  00000000  000051d1  2**0
                  CONTENTS, READONLY

Disassembly of section .text._ZL7spiSendh:

00000000 <_ZL7spiSendh>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	8e bd       	out	0x2e, r24	; 46
   2:	0d b4       	in	r0, 0x2d	; 45
   4:	07 fe       	sbrs	r0, 7
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	00 c0       	rjmp	.+0      	; 0x8 <_ZL7spiSendh+0x8>
   8:	08 95       	ret

Disassembly of section .text._ZL6spiRecv:

00000000 <_ZL6spiRecv>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	8f ef       	ldi	r24, 0xFF	; 255
   2:	0e 94 00 00 	call	0	; 0x0 <_ZL6spiRecv>
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	8e b5       	in	r24, 0x2e	; 46
   8:	08 95       	ret

Disassembly of section .text._ZN7Sd2Card14chipSelectHighEv:

00000000 <_ZN7Sd2Card14chipSelectHighEv>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	61 e0       	ldi	r22, 0x01	; 1
   2:	fc 01       	movw	r30, r24
   4:	84 81       	ldd	r24, Z+4	; 0x04
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	0c 94 00 00 	jmp	0	; 0x0 <_ZN7Sd2Card14chipSelectHighEv>

Disassembly of section .text._ZN7Sd2Card13chipSelectLowEv:

00000000 <_ZN7Sd2Card13chipSelectLowEv>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	60 e0       	ldi	r22, 0x00	; 0
   2:	fc 01       	movw	r30, r24
   4:	84 81       	ldd	r24, Z+4	; 0x04
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	0c 94 00 00 	jmp	0	; 0x0 <_ZN7Sd2Card13chipSelectLowEv>

Disassembly of section .text._ZN7Sd2Card7readEndEv:

00000000 <_ZN7Sd2Card7readEndEv>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	8e 81       	ldd	r24, Y+6	; 0x06
   8:	88 23       	and	r24, r24
   a:	01 f0       	breq	.+0      	; 0xc <_ZN7Sd2Card7readEndEv+0xc>
   c:	8f ef       	ldi	r24, 0xFF	; 255
   e:	8e bd       	out	0x2e, r24	; 46
  10:	2f ef       	ldi	r18, 0xFF	; 255
  spiSend(STOP_TRAN_TOKEN);
  12:	8f 81       	ldd	r24, Y+7	; 0x07
  14:	98 85       	ldd	r25, Y+8	; 0x08
  16:	ac 01       	movw	r20, r24
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  18:	4f 5f       	subi	r20, 0xFF	; 255
  1a:	5f 4f       	sbci	r21, 0xFF	; 255
  1c:	58 87       	std	Y+8, r21	; 0x08
  1e:	4f 83       	std	Y+7, r20	; 0x07
  20:	81 30       	cpi	r24, 0x01	; 1
  22:	92 40       	sbci	r25, 0x02	; 2
  24:	00 f4       	brcc	.+0      	; 0x26 <_ZN7Sd2Card7readEndEv+0x26>
  chipSelectHigh();
  26:	0d b4       	in	r0, 0x2d	; 45
  28:	07 fe       	sbrs	r0, 7
  2a:	00 c0       	rjmp	.+0      	; 0x2c <_ZN7Sd2Card7readEndEv+0x2c>
  return true;
  2c:	2e bd       	out	0x2e, r18	; 46

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  return false;
}
  2e:	00 c0       	rjmp	.+0      	; 0x30 <_ZN7Sd2Card7readEndEv+0x30>
  30:	0d b4       	in	r0, 0x2d	; 45
  32:	07 fe       	sbrs	r0, 7
  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {
    cardCommand(CMD55, 0);
    return cardCommand(cmd, arg);
  }
  uint8_t cardCommand(uint8_t cmd, uint32_t arg);
  void error(uint8_t code) {errorCode_ = code;}
  34:	00 c0       	rjmp	.+0      	; 0x36 <_ZN7Sd2Card7readEndEv+0x36>
  36:	ce 01       	movw	r24, r28
  chipSelectHigh();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  38:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card7readEndEv>
  3c:	1e 82       	std	Y+6, r1	; 0x06
  return false;
  3e:	df 91       	pop	r29
  40:	cf 91       	pop	r28
  42:	08 95       	ret

Disassembly of section .text._ZN7Sd2Card16partialBlockReadEh:

00000000 <_ZN7Sd2Card16partialBlockReadEh>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	ec 01       	movw	r28, r24
   8:	16 2f       	mov	r17, r22
   a:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card16partialBlockReadEh>
   e:	19 87       	std	Y+9, r17	; 0x09
  10:	df 91       	pop	r29
  spiSend(STOP_TRAN_TOKEN);
  12:	cf 91       	pop	r28
  14:	1f 91       	pop	r17
  16:	08 95       	ret

Disassembly of section .text._ZN7Sd2Card10setSckRateEh:

00000000 <_ZN7Sd2Card10setSckRateEh>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	67 30       	cpi	r22, 0x07	; 7
   2:	00 f0       	brcs	.+0      	; 0x4 <_ZN7Sd2Card10setSckRateEh+0x4>
   4:	26 e1       	ldi	r18, 0x16	; 22
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	fc 01       	movw	r30, r24
   8:	25 83       	std	Z+5, r18	; 0x05
   a:	80 e0       	ldi	r24, 0x00	; 0
   c:	08 95       	ret
   e:	26 2f       	mov	r18, r22
  10:	30 e0       	ldi	r19, 0x00	; 0
  spiSend(STOP_TRAN_TOKEN);
  12:	8d b5       	in	r24, 0x2d	; 45
  14:	60 fd       	sbrc	r22, 0
  16:	00 c0       	rjmp	.+0      	; 0x18 <_ZN7Sd2Card10setSckRateEh+0x18>
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  18:	66 30       	cpi	r22, 0x06	; 6
  1a:	01 f4       	brne	.+0      	; 0x1c <_ZN7Sd2Card10setSckRateEh+0x1c>
  1c:	8e 7f       	andi	r24, 0xFE	; 254
  1e:	8d bd       	out	0x2d, r24	; 45
  20:	8c b5       	in	r24, 0x2c	; 44
  22:	8c 7f       	andi	r24, 0xFC	; 252
  24:	8c bd       	out	0x2c, r24	; 44
  chipSelectHigh();
  26:	8c b5       	in	r24, 0x2c	; 44
  28:	35 95       	asr	r19
  2a:	27 95       	ror	r18
  return true;
  2c:	82 2b       	or	r24, r18

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  return false;
}
  2e:	8c bd       	out	0x2c, r24	; 44
  30:	81 e0       	ldi	r24, 0x01	; 1
  32:	08 95       	ret
  34:	81 60       	ori	r24, 0x01	; 1
  36:	00 c0       	rjmp	.+0      	; 0x38 <__zero_reg__+0x37>

Disassembly of section .text._ZN7Sd2Card11waitNotBusyEj:

00000000 <_ZN7Sd2Card11waitNotBusyEj>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	df 93       	push	r29
   8:	eb 01       	movw	r28, r22
   a:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card11waitNotBusyEj>
   e:	8b 01       	movw	r16, r22
  10:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card11waitNotBusyEj>
  spiSend(STOP_TRAN_TOKEN);
  14:	8f 3f       	cpi	r24, 0xFF	; 255
  16:	01 f0       	breq	.+0      	; 0x18 <_ZN7Sd2Card11waitNotBusyEj+0x18>
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  18:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card11waitNotBusyEj>
  1c:	60 1b       	sub	r22, r16
  1e:	71 0b       	sbc	r23, r17
  20:	6c 17       	cp	r22, r28
  22:	7d 07       	cpc	r23, r29
  24:	00 f0       	brcs	.+0      	; 0x26 <_ZN7Sd2Card11waitNotBusyEj+0x26>
  chipSelectHigh();
  26:	80 e0       	ldi	r24, 0x00	; 0
  28:	df 91       	pop	r29
  2a:	cf 91       	pop	r28
  return true;
  2c:	1f 91       	pop	r17

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  return false;
}
  2e:	0f 91       	pop	r16
  30:	08 95       	ret
  32:	81 e0       	ldi	r24, 0x01	; 1
  34:	00 c0       	rjmp	.+0      	; 0x36 <__zero_reg__+0x35>

Disassembly of section .text._ZN7Sd2Card11cardCommandEhm:

00000000 <_ZN7Sd2Card11cardCommandEhm>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	bf 92       	push	r11
   8:	ff 92       	push	r15
   a:	0f 93       	push	r16
   c:	1f 93       	push	r17
   e:	cf 93       	push	r28
  10:	df 93       	push	r29
  spiSend(STOP_TRAN_TOKEN);
  12:	ec 01       	movw	r28, r24
  14:	f6 2e       	mov	r15, r22
  16:	49 01       	movw	r8, r18
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  18:	5a 01       	movw	r10, r20
  1a:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card11cardCommandEhm>
  1e:	ce 01       	movw	r24, r28
  20:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card11cardCommandEhm>
  24:	6c e2       	ldi	r22, 0x2C	; 44
  chipSelectHigh();
  26:	71 e0       	ldi	r23, 0x01	; 1
  28:	ce 01       	movw	r24, r28
  2a:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card11cardCommandEhm>

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  return false;
}
  2e:	8f 2d       	mov	r24, r15
  30:	80 64       	ori	r24, 0x40	; 64
  32:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card11cardCommandEhm>
  36:	08 e1       	ldi	r16, 0x18	; 24
  chipSelectHigh();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  38:	10 e0       	ldi	r17, 0x00	; 0
  3a:	d5 01       	movw	r26, r10
  3c:	c4 01       	movw	r24, r8
  return false;
  3e:	00 2e       	mov	r0, r16
  40:	00 c0       	rjmp	.+0      	; 0x42 <_ZN7Sd2Card11cardCommandEhm+0x42>
  42:	b6 95       	lsr	r27
  44:	a7 95       	ror	r26
  46:	97 95       	ror	r25
  48:	87 95       	ror	r24
  4a:	0a 94       	dec	r0
  4c:	02 f4       	brpl	.+0      	; 0x4e <_ZN7Sd2Card11cardCommandEhm+0x4e>
  4e:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card11cardCommandEhm>
  52:	08 50       	subi	r16, 0x08	; 8
  54:	11 09       	sbc	r17, r1
  56:	08 3f       	cpi	r16, 0xF8	; 248
  58:	8f ef       	ldi	r24, 0xFF	; 255
  5a:	18 07       	cpc	r17, r24
  5c:	01 f4       	brne	.+0      	; 0x5e <_ZN7Sd2Card11cardCommandEhm+0x5e>
  5e:	85 e9       	ldi	r24, 0x95	; 149
  60:	ff 20       	and	r15, r15
  62:	01 f0       	breq	.+0      	; 0x64 <_ZN7Sd2Card11cardCommandEhm+0x64>
  64:	88 e0       	ldi	r24, 0x08	; 8
  66:	f8 12       	cpse	r15, r24
  68:	00 c0       	rjmp	.+0      	; 0x6a <_ZN7Sd2Card11cardCommandEhm+0x6a>
  6a:	87 e8       	ldi	r24, 0x87	; 135
  6c:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card11cardCommandEhm>
  70:	10 e0       	ldi	r17, 0x00	; 0
  72:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card11cardCommandEhm>
  76:	8a 87       	std	Y+10, r24	; 0x0a
  78:	87 ff       	sbrs	r24, 7
  7a:	00 c0       	rjmp	.+0      	; 0x7c <_ZN7Sd2Card11cardCommandEhm+0x7c>
  7c:	1f 3f       	cpi	r17, 0xFF	; 255
  7e:	01 f0       	breq	.+0      	; 0x80 <_ZN7Sd2Card11cardCommandEhm+0x80>
  80:	1f 5f       	subi	r17, 0xFF	; 255
  82:	00 c0       	rjmp	.+0      	; 0x84 <_ZN7Sd2Card11cardCommandEhm+0x84>
  84:	8f ef       	ldi	r24, 0xFF	; 255
  86:	00 c0       	rjmp	.+0      	; 0x88 <_ZN7Sd2Card11cardCommandEhm+0x88>
  88:	df 91       	pop	r29
  8a:	cf 91       	pop	r28
  8c:	1f 91       	pop	r17
  8e:	0f 91       	pop	r16
  90:	ff 90       	pop	r15
  92:	bf 90       	pop	r11
  94:	af 90       	pop	r10
  96:	9f 90       	pop	r9
  98:	8f 90       	pop	r8
  9a:	08 95       	ret

Disassembly of section .text._ZN7Sd2Card4initEhh:

00000000 <_ZN7Sd2Card4initEhh>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	bf 92       	push	r11
   8:	ef 92       	push	r14
   a:	ff 92       	push	r15
   c:	0f 93       	push	r16
   e:	1f 93       	push	r17
  10:	cf 93       	push	r28
  spiSend(STOP_TRAN_TOKEN);
  12:	df 93       	push	r29
  14:	ec 01       	movw	r28, r24
  16:	e6 2e       	mov	r14, r22
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  18:	1b 86       	std	Y+11, r1	; 0x0b
  1a:	19 86       	std	Y+9, r1	; 0x09
  1c:	1e 82       	std	Y+6, r1	; 0x06
  1e:	1d 82       	std	Y+5, r1	; 0x05
  20:	4c 83       	std	Y+4, r20	; 0x04
  22:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
  chipSelectHigh();
  26:	8b 01       	movw	r16, r22
  28:	61 e0       	ldi	r22, 0x01	; 1
  2a:	8c 81       	ldd	r24, Y+4	; 0x04
  return true;
  2c:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  return false;
}
  30:	ce 01       	movw	r24, r28
  32:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
  36:	60 e0       	ldi	r22, 0x00	; 0
  chipSelectHigh();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  38:	8c e0       	ldi	r24, 0x0C	; 12
  3a:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
  return false;
  3e:	61 e0       	ldi	r22, 0x01	; 1
  40:	8b e0       	ldi	r24, 0x0B	; 11
  42:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
  46:	61 e0       	ldi	r22, 0x01	; 1
  48:	8d e0       	ldi	r24, 0x0D	; 13
  4a:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
  4e:	61 e0       	ldi	r22, 0x01	; 1
  50:	8a e0       	ldi	r24, 0x0A	; 10
  52:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
  56:	61 e0       	ldi	r22, 0x01	; 1
  58:	8a e0       	ldi	r24, 0x0A	; 10
  5a:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
  5e:	83 e5       	ldi	r24, 0x53	; 83
  60:	8c bd       	out	0x2c, r24	; 44
  62:	8d b5       	in	r24, 0x2d	; 45
  64:	8e 7f       	andi	r24, 0xFE	; 254
  66:	8d bd       	out	0x2d, r24	; 45
  68:	2a e0       	ldi	r18, 0x0A	; 10
  6a:	f2 2e       	mov	r15, r18
  6c:	8f ef       	ldi	r24, 0xFF	; 255
  6e:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
  72:	fa 94       	dec	r15
  74:	f1 10       	cpse	r15, r1
  76:	00 c0       	rjmp	.+0      	; 0x78 <_ZN7Sd2Card4initEhh+0x78>
  78:	ce 01       	movw	r24, r28
  7a:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
  7e:	20 e0       	ldi	r18, 0x00	; 0
  80:	30 e0       	ldi	r19, 0x00	; 0
  82:	a9 01       	movw	r20, r18
  84:	60 e0       	ldi	r22, 0x00	; 0
  86:	ce 01       	movw	r24, r28
  88:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
  8c:	f8 2e       	mov	r15, r24
  8e:	8a 87       	std	Y+10, r24	; 0x0a
  90:	81 e0       	ldi	r24, 0x01	; 1
  92:	f8 16       	cp	r15, r24
  94:	01 f0       	breq	.+0      	; 0x96 <_ZN7Sd2Card4initEhh+0x96>
  96:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
  9a:	60 1b       	sub	r22, r16
  9c:	71 0b       	sbc	r23, r17
  9e:	61 3d       	cpi	r22, 0xD1	; 209
  a0:	77 40       	sbci	r23, 0x07	; 7
  a2:	00 f0       	brcs	.+0      	; 0xa4 <_ZN7Sd2Card4initEhh+0xa4>
  a4:	81 e0       	ldi	r24, 0x01	; 1
  a6:	8d 83       	std	Y+5, r24	; 0x05
  a8:	ce 01       	movw	r24, r28
  aa:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
  ae:	80 e0       	ldi	r24, 0x00	; 0
  b0:	df 91       	pop	r29
  b2:	cf 91       	pop	r28
  b4:	1f 91       	pop	r17
  b6:	0f 91       	pop	r16
  b8:	ff 90       	pop	r15
  ba:	ef 90       	pop	r14
  bc:	bf 90       	pop	r11
  be:	af 90       	pop	r10
  c0:	9f 90       	pop	r9
  c2:	8f 90       	pop	r8
  c4:	08 95       	ret
  c6:	2a ea       	ldi	r18, 0xAA	; 170
  c8:	31 e0       	ldi	r19, 0x01	; 1
  ca:	40 e0       	ldi	r20, 0x00	; 0
  cc:	50 e0       	ldi	r21, 0x00	; 0
  ce:	68 e0       	ldi	r22, 0x08	; 8
  d0:	ce 01       	movw	r24, r28
  d2:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
  d6:	82 ff       	sbrs	r24, 2
  d8:	00 c0       	rjmp	.+0      	; 0xda <_ZN7Sd2Card4initEhh+0xda>
  da:	fb 86       	std	Y+11, r15	; 0x0b
  dc:	8b 85       	ldd	r24, Y+11	; 0x0b
  de:	81 2c       	mov	r8, r1
  e0:	91 2c       	mov	r9, r1
  e2:	54 01       	movw	r10, r8
  e4:	82 30       	cpi	r24, 0x02	; 2
  e6:	01 f4       	brne	.+0      	; 0xe8 <_ZN7Sd2Card4initEhh+0xe8>
  e8:	81 2c       	mov	r8, r1
  ea:	91 2c       	mov	r9, r1
  ec:	a1 2c       	mov	r10, r1
  ee:	80 e4       	ldi	r24, 0x40	; 64
  f0:	b8 2e       	mov	r11, r24
  f2:	20 e0       	ldi	r18, 0x00	; 0
  f4:	30 e0       	ldi	r19, 0x00	; 0
  f6:	a9 01       	movw	r20, r18
  f8:	67 e3       	ldi	r22, 0x37	; 55
  fa:	ce 01       	movw	r24, r28
  fc:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
 100:	a5 01       	movw	r20, r10
 102:	94 01       	movw	r18, r8
 104:	69 e2       	ldi	r22, 0x29	; 41
 106:	ce 01       	movw	r24, r28
 108:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
 10c:	8a 87       	std	Y+10, r24	; 0x0a
 10e:	88 23       	and	r24, r24
 110:	01 f0       	breq	.+0      	; 0x112 <_ZN7Sd2Card4initEhh+0x112>
 112:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
 116:	60 1b       	sub	r22, r16
 118:	71 0b       	sbc	r23, r17
 11a:	61 3d       	cpi	r22, 0xD1	; 209
 11c:	77 40       	sbci	r23, 0x07	; 7
 11e:	00 f0       	brcs	.+0      	; 0x120 <_ZN7Sd2Card4initEhh+0x120>
 120:	88 e0       	ldi	r24, 0x08	; 8
 122:	00 c0       	rjmp	.+0      	; 0x124 <_ZN7Sd2Card4initEhh+0x124>
 124:	94 e0       	ldi	r25, 0x04	; 4
 126:	f9 2e       	mov	r15, r25
 128:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
 12c:	8a 87       	std	Y+10, r24	; 0x0a
 12e:	fa 94       	dec	r15
 130:	f1 10       	cpse	r15, r1
 132:	00 c0       	rjmp	.+0      	; 0x134 <_ZN7Sd2Card4initEhh+0x134>
 134:	8a 3a       	cpi	r24, 0xAA	; 170
 136:	01 f0       	breq	.+0      	; 0x138 <_ZN7Sd2Card4initEhh+0x138>
 138:	82 e0       	ldi	r24, 0x02	; 2
 13a:	00 c0       	rjmp	.+0      	; 0x13c <_ZN7Sd2Card4initEhh+0x13c>
 13c:	82 e0       	ldi	r24, 0x02	; 2
 13e:	8b 87       	std	Y+11, r24	; 0x0b
 140:	00 c0       	rjmp	.+0      	; 0x142 <_ZN7Sd2Card4initEhh+0x142>
 142:	8b 85       	ldd	r24, Y+11	; 0x0b
 144:	82 30       	cpi	r24, 0x02	; 2
 146:	01 f4       	brne	.+0      	; 0x148 <_ZN7Sd2Card4initEhh+0x148>
 148:	20 e0       	ldi	r18, 0x00	; 0
 14a:	30 e0       	ldi	r19, 0x00	; 0
 14c:	a9 01       	movw	r20, r18
 14e:	6a e3       	ldi	r22, 0x3A	; 58
 150:	ce 01       	movw	r24, r28
 152:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
 156:	88 23       	and	r24, r24
 158:	01 f0       	breq	.+0      	; 0x15a <_ZN7Sd2Card4initEhh+0x15a>
 15a:	86 e0       	ldi	r24, 0x06	; 6
 15c:	00 c0       	rjmp	.+0      	; 0x15e <_ZN7Sd2Card4initEhh+0x15e>
 15e:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
 162:	80 7c       	andi	r24, 0xC0	; 192
 164:	80 3c       	cpi	r24, 0xC0	; 192
 166:	01 f4       	brne	.+0      	; 0x168 <_ZN7Sd2Card4initEhh+0x168>
 168:	83 e0       	ldi	r24, 0x03	; 3
 16a:	8b 87       	std	Y+11, r24	; 0x0b
 16c:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
 170:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
 174:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
 178:	ce 01       	movw	r24, r28
 17a:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card4initEhh>
 17e:	6e 2d       	mov	r22, r14
 180:	ce 01       	movw	r24, r28
 182:	df 91       	pop	r29
 184:	cf 91       	pop	r28
 186:	1f 91       	pop	r17
 188:	0f 91       	pop	r16
 18a:	ff 90       	pop	r15
 18c:	ef 90       	pop	r14
 18e:	bf 90       	pop	r11
 190:	af 90       	pop	r10
 192:	9f 90       	pop	r9
 194:	8f 90       	pop	r8
 196:	0c 94 00 00 	jmp	0	; 0x0 <_ZN7Sd2Card4initEhh>

Disassembly of section .text._ZN7Sd2Card14waitStartBlockEv:

00000000 <_ZN7Sd2Card14waitStartBlockEv>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	df 93       	push	r29
   8:	ec 01       	movw	r28, r24
   a:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card14waitStartBlockEv>
   e:	8b 01       	movw	r16, r22
  10:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card14waitStartBlockEv>
  spiSend(STOP_TRAN_TOKEN);
  14:	8a 87       	std	Y+10, r24	; 0x0a
  16:	8f 3f       	cpi	r24, 0xFF	; 255
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  18:	01 f4       	brne	.+0      	; 0x1a <_ZN7Sd2Card14waitStartBlockEv+0x1a>
  1a:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card14waitStartBlockEv>
  1e:	60 1b       	sub	r22, r16
  20:	71 0b       	sbc	r23, r17
  22:	6d 32       	cpi	r22, 0x2D	; 45
  24:	71 40       	sbci	r23, 0x01	; 1
  chipSelectHigh();
  26:	00 f0       	brcs	.+0      	; 0x28 <_ZN7Sd2Card14waitStartBlockEv+0x28>
  28:	8f e0       	ldi	r24, 0x0F	; 15
  2a:	8d 83       	std	Y+5, r24	; 0x05
  return true;
  2c:	ce 01       	movw	r24, r28

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  return false;
}
  2e:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card14waitStartBlockEv>
  32:	80 e0       	ldi	r24, 0x00	; 0
  34:	df 91       	pop	r29
  36:	cf 91       	pop	r28
  chipSelectHigh();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  38:	1f 91       	pop	r17
  3a:	0f 91       	pop	r16
  3c:	08 95       	ret
  return false;
  3e:	8e 3f       	cpi	r24, 0xFE	; 254
  40:	01 f0       	breq	.+0      	; 0x42 <_ZN7Sd2Card14waitStartBlockEv+0x42>
  42:	8d e0       	ldi	r24, 0x0D	; 13
  44:	00 c0       	rjmp	.+0      	; 0x46 <_ZN7Sd2Card14waitStartBlockEv+0x46>
  46:	81 e0       	ldi	r24, 0x01	; 1
  48:	00 c0       	rjmp	.+0      	; 0x4a <__SREG__+0xb>

Disassembly of section .text._ZN7Sd2Card8readDataEmjjPh.part.5:

00000000 <_ZN7Sd2Card8readDataEmjjPh.part.5>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	ec 01       	movw	r28, r24
  spiSend(STOP_TRAN_TOKEN);
  12:	69 01       	movw	r12, r18
  14:	c8 01       	movw	r24, r16
  16:	82 0f       	add	r24, r18
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  18:	93 1f       	adc	r25, r19
  1a:	81 30       	cpi	r24, 0x01	; 1
  1c:	92 40       	sbci	r25, 0x02	; 2
  1e:	00 f4       	brcc	.+0      	; 0x20 <_ZN7Sd2Card8readDataEmjjPh.part.5+0x20>
  20:	8e 81       	ldd	r24, Y+6	; 0x06
  22:	88 23       	and	r24, r24
  24:	01 f0       	breq	.+0      	; 0x26 <_ZN7Sd2Card8readDataEmjjPh.part.5+0x26>
  chipSelectHigh();
  26:	88 81       	ld	r24, Y
  28:	99 81       	ldd	r25, Y+1	; 0x01
  2a:	aa 81       	ldd	r26, Y+2	; 0x02
  return true;
  2c:	bb 81       	ldd	r27, Y+3	; 0x03

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  return false;
}
  2e:	84 17       	cp	r24, r20
  30:	95 07       	cpc	r25, r21
  32:	a6 07       	cpc	r26, r22
  34:	b7 07       	cpc	r27, r23
  36:	01 f4       	brne	.+0      	; 0x38 <_ZN7Sd2Card8readDataEmjjPh.part.5+0x38>
  chipSelectHigh();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  38:	8f 81       	ldd	r24, Y+7	; 0x07
  3a:	98 85       	ldd	r25, Y+8	; 0x08
  3c:	c8 16       	cp	r12, r24
  return false;
  3e:	d9 06       	cpc	r13, r25
  40:	00 f4       	brcc	.+0      	; 0x42 <_ZN7Sd2Card8readDataEmjjPh.part.5+0x42>
  42:	48 83       	st	Y, r20
  44:	59 83       	std	Y+1, r21	; 0x01
  46:	6a 83       	std	Y+2, r22	; 0x02
  48:	7b 83       	std	Y+3, r23	; 0x03
  4a:	8b 85       	ldd	r24, Y+11	; 0x0b
  4c:	83 30       	cpi	r24, 0x03	; 3
  4e:	01 f0       	breq	.+0      	; 0x50 <_ZN7Sd2Card8readDataEmjjPh.part.5+0x50>
  50:	89 e0       	ldi	r24, 0x09	; 9
  52:	44 0f       	add	r20, r20
  54:	55 1f       	adc	r21, r21
  56:	66 1f       	adc	r22, r22
  58:	77 1f       	adc	r23, r23
  5a:	8a 95       	dec	r24
  5c:	01 f4       	brne	.+0      	; 0x5e <_ZN7Sd2Card8readDataEmjjPh.part.5+0x5e>
  5e:	9a 01       	movw	r18, r20
  60:	ab 01       	movw	r20, r22
  62:	61 e1       	ldi	r22, 0x11	; 17
  64:	ce 01       	movw	r24, r28
  66:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card8readDataEmjjPh.part.5>
  6a:	88 23       	and	r24, r24
  6c:	01 f0       	breq	.+0      	; 0x6e <_ZN7Sd2Card8readDataEmjjPh.part.5+0x6e>
  6e:	83 e0       	ldi	r24, 0x03	; 3
  70:	8d 83       	std	Y+5, r24	; 0x05
  72:	ce 01       	movw	r24, r28
  74:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card8readDataEmjjPh.part.5>
  78:	80 e0       	ldi	r24, 0x00	; 0
  7a:	df 91       	pop	r29
  7c:	cf 91       	pop	r28
  7e:	1f 91       	pop	r17
  80:	0f 91       	pop	r16
  82:	ff 90       	pop	r15
  84:	ef 90       	pop	r14
  86:	df 90       	pop	r13
  88:	cf 90       	pop	r12
  8a:	08 95       	ret
  8c:	ce 01       	movw	r24, r28
  8e:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card8readDataEmjjPh.part.5>
  92:	88 23       	and	r24, r24
  94:	01 f0       	breq	.+0      	; 0x96 <_ZN7Sd2Card8readDataEmjjPh.part.5+0x96>
  96:	18 86       	std	Y+8, r1	; 0x08
  98:	1f 82       	std	Y+7, r1	; 0x07
  9a:	81 e0       	ldi	r24, 0x01	; 1
  9c:	8e 83       	std	Y+6, r24	; 0x06
  9e:	8f ef       	ldi	r24, 0xFF	; 255
  a0:	8e bd       	out	0x2e, r24	; 46
  a2:	2f ef       	ldi	r18, 0xFF	; 255
  a4:	8f 81       	ldd	r24, Y+7	; 0x07
  a6:	98 85       	ldd	r25, Y+8	; 0x08
  a8:	8c 15       	cp	r24, r12
  aa:	9d 05       	cpc	r25, r13
  ac:	00 f4       	brcc	.+0      	; 0xae <_ZN7Sd2Card8readDataEmjjPh.part.5+0xae>
  ae:	0d b4       	in	r0, 0x2d	; 45
  b0:	07 fe       	sbrs	r0, 7
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <_ZN7Sd2Card8readDataEmjjPh.part.5+0xb4>
  b4:	2e bd       	out	0x2e, r18	; 46
  b6:	8f 81       	ldd	r24, Y+7	; 0x07
  b8:	98 85       	ldd	r25, Y+8	; 0x08
  ba:	01 96       	adiw	r24, 0x01	; 1
  bc:	98 87       	std	Y+8, r25	; 0x08
  be:	8f 83       	std	Y+7, r24	; 0x07
  c0:	00 c0       	rjmp	.+0      	; 0xc2 <_ZN7Sd2Card8readDataEmjjPh.part.5+0xc2>
  c2:	c8 01       	movw	r24, r16
  c4:	01 97       	sbiw	r24, 0x01	; 1
  c6:	f7 01       	movw	r30, r14
  c8:	2f ef       	ldi	r18, 0xFF	; 255
  ca:	af 01       	movw	r20, r30
  cc:	4e 19       	sub	r20, r14
  ce:	5f 09       	sbc	r21, r15
  d0:	48 17       	cp	r20, r24
  d2:	59 07       	cpc	r21, r25
  d4:	00 f4       	brcc	.+0      	; 0xd6 <_ZN7Sd2Card8readDataEmjjPh.part.5+0xd6>
  d6:	0d b4       	in	r0, 0x2d	; 45
  d8:	07 fe       	sbrs	r0, 7
  da:	00 c0       	rjmp	.+0      	; 0xdc <_ZN7Sd2Card8readDataEmjjPh.part.5+0xdc>
  dc:	3e b5       	in	r19, 0x2e	; 46
  de:	31 93       	st	Z+, r19
  e0:	2e bd       	out	0x2e, r18	; 46
  e2:	00 c0       	rjmp	.+0      	; 0xe4 <_ZN7Sd2Card8readDataEmjjPh.part.5+0xe4>
  e4:	0d b4       	in	r0, 0x2d	; 45
  e6:	07 fe       	sbrs	r0, 7
  e8:	00 c0       	rjmp	.+0      	; 0xea <_ZN7Sd2Card8readDataEmjjPh.part.5+0xea>
  ea:	2e b5       	in	r18, 0x2e	; 46
  ec:	e8 0e       	add	r14, r24
  ee:	f9 1e       	adc	r15, r25
  f0:	f7 01       	movw	r30, r14
  f2:	20 83       	st	Z, r18
  f4:	8f 81       	ldd	r24, Y+7	; 0x07
  f6:	98 85       	ldd	r25, Y+8	; 0x08
  f8:	08 0f       	add	r16, r24
  fa:	19 1f       	adc	r17, r25
  fc:	18 87       	std	Y+8, r17	; 0x08
  fe:	0f 83       	std	Y+7, r16	; 0x07
 100:	89 85       	ldd	r24, Y+9	; 0x09
 102:	88 23       	and	r24, r24
 104:	01 f0       	breq	.+0      	; 0x106 <_ZN7Sd2Card8readDataEmjjPh.part.5+0x106>
 106:	01 15       	cp	r16, r1
 108:	12 40       	sbci	r17, 0x02	; 2
 10a:	00 f0       	brcs	.+0      	; 0x10c <_ZN7Sd2Card8readDataEmjjPh.part.5+0x10c>
 10c:	ce 01       	movw	r24, r28
 10e:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card8readDataEmjjPh.part.5>
 112:	81 e0       	ldi	r24, 0x01	; 1
 114:	00 c0       	rjmp	.+0      	; 0x116 <__SREG__+0xd7>

Disassembly of section .text._ZN7Sd2Card8readDataEmjjPh:

00000000 <_ZN7Sd2Card8readDataEmjjPh>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	1f 93       	push	r17
   8:	01 15       	cp	r16, r1
   a:	11 05       	cpc	r17, r1
   c:	01 f0       	breq	.+0      	; 0xe <_ZN7Sd2Card8readDataEmjjPh+0xe>
   e:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card8readDataEmjjPh>
  spiSend(STOP_TRAN_TOKEN);
  12:	1f 91       	pop	r17
  14:	0f 91       	pop	r16
  16:	ff 90       	pop	r15
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  18:	ef 90       	pop	r14
  1a:	08 95       	ret
  1c:	81 e0       	ldi	r24, 0x01	; 1
  1e:	00 c0       	rjmp	.+0      	; 0x20 <__zero_reg__+0x1f>

Disassembly of section .text._ZN7Sd2Card9readBlockEmPh:

00000000 <_ZN7Sd2Card9readBlockEmPh>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	1f 93       	push	r17
   8:	79 01       	movw	r14, r18
   a:	00 e0       	ldi	r16, 0x00	; 0
   c:	12 e0       	ldi	r17, 0x02	; 2
   e:	30 e0       	ldi	r19, 0x00	; 0
  10:	20 e0       	ldi	r18, 0x00	; 0
  spiSend(STOP_TRAN_TOKEN);
  12:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card9readBlockEmPh>
  16:	1f 91       	pop	r17
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  18:	0f 91       	pop	r16
  1a:	ff 90       	pop	r15
  1c:	ef 90       	pop	r14
  1e:	08 95       	ret

Disassembly of section .text._ZN7Sd2Card12readRegisterEhPv:

00000000 <_ZN7Sd2Card12readRegisterEhPv>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	1f 93       	push	r17
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	8c 01       	movw	r16, r24
   e:	7a 01       	movw	r14, r20
  10:	20 e0       	ldi	r18, 0x00	; 0
  spiSend(STOP_TRAN_TOKEN);
  12:	30 e0       	ldi	r19, 0x00	; 0
  14:	a9 01       	movw	r20, r18
  16:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card12readRegisterEhPv>
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  1a:	88 23       	and	r24, r24
  1c:	01 f0       	breq	.+0      	; 0x1e <_ZN7Sd2Card12readRegisterEhPv+0x1e>
  1e:	8e e0       	ldi	r24, 0x0E	; 14
  20:	f8 01       	movw	r30, r16
  22:	85 83       	std	Z+5, r24	; 0x05
  24:	c8 01       	movw	r24, r16
  chipSelectHigh();
  26:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card12readRegisterEhPv>
  2a:	80 e0       	ldi	r24, 0x00	; 0
  return true;
  2c:	00 c0       	rjmp	.+0      	; 0x2e <_ZN7Sd2Card12readRegisterEhPv+0x2e>

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  return false;
}
  2e:	c8 01       	movw	r24, r16
  30:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card12readRegisterEhPv>
  34:	88 23       	and	r24, r24
  36:	01 f0       	breq	.+0      	; 0x38 <_ZN7Sd2Card12readRegisterEhPv+0x38>
  chipSelectHigh();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  38:	e7 01       	movw	r28, r14
  3a:	f0 e1       	ldi	r31, 0x10	; 16
  3c:	ef 0e       	add	r14, r31
  return false;
  3e:	f1 1c       	adc	r15, r1
  40:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card12readRegisterEhPv>
  44:	89 93       	st	Y+, r24
  46:	ce 15       	cp	r28, r14
  48:	df 05       	cpc	r29, r15
  4a:	01 f4       	brne	.+0      	; 0x4c <_ZN7Sd2Card12readRegisterEhPv+0x4c>
  4c:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card12readRegisterEhPv>
  50:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card12readRegisterEhPv>
  54:	c8 01       	movw	r24, r16
  56:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card12readRegisterEhPv>
  5a:	81 e0       	ldi	r24, 0x01	; 1
  5c:	df 91       	pop	r29
  5e:	cf 91       	pop	r28
  60:	1f 91       	pop	r17
  62:	0f 91       	pop	r16
  64:	ff 90       	pop	r15
  66:	ef 90       	pop	r14
  68:	08 95       	ret

Disassembly of section .text._ZN7Sd2Card8cardSizeEv:

00000000 <_ZN7Sd2Card8cardSizeEv>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	df 93       	push	r29
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	60 97       	sbiw	r28, 0x10	; 16
   e:	0f b6       	in	r0, 0x3f	; 63
  10:	f8 94       	cli
  spiSend(STOP_TRAN_TOKEN);
  12:	de bf       	out	0x3e, r29	; 62
  14:	0f be       	out	0x3f, r0	; 63
  16:	cd bf       	out	0x3d, r28	; 61
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  18:	8c 01       	movw	r16, r24
  1a:	ae 01       	movw	r20, r28
  1c:	4f 5f       	subi	r20, 0xFF	; 255
  1e:	5f 4f       	sbci	r21, 0xFF	; 255
  20:	69 e0       	ldi	r22, 0x09	; 9
  22:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card8cardSizeEv>
  chipSelectHigh();
  26:	88 23       	and	r24, r24
  28:	01 f4       	brne	.+0      	; 0x2a <_ZN7Sd2Card8cardSizeEv+0x2a>
  2a:	00 c0       	rjmp	.+0      	; 0x2c <_ZN7Sd2Card8cardSizeEv+0x2c>
  return true;
  2c:	89 81       	ldd	r24, Y+1	; 0x01

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  return false;
}
  2e:	80 7c       	andi	r24, 0xC0	; 192
  30:	01 f4       	brne	.+0      	; 0x32 <_ZN7Sd2Card8cardSizeEv+0x32>
  32:	6f 81       	ldd	r22, Y+7	; 0x07
  34:	63 70       	andi	r22, 0x03	; 3
  36:	70 e0       	ldi	r23, 0x00	; 0
  chipSelectHigh();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  38:	76 2f       	mov	r23, r22
  3a:	66 27       	eor	r22, r22
  3c:	77 0f       	add	r23, r23
  return false;
  3e:	77 0f       	add	r23, r23
  40:	88 85       	ldd	r24, Y+8	; 0x08
  42:	24 e0       	ldi	r18, 0x04	; 4
  44:	82 9f       	mul	r24, r18
  46:	c0 01       	movw	r24, r0
  48:	11 24       	eor	r1, r1
  4a:	68 2b       	or	r22, r24
  4c:	79 2b       	or	r23, r25
  4e:	89 85       	ldd	r24, Y+9	; 0x09
  50:	82 95       	swap	r24
  52:	86 95       	lsr	r24
  54:	86 95       	lsr	r24
  56:	83 70       	andi	r24, 0x03	; 3
  58:	68 2b       	or	r22, r24
  5a:	6f 5f       	subi	r22, 0xFF	; 255
  5c:	7f 4f       	sbci	r23, 0xFF	; 255
  5e:	90 e0       	ldi	r25, 0x00	; 0
  60:	80 e0       	ldi	r24, 0x00	; 0
  62:	2a 85       	ldd	r18, Y+10	; 0x0a
  64:	23 70       	andi	r18, 0x03	; 3
  66:	22 0f       	add	r18, r18
  68:	3b 85       	ldd	r19, Y+11	; 0x0b
  6a:	37 fb       	bst	r19, 7
  6c:	33 27       	eor	r19, r19
  6e:	30 f9       	bld	r19, 0
  70:	23 2b       	or	r18, r19
  72:	3e 81       	ldd	r19, Y+6	; 0x06
  74:	3f 70       	andi	r19, 0x0F	; 15
  76:	23 0f       	add	r18, r19
  78:	33 27       	eor	r19, r19
  7a:	33 1f       	adc	r19, r19
  7c:	27 50       	subi	r18, 0x07	; 7
  7e:	31 09       	sbc	r19, r1
  80:	00 c0       	rjmp	.+0      	; 0x82 <_ZN7Sd2Card8cardSizeEv+0x82>
  82:	66 0f       	add	r22, r22
  84:	77 1f       	adc	r23, r23
  86:	88 1f       	adc	r24, r24
  88:	99 1f       	adc	r25, r25
  8a:	2a 95       	dec	r18
  8c:	02 f4       	brpl	.+0      	; 0x8e <_ZN7Sd2Card8cardSizeEv+0x8e>
  8e:	60 96       	adiw	r28, 0x10	; 16
  90:	0f b6       	in	r0, 0x3f	; 63
  92:	f8 94       	cli
  94:	de bf       	out	0x3e, r29	; 62
  96:	0f be       	out	0x3f, r0	; 63
  98:	cd bf       	out	0x3d, r28	; 61
  9a:	df 91       	pop	r29
  9c:	cf 91       	pop	r28
  9e:	1f 91       	pop	r17
  a0:	0f 91       	pop	r16
  a2:	08 95       	ret
  a4:	80 34       	cpi	r24, 0x40	; 64
  a6:	01 f4       	brne	.+0      	; 0xa8 <_ZN7Sd2Card8cardSizeEv+0xa8>
  a8:	68 85       	ldd	r22, Y+8	; 0x08
  aa:	66 95       	lsr	r22
  ac:	66 95       	lsr	r22
  ae:	70 e0       	ldi	r23, 0x00	; 0
  b0:	90 e0       	ldi	r25, 0x00	; 0
  b2:	80 e0       	ldi	r24, 0x00	; 0
  b4:	cb 01       	movw	r24, r22
  b6:	77 27       	eor	r23, r23
  b8:	66 27       	eor	r22, r22
  ba:	2a 85       	ldd	r18, Y+10	; 0x0a
  bc:	62 2b       	or	r22, r18
  be:	09 85       	ldd	r16, Y+9	; 0x09
  c0:	10 e0       	ldi	r17, 0x00	; 0
  c2:	10 2f       	mov	r17, r16
  c4:	00 27       	eor	r16, r16
  c6:	01 2e       	mov	r0, r17
  c8:	00 0c       	add	r0, r0
  ca:	22 0b       	sbc	r18, r18
  cc:	33 0b       	sbc	r19, r19
  ce:	60 2b       	or	r22, r16
  d0:	71 2b       	or	r23, r17
  d2:	82 2b       	or	r24, r18
  d4:	93 2b       	or	r25, r19
  d6:	6f 5f       	subi	r22, 0xFF	; 255
  d8:	7f 4f       	sbci	r23, 0xFF	; 255
  da:	8f 4f       	sbci	r24, 0xFF	; 255
  dc:	9f 4f       	sbci	r25, 0xFF	; 255
  de:	4a e0       	ldi	r20, 0x0A	; 10
  e0:	66 0f       	add	r22, r22
  e2:	77 1f       	adc	r23, r23
  e4:	88 1f       	adc	r24, r24
  e6:	99 1f       	adc	r25, r25
  e8:	4a 95       	dec	r20
  ea:	01 f4       	brne	.+0      	; 0xec <_ZN7Sd2Card8cardSizeEv+0xec>
  ec:	00 c0       	rjmp	.+0      	; 0xee <_ZN7Sd2Card8cardSizeEv+0xee>
  ee:	89 e0       	ldi	r24, 0x09	; 9
  f0:	f8 01       	movw	r30, r16
  f2:	85 83       	std	Z+5, r24	; 0x05
  f4:	60 e0       	ldi	r22, 0x00	; 0
  f6:	70 e0       	ldi	r23, 0x00	; 0
  f8:	cb 01       	movw	r24, r22
  fa:	00 c0       	rjmp	.+0      	; 0xfc <__SREG__+0xbd>

Disassembly of section .text._ZN7Sd2Card22eraseSingleBlockEnableEv:

00000000 <_ZN7Sd2Card22eraseSingleBlockEnableEv>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	cd b7       	in	r28, 0x3d	; 61
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	de b7       	in	r29, 0x3e	; 62
   8:	60 97       	sbiw	r28, 0x10	; 16
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  spiSend(STOP_TRAN_TOKEN);
  12:	cd bf       	out	0x3d, r28	; 61
  14:	ae 01       	movw	r20, r28
  16:	4f 5f       	subi	r20, 0xFF	; 255
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  18:	5f 4f       	sbci	r21, 0xFF	; 255
  1a:	69 e0       	ldi	r22, 0x09	; 9
  1c:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card22eraseSingleBlockEnableEv>
  20:	88 23       	and	r24, r24
  22:	01 f0       	breq	.+0      	; 0x24 <_ZN7Sd2Card22eraseSingleBlockEnableEv+0x24>
  24:	8b 85       	ldd	r24, Y+11	; 0x0b
  chipSelectHigh();
  26:	86 fb       	bst	r24, 6
  28:	88 27       	eor	r24, r24
  2a:	80 f9       	bld	r24, 0
  return true;
  2c:	60 96       	adiw	r28, 0x10	; 16

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  return false;
}
  2e:	0f b6       	in	r0, 0x3f	; 63
  30:	f8 94       	cli
  32:	de bf       	out	0x3e, r29	; 62
  34:	0f be       	out	0x3f, r0	; 63
  36:	cd bf       	out	0x3d, r28	; 61
  chipSelectHigh();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  38:	df 91       	pop	r29
  3a:	cf 91       	pop	r28
  3c:	08 95       	ret

Disassembly of section .text._ZN7Sd2Card5eraseEmm:

00000000 <_ZN7Sd2Card5eraseEmm>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	bf 92       	push	r11
   8:	cf 92       	push	r12
   a:	df 92       	push	r13
   c:	ef 92       	push	r14
   e:	ff 92       	push	r15
  10:	0f 93       	push	r16
  spiSend(STOP_TRAN_TOKEN);
  12:	1f 93       	push	r17
  14:	cf 93       	push	r28
  16:	df 93       	push	r29
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  18:	ec 01       	movw	r28, r24
  1a:	4a 01       	movw	r8, r20
  1c:	5b 01       	movw	r10, r22
  1e:	68 01       	movw	r12, r16
  20:	79 01       	movw	r14, r18
  22:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card5eraseEmm>
  chipSelectHigh();
  26:	81 11       	cpse	r24, r1
  28:	00 c0       	rjmp	.+0      	; 0x2a <_ZN7Sd2Card5eraseEmm+0x2a>
  2a:	8b e0       	ldi	r24, 0x0B	; 11
  return true;
  2c:	8d 83       	std	Y+5, r24	; 0x05

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  return false;
}
  2e:	ce 01       	movw	r24, r28
  30:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card5eraseEmm>
  34:	80 e0       	ldi	r24, 0x00	; 0
  36:	df 91       	pop	r29
  chipSelectHigh();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  38:	cf 91       	pop	r28
  3a:	1f 91       	pop	r17
  3c:	0f 91       	pop	r16
  return false;
  3e:	ff 90       	pop	r15
  40:	ef 90       	pop	r14
  42:	df 90       	pop	r13
  44:	cf 90       	pop	r12
  46:	bf 90       	pop	r11
  48:	af 90       	pop	r10
  4a:	9f 90       	pop	r9
  4c:	8f 90       	pop	r8
  4e:	08 95       	ret
  50:	8b 85       	ldd	r24, Y+11	; 0x0b
  52:	83 30       	cpi	r24, 0x03	; 3
  54:	01 f0       	breq	.+0      	; 0x56 <_ZN7Sd2Card5eraseEmm+0x56>
  56:	89 e0       	ldi	r24, 0x09	; 9
  58:	88 0c       	add	r8, r8
  5a:	99 1c       	adc	r9, r9
  5c:	aa 1c       	adc	r10, r10
  5e:	bb 1c       	adc	r11, r11
  60:	8a 95       	dec	r24
  62:	01 f4       	brne	.+0      	; 0x64 <_ZN7Sd2Card5eraseEmm+0x64>
  64:	99 e0       	ldi	r25, 0x09	; 9
  66:	cc 0c       	add	r12, r12
  68:	dd 1c       	adc	r13, r13
  6a:	ee 1c       	adc	r14, r14
  6c:	ff 1c       	adc	r15, r15
  6e:	9a 95       	dec	r25
  70:	01 f4       	brne	.+0      	; 0x72 <_ZN7Sd2Card5eraseEmm+0x72>
  72:	a5 01       	movw	r20, r10
  74:	94 01       	movw	r18, r8
  76:	60 e2       	ldi	r22, 0x20	; 32
  78:	ce 01       	movw	r24, r28
  7a:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card5eraseEmm>
  7e:	88 23       	and	r24, r24
  80:	01 f0       	breq	.+0      	; 0x82 <_ZN7Sd2Card5eraseEmm+0x82>
  82:	8a e0       	ldi	r24, 0x0A	; 10
  84:	00 c0       	rjmp	.+0      	; 0x86 <_ZN7Sd2Card5eraseEmm+0x86>
  86:	a7 01       	movw	r20, r14
  88:	96 01       	movw	r18, r12
  8a:	61 e2       	ldi	r22, 0x21	; 33
  8c:	ce 01       	movw	r24, r28
  8e:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card5eraseEmm>
  92:	81 11       	cpse	r24, r1
  94:	00 c0       	rjmp	.+0      	; 0x96 <_ZN7Sd2Card5eraseEmm+0x96>
  96:	20 e0       	ldi	r18, 0x00	; 0
  98:	30 e0       	ldi	r19, 0x00	; 0
  9a:	a9 01       	movw	r20, r18
  9c:	66 e2       	ldi	r22, 0x26	; 38
  9e:	ce 01       	movw	r24, r28
  a0:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card5eraseEmm>
  a4:	81 11       	cpse	r24, r1
  a6:	00 c0       	rjmp	.+0      	; 0xa8 <_ZN7Sd2Card5eraseEmm+0xa8>
  a8:	60 e1       	ldi	r22, 0x10	; 16
  aa:	77 e2       	ldi	r23, 0x27	; 39
  ac:	ce 01       	movw	r24, r28
  ae:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card5eraseEmm>
  b2:	81 11       	cpse	r24, r1
  b4:	00 c0       	rjmp	.+0      	; 0xb6 <_ZN7Sd2Card5eraseEmm+0xb6>
  b6:	8c e0       	ldi	r24, 0x0C	; 12
  b8:	00 c0       	rjmp	.+0      	; 0xba <_ZN7Sd2Card5eraseEmm+0xba>
  ba:	ce 01       	movw	r24, r28
  bc:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card5eraseEmm>
  c0:	81 e0       	ldi	r24, 0x01	; 1
  c2:	00 c0       	rjmp	.+0      	; 0xc4 <__SREG__+0x85>

Disassembly of section .text._ZN7Sd2Card9writeDataEhPKh:

00000000 <_ZN7Sd2Card9writeDataEhPKh>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	6e bd       	out	0x2e, r22	; 46
   8:	fa 01       	movw	r30, r20
   a:	ca 01       	movw	r24, r20
   c:	9e 5f       	subi	r25, 0xFE	; 254
   e:	0d b4       	in	r0, 0x2d	; 45
  10:	07 fe       	sbrs	r0, 7
  spiSend(STOP_TRAN_TOKEN);
  12:	00 c0       	rjmp	.+0      	; 0x14 <_ZN7Sd2Card9writeDataEhPKh+0x14>
  14:	20 81       	ld	r18, Z
  16:	2e bd       	out	0x2e, r18	; 46
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  18:	0d b4       	in	r0, 0x2d	; 45
  1a:	07 fe       	sbrs	r0, 7
  1c:	00 c0       	rjmp	.+0      	; 0x1e <_ZN7Sd2Card9writeDataEhPKh+0x1e>
  1e:	21 81       	ldd	r18, Z+1	; 0x01
  20:	2e bd       	out	0x2e, r18	; 46
  22:	32 96       	adiw	r30, 0x02	; 2
  24:	e8 17       	cp	r30, r24
  chipSelectHigh();
  26:	f9 07       	cpc	r31, r25
  28:	01 f4       	brne	.+0      	; 0x2a <_ZN7Sd2Card9writeDataEhPKh+0x2a>
  2a:	0d b4       	in	r0, 0x2d	; 45
  return true;
  2c:	07 fe       	sbrs	r0, 7

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  return false;
}
  2e:	00 c0       	rjmp	.+0      	; 0x30 <_ZN7Sd2Card9writeDataEhPKh+0x30>
  30:	8f ef       	ldi	r24, 0xFF	; 255
  32:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card9writeDataEhPKh>
  36:	8f ef       	ldi	r24, 0xFF	; 255
  chipSelectHigh();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  38:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card9writeDataEhPKh>
  3c:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card9writeDataEhPKh>
  return false;
  40:	8a 87       	std	Y+10, r24	; 0x0a
  42:	8f 71       	andi	r24, 0x1F	; 31
  44:	85 30       	cpi	r24, 0x05	; 5
  46:	01 f0       	breq	.+0      	; 0x48 <_ZN7Sd2Card9writeDataEhPKh+0x48>
  48:	81 e1       	ldi	r24, 0x11	; 17
  4a:	8d 83       	std	Y+5, r24	; 0x05
  4c:	ce 01       	movw	r24, r28
  4e:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card9writeDataEhPKh>
  52:	80 e0       	ldi	r24, 0x00	; 0
  54:	df 91       	pop	r29
  56:	cf 91       	pop	r28
  58:	08 95       	ret
  5a:	81 e0       	ldi	r24, 0x01	; 1
  5c:	00 c0       	rjmp	.+0      	; 0x5e <__SREG__+0x1f>

Disassembly of section .text._ZN7Sd2Card10writeBlockEmPKh:

00000000 <_ZN7Sd2Card10writeBlockEmPKh>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	df 93       	push	r29
   8:	ec 01       	movw	r28, r24
   a:	89 01       	movw	r16, r18
   c:	82 e1       	ldi	r24, 0x12	; 18
   e:	41 15       	cp	r20, r1
  10:	51 05       	cpc	r21, r1
  spiSend(STOP_TRAN_TOKEN);
  12:	61 05       	cpc	r22, r1
  14:	71 05       	cpc	r23, r1
  16:	01 f0       	breq	.+0      	; 0x18 <_ZN7Sd2Card10writeBlockEmPKh+0x18>
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  18:	8b 85       	ldd	r24, Y+11	; 0x0b
  1a:	83 30       	cpi	r24, 0x03	; 3
  1c:	01 f0       	breq	.+0      	; 0x1e <_ZN7Sd2Card10writeBlockEmPKh+0x1e>
  1e:	89 e0       	ldi	r24, 0x09	; 9
  20:	44 0f       	add	r20, r20
  22:	55 1f       	adc	r21, r21
  24:	66 1f       	adc	r22, r22
  chipSelectHigh();
  26:	77 1f       	adc	r23, r23
  28:	8a 95       	dec	r24
  2a:	01 f4       	brne	.+0      	; 0x2c <_ZN7Sd2Card10writeBlockEmPKh+0x2c>
  return true;
  2c:	9a 01       	movw	r18, r20

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  return false;
}
  2e:	ab 01       	movw	r20, r22
  30:	68 e1       	ldi	r22, 0x18	; 24
  32:	ce 01       	movw	r24, r28
  34:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card10writeBlockEmPKh>
  chipSelectHigh();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  38:	88 23       	and	r24, r24
  3a:	01 f0       	breq	.+0      	; 0x3c <_ZN7Sd2Card10writeBlockEmPKh+0x3c>
  3c:	84 e0       	ldi	r24, 0x04	; 4
  return false;
  3e:	8d 83       	std	Y+5, r24	; 0x05
  40:	ce 01       	movw	r24, r28
  42:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card10writeBlockEmPKh>
  46:	80 e0       	ldi	r24, 0x00	; 0
  48:	00 c0       	rjmp	.+0      	; 0x4a <_ZN7Sd2Card10writeBlockEmPKh+0x4a>
  4a:	a8 01       	movw	r20, r16
  4c:	6e ef       	ldi	r22, 0xFE	; 254
  4e:	ce 01       	movw	r24, r28
  50:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card10writeBlockEmPKh>
  54:	88 23       	and	r24, r24
  56:	01 f0       	breq	.+0      	; 0x58 <_ZN7Sd2Card10writeBlockEmPKh+0x58>
  58:	68 e5       	ldi	r22, 0x58	; 88
  5a:	72 e0       	ldi	r23, 0x02	; 2
  5c:	ce 01       	movw	r24, r28
  5e:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card10writeBlockEmPKh>
  62:	81 11       	cpse	r24, r1
  64:	00 c0       	rjmp	.+0      	; 0x66 <_ZN7Sd2Card10writeBlockEmPKh+0x66>
  66:	85 e1       	ldi	r24, 0x15	; 21
  68:	00 c0       	rjmp	.+0      	; 0x6a <_ZN7Sd2Card10writeBlockEmPKh+0x6a>
  6a:	20 e0       	ldi	r18, 0x00	; 0
  6c:	30 e0       	ldi	r19, 0x00	; 0
  6e:	a9 01       	movw	r20, r18
  70:	6d e0       	ldi	r22, 0x0D	; 13
  72:	ce 01       	movw	r24, r28
  74:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card10writeBlockEmPKh>
  78:	88 23       	and	r24, r24
  7a:	01 f0       	breq	.+0      	; 0x7c <_ZN7Sd2Card10writeBlockEmPKh+0x7c>
  7c:	84 e1       	ldi	r24, 0x14	; 20
  7e:	00 c0       	rjmp	.+0      	; 0x80 <_ZN7Sd2Card10writeBlockEmPKh+0x80>
  80:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card10writeBlockEmPKh>
  84:	81 11       	cpse	r24, r1
  86:	00 c0       	rjmp	.+0      	; 0x88 <_ZN7Sd2Card10writeBlockEmPKh+0x88>
  88:	ce 01       	movw	r24, r28
  8a:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card10writeBlockEmPKh>
  8e:	81 e0       	ldi	r24, 0x01	; 1
  90:	df 91       	pop	r29
  92:	cf 91       	pop	r28
  94:	1f 91       	pop	r17
  96:	0f 91       	pop	r16
  98:	08 95       	ret

Disassembly of section .text._ZN7Sd2Card9writeDataEPKh:

00000000 <_ZN7Sd2Card9writeDataEPKh>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	df 93       	push	r29
   8:	ec 01       	movw	r28, r24
   a:	8b 01       	movw	r16, r22
   c:	68 e5       	ldi	r22, 0x58	; 88
   e:	72 e0       	ldi	r23, 0x02	; 2
  10:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card9writeDataEPKh>
  spiSend(STOP_TRAN_TOKEN);
  14:	88 23       	and	r24, r24
  16:	01 f0       	breq	.+0      	; 0x18 <_ZN7Sd2Card9writeDataEPKh+0x18>
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  18:	a8 01       	movw	r20, r16
  1a:	6c ef       	ldi	r22, 0xFC	; 252
  1c:	ce 01       	movw	r24, r28
  1e:	df 91       	pop	r29
  20:	cf 91       	pop	r28
  22:	1f 91       	pop	r17
  24:	0f 91       	pop	r16
  chipSelectHigh();
  26:	0c 94 00 00 	jmp	0	; 0x0 <_ZN7Sd2Card9writeDataEPKh>
  2a:	83 e1       	ldi	r24, 0x13	; 19
  return true;
  2c:	8d 83       	std	Y+5, r24	; 0x05

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  return false;
}
  2e:	ce 01       	movw	r24, r28
  30:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card9writeDataEPKh>
  34:	80 e0       	ldi	r24, 0x00	; 0
  36:	df 91       	pop	r29
  chipSelectHigh();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  38:	cf 91       	pop	r28
  3a:	1f 91       	pop	r17
  3c:	0f 91       	pop	r16
  return false;
  3e:	08 95       	ret

Disassembly of section .text._ZN7Sd2Card10writeStartEmm:

00000000 <_ZN7Sd2Card10writeStartEmm>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	bf 92       	push	r11
   8:	cf 92       	push	r12
   a:	df 92       	push	r13
   c:	ef 92       	push	r14
   e:	ff 92       	push	r15
  10:	0f 93       	push	r16
  spiSend(STOP_TRAN_TOKEN);
  12:	1f 93       	push	r17
  14:	cf 93       	push	r28
  16:	df 93       	push	r29
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  18:	ec 01       	movw	r28, r24
  1a:	6a 01       	movw	r12, r20
  1c:	7b 01       	movw	r14, r22
  1e:	59 01       	movw	r10, r18
  20:	82 e1       	ldi	r24, 0x12	; 18
  22:	c1 14       	cp	r12, r1
  24:	d1 04       	cpc	r13, r1
  chipSelectHigh();
  26:	e1 04       	cpc	r14, r1
  28:	f1 04       	cpc	r15, r1
  2a:	01 f0       	breq	.+0      	; 0x2c <_ZN7Sd2Card10writeStartEmm+0x2c>
  return true;
  2c:	20 e0       	ldi	r18, 0x00	; 0

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  return false;
}
  2e:	30 e0       	ldi	r19, 0x00	; 0
  30:	a9 01       	movw	r20, r18
  32:	67 e3       	ldi	r22, 0x37	; 55
  34:	ce 01       	movw	r24, r28
  36:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card10writeStartEmm>
  chipSelectHigh();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  3a:	a5 01       	movw	r20, r10
  3c:	98 01       	movw	r18, r16
  return false;
  3e:	67 e1       	ldi	r22, 0x17	; 23
  40:	ce 01       	movw	r24, r28
  42:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card10writeStartEmm>
  46:	88 23       	and	r24, r24
  48:	01 f0       	breq	.+0      	; 0x4a <_ZN7Sd2Card10writeStartEmm+0x4a>
  4a:	87 e0       	ldi	r24, 0x07	; 7
  4c:	8d 83       	std	Y+5, r24	; 0x05
  4e:	ce 01       	movw	r24, r28
  50:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card10writeStartEmm>
  54:	80 e0       	ldi	r24, 0x00	; 0
  56:	df 91       	pop	r29
  58:	cf 91       	pop	r28
  5a:	1f 91       	pop	r17
  5c:	0f 91       	pop	r16
  5e:	ff 90       	pop	r15
  60:	ef 90       	pop	r14
  62:	df 90       	pop	r13
  64:	cf 90       	pop	r12
  66:	bf 90       	pop	r11
  68:	af 90       	pop	r10
  6a:	9f 90       	pop	r9
  6c:	8f 90       	pop	r8
  6e:	08 95       	ret
  70:	8b 85       	ldd	r24, Y+11	; 0x0b
  72:	83 30       	cpi	r24, 0x03	; 3
  74:	01 f0       	breq	.+0      	; 0x76 <_ZN7Sd2Card10writeStartEmm+0x76>
  76:	89 e0       	ldi	r24, 0x09	; 9
  78:	cc 0c       	add	r12, r12
  7a:	dd 1c       	adc	r13, r13
  7c:	ee 1c       	adc	r14, r14
  7e:	ff 1c       	adc	r15, r15
  80:	8a 95       	dec	r24
  82:	01 f4       	brne	.+0      	; 0x84 <_ZN7Sd2Card10writeStartEmm+0x84>
  84:	a7 01       	movw	r20, r14
  86:	96 01       	movw	r18, r12
  88:	69 e1       	ldi	r22, 0x19	; 25
  8a:	ce 01       	movw	r24, r28
  8c:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card10writeStartEmm>
  90:	88 23       	and	r24, r24
  92:	01 f0       	breq	.+0      	; 0x94 <_ZN7Sd2Card10writeStartEmm+0x94>
  94:	85 e0       	ldi	r24, 0x05	; 5
  96:	00 c0       	rjmp	.+0      	; 0x98 <_ZN7Sd2Card10writeStartEmm+0x98>
  98:	81 e0       	ldi	r24, 0x01	; 1
  9a:	00 c0       	rjmp	.+0      	; 0x9c <__SREG__+0x5d>

Disassembly of section .text._ZN7Sd2Card9writeStopEv:

00000000 <_ZN7Sd2Card9writeStopEv>:
/** End a write multiple blocks sequence.
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::writeStop(void) {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
   6:	68 e5       	ldi	r22, 0x58	; 88
   8:	72 e0       	ldi	r23, 0x02	; 2
   a:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card9writeStopEv>
   e:	88 23       	and	r24, r24
  10:	01 f0       	breq	.+0      	; 0x12 <_ZN7Sd2Card9writeStopEv+0x12>
  spiSend(STOP_TRAN_TOKEN);
  12:	8d ef       	ldi	r24, 0xFD	; 253
  14:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card9writeStopEv>
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  18:	68 e5       	ldi	r22, 0x58	; 88
  1a:	72 e0       	ldi	r23, 0x02	; 2
  1c:	ce 01       	movw	r24, r28
  1e:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card9writeStopEv>
  22:	88 23       	and	r24, r24
  24:	01 f0       	breq	.+0      	; 0x26 <_ZN7Sd2Card9writeStopEv+0x26>
  chipSelectHigh();
  26:	ce 01       	movw	r24, r28
  28:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card9writeStopEv>
  return true;
  2c:	81 e0       	ldi	r24, 0x01	; 1

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  return false;
}
  2e:	df 91       	pop	r29
  30:	cf 91       	pop	r28
  32:	08 95       	ret
  34:	80 e1       	ldi	r24, 0x10	; 16
  36:	8d 83       	std	Y+5, r24	; 0x05
  chipSelectHigh();
  return true;

 fail:
  error(SD_CARD_ERROR_STOP_TRAN);
  chipSelectHigh();
  38:	ce 01       	movw	r24, r28
  3a:	0e 94 00 00 	call	0	; 0x0 <_ZN7Sd2Card9writeStopEv>
  return false;
  3e:	80 e0       	ldi	r24, 0x00	; 0
  40:	00 c0       	rjmp	.+0      	; 0x42 <__SREG__+0x3>

SdFile.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .group        00000008  00000000  00000000  00000034  2**2
                  CONTENTS, READONLY, EXCLUDE, GROUP, LINK_ONCE_DISCARD
  1 .text         00000000  00000000  00000000  0000003c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .data         00000000  00000000  00000000  0000003c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000000  00000000  00000000  0000003c  2**0
                  ALLOC
  4 .stab         000038a0  00000000  00000000  0000003c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .stabstr      000042e1  00000000  00000000  000038dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .text._ZN6SdFile10addClusterEv 0000004e  00000000  00000000  00007bbd  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text._ZN6SdFile13addDirClusterEv 000000d4  00000000  00000000  00007c0b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text._ZN6SdFile13cacheDirEntryEh 00000032  00000000  00000000  00007cdf  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text._ZN6SdFile15contiguousRangeEPmS0_ 0000015c  00000000  00000000  00007d11  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text._ZN6SdFile7dirNameERK14directoryEntryPc 00000044  00000000  00000000  00007e6d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text._ZN6SdFile10make83NameEPKcPh 0000006e  00000000  00000000  00007eb1  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text._ZN6SdFile8openRootEP8SdVolume 000000a0  00000000  00000000  00007f1f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text._ZN6SdFile12printDirNameERK14directoryEntryh 00000084  00000000  00000000  00007fbf  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text._ZN6SdFile14printTwoDigitsEh 00000036  00000000  00000000  00008043  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text._ZN6SdFile12printFatDateEj 00000058  00000000  00000000  00008079  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 16 .text._ZN6SdFile12printFatTimeEj 0000004e  00000000  00000000  000080d1  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 17 .text._ZN6SdFile4readEPvj 0000020e  00000000  00000000  0000811f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 18 .text._ZN6SdFile7readDirEP14directoryEntry 00000068  00000000  00000000  0000832d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 19 .text._ZN6SdFile12readDirCacheEv 00000082  00000000  00000000  00008395  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 20 .text._ZN6SdFile7seekSetEm 00000128  00000000  00000000  00008417  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 21 .text._ZN6SdFile4syncEv 00000092  00000000  00000000  0000853f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 22 .text._ZN6SdFile5closeEv 00000018  00000000  00000000  000085d1  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 23 .text._ZN6SdFile8dirEntryEP14directoryEntry 0000003e  00000000  00000000  000085e9  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 24 .text._ZN6SdFile9timestampEhjhhhhh 0000010e  00000000  00000000  00008627  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 25 .text._ZN6SdFile8truncateEm 00000168  00000000  00000000  00008735  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 26 .text._ZN6SdFile15openCachedEntryEhh 000000f6  00000000  00000000  0000889d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 27 .text._ZN6SdFile4openEPS_PKch 000001da  00000000  00000000  00008993  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 28 .text._ZN6SdFile7makeDirEPS_PKc 0000018e  00000000  00000000  00008b6d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 29 .text._ZN6SdFile4openEPS_jh 00000090  00000000  00000000  00008cfb  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 30 .text._ZN6SdFile2lsEhh 000001ce  00000000  00000000  00008d8b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 31 .text._ZN6SdFile6removeEv 00000038  00000000  00000000  00008f59  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 32 .text._ZN6SdFile16createContiguousEPS_PKcm 000000a2  00000000  00000000  00008f91  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 33 .text._ZN6SdFile6removeEPS_PKc 0000004a  00000000  00000000  00009033  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 34 .text._ZN6SdFile5rmDirEv 00000074  00000000  00000000  0000907d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 35 .text._ZN6SdFile8rmRfStarEv 0000013a  00000000  00000000  000090f1  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 36 .text._ZN6SdFile5writeEPKvj 0000033a  00000000  00000000  0000922b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 37 .text._ZN6SdFile5writeEh 00000022  00000000  00000000  00009565  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 38 .text._ZN6SdFile5writeEPKc 00000014  00000000  00000000  00009587  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 39 .text._ZN6SdFile7write_PEPKc 00000032  00000000  00000000  0000959b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 40 .text._ZN6SdFile9writeln_PEPKc 00000014  00000000  00000000  000095cd  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 41 .rodata._ZTV6SdFile 0000000a  00000000  00000000  000095e1  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 42 .progmem.data._ZZN6SdFile10make83NameEPKcPhE3__c 00000010  00000000  00000000  000095eb  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 43 .bss._ZN6SdFile12oldDateTime_E 00000002  00000000  00000000  000095fb  2**0
                  ALLOC
 44 .bss._ZN6SdFile9dateTime_E 00000002  00000000  00000000  000095fb  2**0
                  ALLOC
 45 .comment      00000012  00000000  00000000  000095fb  2**0
                  CONTENTS, READONLY

Disassembly of section .text._ZN6SdFile10addClusterEv:

00000000 <_ZN6SdFile10addClusterEv>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
  write_P(str);
   6:	9c 01       	movw	r18, r24
   8:	2b 5f       	subi	r18, 0xFB	; 251
  println();
   a:	3f 4f       	sbci	r19, 0xFF	; 255
}
   c:	41 e0       	ldi	r20, 0x01	; 1
   e:	50 e0       	ldi	r21, 0x00	; 0
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	60 e0       	ldi	r22, 0x00	; 0
  12:	70 e0       	ldi	r23, 0x00	; 0
  14:	8a 8d       	ldd	r24, Y+26	; 0x1a
  16:	9b 8d       	ldd	r25, Y+27	; 0x1b
  18:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile10addClusterEv>
  1c:	88 23       	and	r24, r24
  1e:	01 f0       	breq	.+0      	; 0x20 <_ZN6SdFile10addClusterEv+0x20>
  20:	8e 89       	ldd	r24, Y+22	; 0x16
  22:	9f 89       	ldd	r25, Y+23	; 0x17
  24:	a8 8d       	ldd	r26, Y+24	; 0x18
  26:	b9 8d       	ldd	r27, Y+25	; 0x19
  28:	89 2b       	or	r24, r25
  2a:	8a 2b       	or	r24, r26
  2c:	8b 2b       	or	r24, r27
  2e:	01 f4       	brne	.+0      	; 0x30 <_ZN6SdFile10addClusterEv+0x30>
  30:	8d 81       	ldd	r24, Y+5	; 0x05
  32:	9e 81       	ldd	r25, Y+6	; 0x06
  34:	af 81       	ldd	r26, Y+7	; 0x07
  36:	b8 85       	ldd	r27, Y+8	; 0x08
  38:	8e 8b       	std	Y+22, r24	; 0x16
  3a:	9f 8b       	std	Y+23, r25	; 0x17
  3c:	a8 8f       	std	Y+24, r26	; 0x18
  3e:	b9 8f       	std	Y+25, r27	; 0x19
  40:	8b 81       	ldd	r24, Y+3	; 0x03
  42:	80 68       	ori	r24, 0x80	; 128
  44:	8b 83       	std	Y+3, r24	; 0x03
  46:	81 e0       	ldi	r24, 0x01	; 1
  48:	df 91       	pop	r29
  4a:	cf 91       	pop	r28
  4c:	08 95       	ret

Disassembly of section .text._ZN6SdFile13addDirClusterEv:

00000000 <_ZN6SdFile13addDirClusterEv>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
  write_P(str);
   6:	bf 92       	push	r11
   8:	cf 92       	push	r12
  println();
   a:	df 92       	push	r13
}
   c:	ef 92       	push	r14
   e:	ff 92       	push	r15
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	cf 93       	push	r28
  12:	df 93       	push	r29
  14:	ec 01       	movw	r28, r24
  16:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile13addDirClusterEv>
  1a:	81 11       	cpse	r24, r1
  1c:	00 c0       	rjmp	.+0      	; 0x1e <_ZN6SdFile13addDirClusterEv+0x1e>
  1e:	80 e0       	ldi	r24, 0x00	; 0
  20:	df 91       	pop	r29
  22:	cf 91       	pop	r28
  24:	ff 90       	pop	r15
  26:	ef 90       	pop	r14
  28:	df 90       	pop	r13
  2a:	cf 90       	pop	r12
  2c:	bf 90       	pop	r11
  2e:	af 90       	pop	r10
  30:	9f 90       	pop	r9
  32:	8f 90       	pop	r8
  34:	08 95       	ret
  36:	ea 8d       	ldd	r30, Y+26	; 0x1a
  38:	fb 8d       	ldd	r31, Y+27	; 0x1b
  3a:	cd 80       	ldd	r12, Y+5	; 0x05
  3c:	de 80       	ldd	r13, Y+6	; 0x06
  3e:	ef 80       	ldd	r14, Y+7	; 0x07
  40:	f8 84       	ldd	r15, Y+8	; 0x08
  42:	82 e0       	ldi	r24, 0x02	; 2
  44:	c8 1a       	sub	r12, r24
  46:	d1 08       	sbc	r13, r1
  48:	e1 08       	sbc	r14, r1
  4a:	f1 08       	sbc	r15, r1
  4c:	85 85       	ldd	r24, Z+13	; 0x0d
  4e:	00 c0       	rjmp	.+0      	; 0x50 <_ZN6SdFile13addDirClusterEv+0x50>
  50:	cc 0c       	add	r12, r12
  52:	dd 1c       	adc	r13, r13
  54:	ee 1c       	adc	r14, r14
  56:	ff 1c       	adc	r15, r15
  58:	8a 95       	dec	r24
  5a:	02 f4       	brpl	.+0      	; 0x5c <_ZN6SdFile13addDirClusterEv+0x5c>
  5c:	86 85       	ldd	r24, Z+14	; 0x0e
  5e:	97 85       	ldd	r25, Z+15	; 0x0f
  60:	a0 89       	ldd	r26, Z+16	; 0x10
  62:	b1 89       	ldd	r27, Z+17	; 0x11
  64:	c8 0e       	add	r12, r24
  66:	d9 1e       	adc	r13, r25
  68:	ea 1e       	adc	r14, r26
  6a:	fb 1e       	adc	r15, r27
  6c:	84 81       	ldd	r24, Z+4	; 0x04
  6e:	46 01       	movw	r8, r12
  70:	57 01       	movw	r10, r14
  72:	88 0e       	add	r8, r24
  74:	91 1c       	adc	r9, r1
  76:	a1 1c       	adc	r10, r1
  78:	b1 1c       	adc	r11, r1
  7a:	8c 14       	cp	r8, r12
  7c:	9d 04       	cpc	r9, r13
  7e:	ae 04       	cpc	r10, r14
  80:	bf 04       	cpc	r11, r15
  82:	01 f0       	breq	.+0      	; 0x84 <_ZN6SdFile13addDirClusterEv+0x84>
  84:	81 e0       	ldi	r24, 0x01	; 1
  86:	88 1a       	sub	r8, r24
  88:	91 08       	sbc	r9, r1
  8a:	a1 08       	sbc	r10, r1
  8c:	b1 08       	sbc	r11, r1
  8e:	c5 01       	movw	r24, r10
  90:	b4 01       	movw	r22, r8
  92:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile13addDirClusterEv>
  96:	81 11       	cpse	r24, r1
  98:	00 c0       	rjmp	.+0      	; 0x9a <_ZN6SdFile13addDirClusterEv+0x9a>
  9a:	00 c0       	rjmp	.+0      	; 0x9c <_ZN6SdFile13addDirClusterEv+0x9c>
  9c:	ea 8d       	ldd	r30, Y+26	; 0x1a
  9e:	fb 8d       	ldd	r31, Y+27	; 0x1b
  a0:	25 85       	ldd	r18, Z+13	; 0x0d
  a2:	80 e0       	ldi	r24, 0x00	; 0
  a4:	92 e0       	ldi	r25, 0x02	; 2
  a6:	a0 e0       	ldi	r26, 0x00	; 0
  a8:	b0 e0       	ldi	r27, 0x00	; 0
  aa:	00 c0       	rjmp	.+0      	; 0xac <_ZN6SdFile13addDirClusterEv+0xac>
  ac:	88 0f       	add	r24, r24
  ae:	99 1f       	adc	r25, r25
  b0:	aa 1f       	adc	r26, r26
  b2:	bb 1f       	adc	r27, r27
  b4:	2a 95       	dec	r18
  b6:	02 f4       	brpl	.+0      	; 0xb8 <_ZN6SdFile13addDirClusterEv+0xb8>
  b8:	4a 89       	ldd	r20, Y+18	; 0x12
  ba:	5b 89       	ldd	r21, Y+19	; 0x13
  bc:	6c 89       	ldd	r22, Y+20	; 0x14
  be:	7d 89       	ldd	r23, Y+21	; 0x15
  c0:	84 0f       	add	r24, r20
  c2:	95 1f       	adc	r25, r21
  c4:	a6 1f       	adc	r26, r22
  c6:	b7 1f       	adc	r27, r23
  c8:	8a 8b       	std	Y+18, r24	; 0x12
  ca:	9b 8b       	std	Y+19, r25	; 0x13
  cc:	ac 8b       	std	Y+20, r26	; 0x14
  ce:	bd 8b       	std	Y+21, r27	; 0x15
  d0:	81 e0       	ldi	r24, 0x01	; 1
  d2:	00 c0       	rjmp	.+0      	; 0xd4 <__SREG__+0x95>

Disassembly of section .text._ZN6SdFile13cacheDirEntryEh:

00000000 <_ZN6SdFile13cacheDirEntryEh>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
  write_P(str);
   6:	46 2f       	mov	r20, r22
   8:	6d 85       	ldd	r22, Y+13	; 0x0d
  println();
   a:	7e 85       	ldd	r23, Y+14	; 0x0e
}
   c:	8f 85       	ldd	r24, Y+15	; 0x0f
   e:	98 89       	ldd	r25, Y+16	; 0x10
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile13cacheDirEntryEh>
  14:	88 23       	and	r24, r24
  16:	01 f0       	breq	.+0      	; 0x18 <_ZN6SdFile13cacheDirEntryEh+0x18>
  18:	89 89       	ldd	r24, Y+17	; 0x11
  1a:	20 e2       	ldi	r18, 0x20	; 32
  1c:	82 9f       	mul	r24, r18
  1e:	c0 01       	movw	r24, r0
  20:	11 24       	eor	r1, r1
  22:	80 50       	subi	r24, 0x00	; 0
  24:	90 40       	sbci	r25, 0x00	; 0
  26:	df 91       	pop	r29
  28:	cf 91       	pop	r28
  2a:	08 95       	ret
  2c:	90 e0       	ldi	r25, 0x00	; 0
  2e:	80 e0       	ldi	r24, 0x00	; 0
  30:	00 c0       	rjmp	.+0      	; 0x32 <__zero_reg__+0x31>

Disassembly of section .text._ZN6SdFile15contiguousRangeEPmS0_:

00000000 <_ZN6SdFile15contiguousRangeEPmS0_>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
  write_P(str);
   6:	bf 92       	push	r11
   8:	cf 92       	push	r12
  println();
   a:	df 92       	push	r13
}
   c:	ef 92       	push	r14
   e:	ff 92       	push	r15
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	0f 93       	push	r16
  12:	1f 93       	push	r17
  14:	cf 93       	push	r28
  16:	df 93       	push	r29
  18:	00 d0       	rcall	.+0      	; 0x1a <_ZN6SdFile15contiguousRangeEPmS0_+0x1a>
  1a:	00 d0       	rcall	.+0      	; 0x1c <_ZN6SdFile15contiguousRangeEPmS0_+0x1c>
  1c:	cd b7       	in	r28, 0x3d	; 61
  1e:	de b7       	in	r29, 0x3e	; 62
  20:	dc 01       	movw	r26, r24
  22:	56 96       	adiw	r26, 0x16	; 22
  24:	cd 90       	ld	r12, X+
  26:	dd 90       	ld	r13, X+
  28:	ed 90       	ld	r14, X+
  2a:	fc 90       	ld	r15, X
  2c:	59 97       	sbiw	r26, 0x19	; 25
  2e:	c1 14       	cp	r12, r1
  30:	d1 04       	cpc	r13, r1
  32:	e1 04       	cpc	r14, r1
  34:	f1 04       	cpc	r15, r1
  36:	01 f4       	brne	.+0      	; 0x38 <_ZN6SdFile15contiguousRangeEPmS0_+0x38>
  38:	00 c0       	rjmp	.+0      	; 0x3a <_ZN6SdFile15contiguousRangeEPmS0_+0x3a>
  3a:	8a 01       	movw	r16, r20
  3c:	5b 01       	movw	r10, r22
  3e:	4c 01       	movw	r8, r24
  40:	9e 01       	movw	r18, r28
  42:	2f 5f       	subi	r18, 0xFF	; 255
  44:	3f 4f       	sbci	r19, 0xFF	; 255
  46:	b7 01       	movw	r22, r14
  48:	a6 01       	movw	r20, r12
  4a:	f4 01       	movw	r30, r8
  4c:	82 8d       	ldd	r24, Z+26	; 0x1a
  4e:	93 8d       	ldd	r25, Z+27	; 0x1b
  50:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile15contiguousRangeEPmS0_>
  54:	88 23       	and	r24, r24
  56:	01 f4       	brne	.+0      	; 0x58 <_ZN6SdFile15contiguousRangeEPmS0_+0x58>
  58:	00 c0       	rjmp	.+0      	; 0x5a <_ZN6SdFile15contiguousRangeEPmS0_+0x5a>
  5a:	d7 01       	movw	r26, r14
  5c:	c6 01       	movw	r24, r12
  5e:	01 96       	adiw	r24, 0x01	; 1
  60:	a1 1d       	adc	r26, r1
  62:	b1 1d       	adc	r27, r1
  64:	49 81       	ldd	r20, Y+1	; 0x01
  66:	5a 81       	ldd	r21, Y+2	; 0x02
  68:	6b 81       	ldd	r22, Y+3	; 0x03
  6a:	7c 81       	ldd	r23, Y+4	; 0x04
  6c:	84 17       	cp	r24, r20
  6e:	95 07       	cpc	r25, r21
  70:	a6 07       	cpc	r26, r22
  72:	b7 07       	cpc	r27, r23
  74:	01 f4       	brne	.+0      	; 0x76 <_ZN6SdFile15contiguousRangeEPmS0_+0x76>
  76:	00 c0       	rjmp	.+0      	; 0x78 <_ZN6SdFile15contiguousRangeEPmS0_+0x78>
  78:	d4 01       	movw	r26, r8
  7a:	5a 96       	adiw	r26, 0x1a	; 26
  7c:	ed 91       	ld	r30, X+
  7e:	fc 91       	ld	r31, X
  80:	87 89       	ldd	r24, Z+23	; 0x17
  82:	80 31       	cpi	r24, 0x10	; 16
  84:	01 f4       	brne	.+0      	; 0x86 <_ZN6SdFile15contiguousRangeEPmS0_+0x86>
  86:	00 c0       	rjmp	.+0      	; 0x88 <_ZN6SdFile15contiguousRangeEPmS0_+0x88>
  88:	88 ef       	ldi	r24, 0xF8	; 248
  8a:	9f ef       	ldi	r25, 0xFF	; 255
  8c:	af ef       	ldi	r26, 0xFF	; 255
  8e:	bf e0       	ldi	r27, 0x0F	; 15
  90:	48 17       	cp	r20, r24
  92:	59 07       	cpc	r21, r25
  94:	6a 07       	cpc	r22, r26
  96:	7b 07       	cpc	r23, r27
  98:	00 f4       	brcc	.+0      	; 0x9a <_ZN6SdFile15contiguousRangeEPmS0_+0x9a>
  9a:	00 c0       	rjmp	.+0      	; 0x9c <_ZN6SdFile15contiguousRangeEPmS0_+0x9c>
  9c:	d4 01       	movw	r26, r8
  9e:	56 96       	adiw	r26, 0x16	; 22
  a0:	4d 91       	ld	r20, X+
  a2:	5d 91       	ld	r21, X+
  a4:	6d 91       	ld	r22, X+
  a6:	7c 91       	ld	r23, X
  a8:	59 97       	sbiw	r26, 0x19	; 25
  aa:	db 01       	movw	r26, r22
  ac:	ca 01       	movw	r24, r20
  ae:	02 97       	sbiw	r24, 0x02	; 2
  b0:	a1 09       	sbc	r26, r1
  b2:	b1 09       	sbc	r27, r1
  b4:	25 85       	ldd	r18, Z+13	; 0x0d
  b6:	00 c0       	rjmp	.+0      	; 0xb8 <_ZN6SdFile15contiguousRangeEPmS0_+0xb8>
  b8:	88 0f       	add	r24, r24
  ba:	99 1f       	adc	r25, r25
  bc:	aa 1f       	adc	r26, r26
  be:	bb 1f       	adc	r27, r27
  c0:	2a 95       	dec	r18
  c2:	02 f4       	brpl	.+0      	; 0xc4 <_ZN6SdFile15contiguousRangeEPmS0_+0xc4>
  c4:	46 85       	ldd	r20, Z+14	; 0x0e
  c6:	57 85       	ldd	r21, Z+15	; 0x0f
  c8:	60 89       	ldd	r22, Z+16	; 0x10
  ca:	71 89       	ldd	r23, Z+17	; 0x11
  cc:	48 0f       	add	r20, r24
  ce:	59 1f       	adc	r21, r25
  d0:	6a 1f       	adc	r22, r26
  d2:	7b 1f       	adc	r23, r27
  d4:	d5 01       	movw	r26, r10
  d6:	4d 93       	st	X+, r20
  d8:	5d 93       	st	X+, r21
  da:	6d 93       	st	X+, r22
  dc:	7c 93       	st	X, r23
  de:	13 97       	sbiw	r26, 0x03	; 3
  e0:	86 85       	ldd	r24, Z+14	; 0x0e
  e2:	97 85       	ldd	r25, Z+15	; 0x0f
  e4:	a0 89       	ldd	r26, Z+16	; 0x10
  e6:	b1 89       	ldd	r27, Z+17	; 0x11
  e8:	01 97       	sbiw	r24, 0x01	; 1
  ea:	a1 09       	sbc	r26, r1
  ec:	b1 09       	sbc	r27, r1
  ee:	24 81       	ldd	r18, Z+4	; 0x04
  f0:	82 0f       	add	r24, r18
  f2:	91 1d       	adc	r25, r1
  f4:	a1 1d       	adc	r26, r1
  f6:	b1 1d       	adc	r27, r1
  f8:	22 e0       	ldi	r18, 0x02	; 2
  fa:	c2 1a       	sub	r12, r18
  fc:	d1 08       	sbc	r13, r1
  fe:	e1 08       	sbc	r14, r1
 100:	f1 08       	sbc	r15, r1
 102:	25 85       	ldd	r18, Z+13	; 0x0d
 104:	00 c0       	rjmp	.+0      	; 0x106 <_ZN6SdFile15contiguousRangeEPmS0_+0x106>
 106:	cc 0c       	add	r12, r12
 108:	dd 1c       	adc	r13, r13
 10a:	ee 1c       	adc	r14, r14
 10c:	ff 1c       	adc	r15, r15
 10e:	2a 95       	dec	r18
 110:	02 f4       	brpl	.+0      	; 0x112 <_ZN6SdFile15contiguousRangeEPmS0_+0x112>
 112:	8c 0d       	add	r24, r12
 114:	9d 1d       	adc	r25, r13
 116:	ae 1d       	adc	r26, r14
 118:	bf 1d       	adc	r27, r15
 11a:	f8 01       	movw	r30, r16
 11c:	80 83       	st	Z, r24
 11e:	91 83       	std	Z+1, r25	; 0x01
 120:	a2 83       	std	Z+2, r26	; 0x02
 122:	b3 83       	std	Z+3, r27	; 0x03
 124:	81 e0       	ldi	r24, 0x01	; 1
 126:	0f 90       	pop	r0
 128:	0f 90       	pop	r0
 12a:	0f 90       	pop	r0
 12c:	0f 90       	pop	r0
 12e:	df 91       	pop	r29
 130:	cf 91       	pop	r28
 132:	1f 91       	pop	r17
 134:	0f 91       	pop	r16
 136:	ff 90       	pop	r15
 138:	ef 90       	pop	r14
 13a:	df 90       	pop	r13
 13c:	cf 90       	pop	r12
 13e:	bf 90       	pop	r11
 140:	af 90       	pop	r10
 142:	9f 90       	pop	r9
 144:	8f 90       	pop	r8
 146:	08 95       	ret
 148:	88 ef       	ldi	r24, 0xF8	; 248
 14a:	9f ef       	ldi	r25, 0xFF	; 255
 14c:	a0 e0       	ldi	r26, 0x00	; 0
 14e:	b0 e0       	ldi	r27, 0x00	; 0
 150:	00 c0       	rjmp	.+0      	; 0x152 <_ZN6SdFile15contiguousRangeEPmS0_+0x152>
 152:	6c 01       	movw	r12, r24
 154:	7d 01       	movw	r14, r26
 156:	00 c0       	rjmp	.+0      	; 0x158 <_ZN6SdFile15contiguousRangeEPmS0_+0x158>
 158:	80 e0       	ldi	r24, 0x00	; 0
 15a:	00 c0       	rjmp	.+0      	; 0x15c <__SREG__+0x11d>

Disassembly of section .text._ZN6SdFile7dirNameERK14directoryEntryPc:

00000000 <_ZN6SdFile7dirNameERK14directoryEntryPc>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	dc 01       	movw	r26, r24
  write_P(str);
   6:	90 e0       	ldi	r25, 0x00	; 0
   8:	e0 e0       	ldi	r30, 0x00	; 0
  println();
   a:	8e e2       	ldi	r24, 0x2E	; 46
}
   c:	2d 91       	ld	r18, X+
   e:	20 32       	cpi	r18, 0x20	; 32
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	01 f0       	breq	.+0      	; 0x12 <_ZN6SdFile7dirNameERK14directoryEntryPc+0x12>
  12:	98 30       	cpi	r25, 0x08	; 8
  14:	01 f4       	brne	.+0      	; 0x16 <_ZN6SdFile7dirNameERK14directoryEntryPc+0x16>
  16:	eb 01       	movw	r28, r22
  18:	ce 0f       	add	r28, r30
  1a:	d1 1d       	adc	r29, r1
  1c:	88 83       	st	Y, r24
  1e:	ef 5f       	subi	r30, 0xFF	; 255
  20:	ed 01       	movw	r28, r26
  22:	21 97       	sbiw	r28, 0x01	; 1
  24:	28 81       	ld	r18, Y
  26:	eb 01       	movw	r28, r22
  28:	ce 0f       	add	r28, r30
  2a:	d1 1d       	adc	r29, r1
  2c:	28 83       	st	Y, r18
  2e:	ef 5f       	subi	r30, 0xFF	; 255
  30:	9f 5f       	subi	r25, 0xFF	; 255
  32:	9b 30       	cpi	r25, 0x0B	; 11
  34:	01 f4       	brne	.+0      	; 0x36 <_ZN6SdFile7dirNameERK14directoryEntryPc+0x36>
  36:	e6 0f       	add	r30, r22
  38:	f7 2f       	mov	r31, r23
  3a:	f1 1d       	adc	r31, r1
  3c:	10 82       	st	Z, r1
  3e:	df 91       	pop	r29
  40:	cf 91       	pop	r28
  42:	08 95       	ret

Disassembly of section .text._ZN6SdFile10make83NameEPKcPh:

00000000 <_ZN6SdFile10make83NameEPKcPh>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	fb 01       	movw	r30, r22
   2:	9b 01       	movw	r18, r22
   4:	25 5f       	subi	r18, 0xF5	; 245
  write_P(str);
   6:	3f 4f       	sbci	r19, 0xFF	; 255
   8:	40 e2       	ldi	r20, 0x20	; 32
  println();
   a:	41 93       	st	Z+, r20
}
   c:	2e 17       	cp	r18, r30
   e:	3f 07       	cpc	r19, r31
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	01 f4       	brne	.+0      	; 0x12 <_ZN6SdFile10make83NameEPKcPh+0x12>
  12:	dc 01       	movw	r26, r24
  14:	20 e0       	ldi	r18, 0x00	; 0
  16:	37 e0       	ldi	r19, 0x07	; 7
  18:	9d 91       	ld	r25, X+
  1a:	99 23       	and	r25, r25
  1c:	01 f0       	breq	.+0      	; 0x1e <_ZN6SdFile10make83NameEPKcPh+0x1e>
  1e:	9e 32       	cpi	r25, 0x2E	; 46
  20:	01 f4       	brne	.+0      	; 0x22 <_ZN6SdFile10make83NameEPKcPh+0x22>
  22:	3a 30       	cpi	r19, 0x0A	; 10
  24:	01 f0       	breq	.+0      	; 0x26 <_ZN6SdFile10make83NameEPKcPh+0x26>
  26:	28 e0       	ldi	r18, 0x08	; 8
  28:	3a e0       	ldi	r19, 0x0A	; 10
  2a:	00 c0       	rjmp	.+0      	; 0x2c <_ZN6SdFile10make83NameEPKcPh+0x2c>
  2c:	e0 e0       	ldi	r30, 0x00	; 0
  2e:	f0 e0       	ldi	r31, 0x00	; 0
  30:	84 91       	lpm	r24, Z
  32:	88 23       	and	r24, r24
  34:	01 f0       	breq	.+0      	; 0x36 <_ZN6SdFile10make83NameEPKcPh+0x36>
  36:	31 96       	adiw	r30, 0x01	; 1
  38:	98 13       	cpse	r25, r24
  3a:	00 c0       	rjmp	.+0      	; 0x3c <_ZN6SdFile10make83NameEPKcPh+0x3c>
  3c:	80 e0       	ldi	r24, 0x00	; 0
  3e:	00 c0       	rjmp	.+0      	; 0x40 <_ZN6SdFile10make83NameEPKcPh+0x40>
  40:	32 17       	cp	r19, r18
  42:	00 f0       	brcs	.+0      	; 0x44 <_ZN6SdFile10make83NameEPKcPh+0x44>
  44:	4f ed       	ldi	r20, 0xDF	; 223
  46:	49 0f       	add	r20, r25
  48:	4e 35       	cpi	r20, 0x5E	; 94
  4a:	00 f4       	brcc	.+0      	; 0x4c <_ZN6SdFile10make83NameEPKcPh+0x4c>
  4c:	8f e9       	ldi	r24, 0x9F	; 159
  4e:	89 0f       	add	r24, r25
  50:	8a 31       	cpi	r24, 0x1A	; 26
  52:	00 f4       	brcc	.+0      	; 0x54 <_ZN6SdFile10make83NameEPKcPh+0x54>
  54:	90 52       	subi	r25, 0x20	; 32
  56:	fb 01       	movw	r30, r22
  58:	e2 0f       	add	r30, r18
  5a:	f1 1d       	adc	r31, r1
  5c:	90 83       	st	Z, r25
  5e:	2f 5f       	subi	r18, 0xFF	; 255
  60:	00 c0       	rjmp	.+0      	; 0x62 <_ZN6SdFile10make83NameEPKcPh+0x62>
  62:	81 e0       	ldi	r24, 0x01	; 1
  64:	fb 01       	movw	r30, r22
  66:	90 81       	ld	r25, Z
  68:	90 32       	cpi	r25, 0x20	; 32
  6a:	01 f0       	breq	.+0      	; 0x6c <_ZN6SdFile10make83NameEPKcPh+0x6c>
  6c:	08 95       	ret

Disassembly of section .text._ZN6SdFile8openRootEP8SdVolume:

00000000 <_ZN6SdFile8openRootEP8SdVolume>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
  write_P(str);
   6:	df 93       	push	r29
   8:	fc 01       	movw	r30, r24
  println();
   a:	24 81       	ldd	r18, Z+4	; 0x04
}
   c:	22 23       	and	r18, r18
   e:	01 f0       	breq	.+0      	; 0x10 <_ZN6SdFile8openRootEP8SdVolume+0x10>
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	80 e0       	ldi	r24, 0x00	; 0
  12:	df 91       	pop	r29
  14:	cf 91       	pop	r28
  16:	1f 91       	pop	r17
  18:	0f 91       	pop	r16
  1a:	08 95       	ret
  1c:	8b 01       	movw	r16, r22
  1e:	ec 01       	movw	r28, r24
  20:	fb 01       	movw	r30, r22
  22:	87 89       	ldd	r24, Z+23	; 0x17
  24:	80 31       	cpi	r24, 0x10	; 16
  26:	01 f4       	brne	.+0      	; 0x28 <_ZN6SdFile8openRootEP8SdVolume+0x28>
  28:	82 e0       	ldi	r24, 0x02	; 2
  2a:	8c 83       	std	Y+4, r24	; 0x04
  2c:	1e 8a       	std	Y+22, r1	; 0x16
  2e:	1f 8a       	std	Y+23, r1	; 0x17
  30:	18 8e       	std	Y+24, r1	; 0x18
  32:	19 8e       	std	Y+25, r1	; 0x19
  34:	80 8d       	ldd	r24, Z+24	; 0x18
  36:	91 8d       	ldd	r25, Z+25	; 0x19
  38:	b0 e0       	ldi	r27, 0x00	; 0
  3a:	a0 e0       	ldi	r26, 0x00	; 0
  3c:	25 e0       	ldi	r18, 0x05	; 5
  3e:	88 0f       	add	r24, r24
  40:	99 1f       	adc	r25, r25
  42:	aa 1f       	adc	r26, r26
  44:	bb 1f       	adc	r27, r27
  46:	2a 95       	dec	r18
  48:	01 f4       	brne	.+0      	; 0x4a <_ZN6SdFile8openRootEP8SdVolume+0x4a>
  4a:	8a 8b       	std	Y+18, r24	; 0x12
  4c:	9b 8b       	std	Y+19, r25	; 0x13
  4e:	ac 8b       	std	Y+20, r26	; 0x14
  50:	bd 8b       	std	Y+21, r27	; 0x15
  52:	1b 8f       	std	Y+27, r17	; 0x1b
  54:	0a 8f       	std	Y+26, r16	; 0x1a
  56:	81 e0       	ldi	r24, 0x01	; 1
  58:	8b 83       	std	Y+3, r24	; 0x03
  5a:	1d 82       	std	Y+5, r1	; 0x05
  5c:	1e 82       	std	Y+6, r1	; 0x06
  5e:	1f 82       	std	Y+7, r1	; 0x07
  60:	18 86       	std	Y+8, r1	; 0x08
  62:	19 86       	std	Y+9, r1	; 0x09
  64:	1a 86       	std	Y+10, r1	; 0x0a
  66:	1b 86       	std	Y+11, r1	; 0x0b
  68:	1c 86       	std	Y+12, r1	; 0x0c
  6a:	1d 86       	std	Y+13, r1	; 0x0d
  6c:	1e 86       	std	Y+14, r1	; 0x0e
  6e:	1f 86       	std	Y+15, r1	; 0x0f
  70:	18 8a       	std	Y+16, r1	; 0x10
  72:	19 8a       	std	Y+17, r1	; 0x11
  74:	00 c0       	rjmp	.+0      	; 0x76 <_ZN6SdFile8openRootEP8SdVolume+0x76>
  76:	80 32       	cpi	r24, 0x20	; 32
  78:	01 f4       	brne	.+0      	; 0x7a <_ZN6SdFile8openRootEP8SdVolume+0x7a>
  7a:	83 e0       	ldi	r24, 0x03	; 3
  7c:	8c 83       	std	Y+4, r24	; 0x04
  7e:	42 8d       	ldd	r20, Z+26	; 0x1a
  80:	53 8d       	ldd	r21, Z+27	; 0x1b
  82:	64 8d       	ldd	r22, Z+28	; 0x1c
  84:	75 8d       	ldd	r23, Z+29	; 0x1d
  86:	4e 8b       	std	Y+22, r20	; 0x16
  88:	5f 8b       	std	Y+23, r21	; 0x17
  8a:	68 8f       	std	Y+24, r22	; 0x18
  8c:	79 8f       	std	Y+25, r23	; 0x19
  8e:	9e 01       	movw	r18, r28
  90:	2e 5e       	subi	r18, 0xEE	; 238
  92:	3f 4f       	sbci	r19, 0xFF	; 255
  94:	c8 01       	movw	r24, r16
  96:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile8openRootEP8SdVolume>
  9a:	81 11       	cpse	r24, r1
  9c:	00 c0       	rjmp	.+0      	; 0x9e <_ZN6SdFile8openRootEP8SdVolume+0x9e>
  9e:	00 c0       	rjmp	.+0      	; 0xa0 <__SREG__+0x61>

Disassembly of section .text._ZN6SdFile12printDirNameERK14directoryEntryh:

00000000 <_ZN6SdFile12printDirNameERK14directoryEntryh>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	df 92       	push	r13
   2:	ef 92       	push	r14
   4:	ff 92       	push	r15
  write_P(str);
   6:	0f 93       	push	r16
   8:	1f 93       	push	r17
  println();
   a:	cf 93       	push	r28
}
   c:	df 93       	push	r29
   e:	7c 01       	movw	r14, r24
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	d6 2e       	mov	r13, r22
  12:	8c 01       	movw	r16, r24
  14:	d0 e0       	ldi	r29, 0x00	; 0
  16:	c0 e0       	ldi	r28, 0x00	; 0
  18:	f8 01       	movw	r30, r16
  1a:	81 91       	ld	r24, Z+
  1c:	8f 01       	movw	r16, r30
  1e:	80 32       	cpi	r24, 0x20	; 32
  20:	01 f0       	breq	.+0      	; 0x22 <_ZN6SdFile12printDirNameERK14directoryEntryh+0x22>
  22:	d8 30       	cpi	r29, 0x08	; 8
  24:	01 f4       	brne	.+0      	; 0x26 <_ZN6SdFile12printDirNameERK14directoryEntryh+0x26>
  26:	cf 5f       	subi	r28, 0xFF	; 255
  28:	50 e0       	ldi	r21, 0x00	; 0
  2a:	40 e0       	ldi	r20, 0x00	; 0
  2c:	6e e2       	ldi	r22, 0x2E	; 46
  2e:	80 e0       	ldi	r24, 0x00	; 0
  30:	90 e0       	ldi	r25, 0x00	; 0
  32:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile12printDirNameERK14directoryEntryh>
  36:	50 e0       	ldi	r21, 0x00	; 0
  38:	40 e0       	ldi	r20, 0x00	; 0
  3a:	f8 01       	movw	r30, r16
  3c:	31 97       	sbiw	r30, 0x01	; 1
  3e:	60 81       	ld	r22, Z
  40:	80 e0       	ldi	r24, 0x00	; 0
  42:	90 e0       	ldi	r25, 0x00	; 0
  44:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile12printDirNameERK14directoryEntryh>
  48:	cf 5f       	subi	r28, 0xFF	; 255
  4a:	df 5f       	subi	r29, 0xFF	; 255
  4c:	db 30       	cpi	r29, 0x0B	; 11
  4e:	01 f4       	brne	.+0      	; 0x50 <_ZN6SdFile12printDirNameERK14directoryEntryh+0x50>
  50:	f7 01       	movw	r30, r14
  52:	83 85       	ldd	r24, Z+11	; 0x0b
  54:	88 71       	andi	r24, 0x18	; 24
  56:	80 31       	cpi	r24, 0x10	; 16
  58:	01 f4       	brne	.+0      	; 0x5a <_ZN6SdFile12printDirNameERK14directoryEntryh+0x5a>
  5a:	50 e0       	ldi	r21, 0x00	; 0
  5c:	40 e0       	ldi	r20, 0x00	; 0
  5e:	6f e2       	ldi	r22, 0x2F	; 47
  60:	80 e0       	ldi	r24, 0x00	; 0
  62:	90 e0       	ldi	r25, 0x00	; 0
  64:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile12printDirNameERK14directoryEntryh>
  68:	cf 5f       	subi	r28, 0xFF	; 255
  6a:	50 e0       	ldi	r21, 0x00	; 0
  6c:	40 e0       	ldi	r20, 0x00	; 0
  6e:	60 e2       	ldi	r22, 0x20	; 32
  70:	cd 15       	cp	r28, r13
  72:	00 f0       	brcs	.+0      	; 0x74 <_ZN6SdFile12printDirNameERK14directoryEntryh+0x74>
  74:	df 91       	pop	r29
  76:	cf 91       	pop	r28
  78:	1f 91       	pop	r17
  7a:	0f 91       	pop	r16
  7c:	ff 90       	pop	r15
  7e:	ef 90       	pop	r14
  80:	df 90       	pop	r13
  82:	08 95       	ret

Disassembly of section .text._ZN6SdFile14printTwoDigitsEh:

00000000 <_ZN6SdFile14printTwoDigitsEh>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	00 d0       	rcall	.+0      	; 0x6 <_ZN6SdFile14printTwoDigitsEh+0x6>
  write_P(str);
   6:	1f 92       	push	r1
   8:	cd b7       	in	r28, 0x3d	; 61
  println();
   a:	de b7       	in	r29, 0x3e	; 62
}
   c:	6a e0       	ldi	r22, 0x0A	; 10
   e:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile14printTwoDigitsEh>
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  12:	80 5d       	subi	r24, 0xD0	; 208
  14:	89 83       	std	Y+1, r24	; 0x01
  16:	90 5d       	subi	r25, 0xD0	; 208
  18:	9a 83       	std	Y+2, r25	; 0x02
  1a:	1b 82       	std	Y+3, r1	; 0x03
  1c:	be 01       	movw	r22, r28
  1e:	6f 5f       	subi	r22, 0xFF	; 255
  20:	7f 4f       	sbci	r23, 0xFF	; 255
  22:	80 e0       	ldi	r24, 0x00	; 0
  24:	90 e0       	ldi	r25, 0x00	; 0
  26:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile14printTwoDigitsEh>
  2a:	0f 90       	pop	r0
  2c:	0f 90       	pop	r0
  2e:	0f 90       	pop	r0
  30:	df 91       	pop	r29
  32:	cf 91       	pop	r28
  34:	08 95       	ret

Disassembly of section .text._ZN6SdFile12printFatDateEj:

00000000 <_ZN6SdFile12printFatDateEj>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
  write_P(str);
   6:	bc 01       	movw	r22, r24
   8:	67 2f       	mov	r22, r23
  println();
   a:	77 27       	eor	r23, r23
}
   c:	66 95       	lsr	r22
   e:	64 54       	subi	r22, 0x44	; 68
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	78 4f       	sbci	r23, 0xF8	; 248
  12:	4a e0       	ldi	r20, 0x0A	; 10
  14:	50 e0       	ldi	r21, 0x00	; 0
  16:	80 e0       	ldi	r24, 0x00	; 0
  18:	90 e0       	ldi	r25, 0x00	; 0
  1a:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile12printFatDateEj>
  1e:	50 e0       	ldi	r21, 0x00	; 0
  20:	40 e0       	ldi	r20, 0x00	; 0
  22:	6d e2       	ldi	r22, 0x2D	; 45
  24:	80 e0       	ldi	r24, 0x00	; 0
  26:	90 e0       	ldi	r25, 0x00	; 0
  28:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile12printFatDateEj>
  2c:	ce 01       	movw	r24, r28
  2e:	25 e0       	ldi	r18, 0x05	; 5
  30:	96 95       	lsr	r25
  32:	87 95       	ror	r24
  34:	2a 95       	dec	r18
  36:	01 f4       	brne	.+0      	; 0x38 <_ZN6SdFile12printFatDateEj+0x38>
  38:	8f 70       	andi	r24, 0x0F	; 15
  3a:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile12printFatDateEj>
  3e:	50 e0       	ldi	r21, 0x00	; 0
  40:	40 e0       	ldi	r20, 0x00	; 0
  42:	6d e2       	ldi	r22, 0x2D	; 45
  44:	80 e0       	ldi	r24, 0x00	; 0
  46:	90 e0       	ldi	r25, 0x00	; 0
  48:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile12printFatDateEj>
  4c:	8c 2f       	mov	r24, r28
  4e:	8f 71       	andi	r24, 0x1F	; 31
  50:	df 91       	pop	r29
  52:	cf 91       	pop	r28
  54:	0c 94 00 00 	jmp	0	; 0x0 <_ZN6SdFile12printFatDateEj>

Disassembly of section .text._ZN6SdFile12printFatTimeEj:

00000000 <_ZN6SdFile12printFatTimeEj>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
  write_P(str);
   6:	8d 2f       	mov	r24, r29
   8:	86 95       	lsr	r24
  println();
   a:	86 95       	lsr	r24
}
   c:	86 95       	lsr	r24
   e:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile12printFatTimeEj>
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  12:	50 e0       	ldi	r21, 0x00	; 0
  14:	40 e0       	ldi	r20, 0x00	; 0
  16:	6a e3       	ldi	r22, 0x3A	; 58
  18:	80 e0       	ldi	r24, 0x00	; 0
  1a:	90 e0       	ldi	r25, 0x00	; 0
  1c:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile12printFatTimeEj>
  20:	ce 01       	movw	r24, r28
  22:	25 e0       	ldi	r18, 0x05	; 5
  24:	96 95       	lsr	r25
  26:	87 95       	ror	r24
  28:	2a 95       	dec	r18
  2a:	01 f4       	brne	.+0      	; 0x2c <_ZN6SdFile12printFatTimeEj+0x2c>
  2c:	8f 73       	andi	r24, 0x3F	; 63
  2e:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile12printFatTimeEj>
  32:	50 e0       	ldi	r21, 0x00	; 0
  34:	40 e0       	ldi	r20, 0x00	; 0
  36:	6a e3       	ldi	r22, 0x3A	; 58
  38:	80 e0       	ldi	r24, 0x00	; 0
  3a:	90 e0       	ldi	r25, 0x00	; 0
  3c:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile12printFatTimeEj>
  40:	8c 2f       	mov	r24, r28
  42:	8f 71       	andi	r24, 0x1F	; 31
  44:	88 0f       	add	r24, r24
  46:	df 91       	pop	r29
  48:	cf 91       	pop	r28
  4a:	0c 94 00 00 	jmp	0	; 0x0 <_ZN6SdFile12printFatTimeEj>

Disassembly of section .text._ZN6SdFile4readEPvj:

00000000 <_ZN6SdFile4readEPvj>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
  write_P(str);
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
  println();
   a:	7f 92       	push	r7
}
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  24:	ec 01       	movw	r28, r24
  26:	5b 01       	movw	r10, r22
  28:	2a 01       	movw	r4, r20
  2a:	8c 81       	ldd	r24, Y+4	; 0x04
  2c:	81 11       	cpse	r24, r1
  2e:	00 c0       	rjmp	.+0      	; 0x30 <_ZN6SdFile4readEPvj+0x30>
  30:	8f ef       	ldi	r24, 0xFF	; 255
  32:	9f ef       	ldi	r25, 0xFF	; 255
  34:	df 91       	pop	r29
  36:	cf 91       	pop	r28
  38:	1f 91       	pop	r17
  3a:	0f 91       	pop	r16
  3c:	ff 90       	pop	r15
  3e:	ef 90       	pop	r14
  40:	df 90       	pop	r13
  42:	cf 90       	pop	r12
  44:	bf 90       	pop	r11
  46:	af 90       	pop	r10
  48:	9f 90       	pop	r9
  4a:	8f 90       	pop	r8
  4c:	7f 90       	pop	r7
  4e:	6f 90       	pop	r6
  50:	5f 90       	pop	r5
  52:	4f 90       	pop	r4
  54:	3f 90       	pop	r3
  56:	2f 90       	pop	r2
  58:	08 95       	ret
  5a:	8b 81       	ldd	r24, Y+3	; 0x03
  5c:	80 ff       	sbrs	r24, 0
  5e:	00 c0       	rjmp	.+0      	; 0x60 <_ZN6SdFile4readEPvj+0x60>
  60:	0a 89       	ldd	r16, Y+18	; 0x12
  62:	1b 89       	ldd	r17, Y+19	; 0x13
  64:	2c 89       	ldd	r18, Y+20	; 0x14
  66:	3d 89       	ldd	r19, Y+21	; 0x15
  68:	49 85       	ldd	r20, Y+9	; 0x09
  6a:	5a 85       	ldd	r21, Y+10	; 0x0a
  6c:	6b 85       	ldd	r22, Y+11	; 0x0b
  6e:	7c 85       	ldd	r23, Y+12	; 0x0c
  70:	c2 01       	movw	r24, r4
  72:	b0 e0       	ldi	r27, 0x00	; 0
  74:	a0 e0       	ldi	r26, 0x00	; 0
  76:	68 01       	movw	r12, r16
  78:	79 01       	movw	r14, r18
  7a:	c4 1a       	sub	r12, r20
  7c:	d5 0a       	sbc	r13, r21
  7e:	e6 0a       	sbc	r14, r22
  80:	f7 0a       	sbc	r15, r23
  82:	c8 16       	cp	r12, r24
  84:	d9 06       	cpc	r13, r25
  86:	ea 06       	cpc	r14, r26
  88:	fb 06       	cpc	r15, r27
  8a:	00 f4       	brcc	.+0      	; 0x8c <_ZN6SdFile4readEPvj+0x8c>
  8c:	28 01       	movw	r4, r16
  8e:	44 1a       	sub	r4, r20
  90:	55 0a       	sbc	r5, r21
  92:	42 01       	movw	r8, r4
  94:	1e 01       	movw	r2, r28
  96:	25 e0       	ldi	r18, 0x05	; 5
  98:	22 0e       	add	r2, r18
  9a:	31 1c       	adc	r3, r1
  9c:	81 14       	cp	r8, r1
  9e:	91 04       	cpc	r9, r1
  a0:	01 f4       	brne	.+0      	; 0xa2 <_ZN6SdFile4readEPvj+0xa2>
  a2:	00 c0       	rjmp	.+0      	; 0xa4 <_ZN6SdFile4readEPvj+0xa4>
  a4:	49 85       	ldd	r20, Y+9	; 0x09
  a6:	5a 85       	ldd	r21, Y+10	; 0x0a
  a8:	6b 85       	ldd	r22, Y+11	; 0x0b
  aa:	7c 85       	ldd	r23, Y+12	; 0x0c
  ac:	6a 01       	movw	r12, r20
  ae:	81 e0       	ldi	r24, 0x01	; 1
  b0:	d8 22       	and	r13, r24
  b2:	8a 8d       	ldd	r24, Y+26	; 0x1a
  b4:	9b 8d       	ldd	r25, Y+27	; 0x1b
  b6:	8a 01       	movw	r16, r20
  b8:	9b 01       	movw	r18, r22
  ba:	e9 e0       	ldi	r30, 0x09	; 9
  bc:	36 95       	lsr	r19
  be:	27 95       	ror	r18
  c0:	17 95       	ror	r17
  c2:	07 95       	ror	r16
  c4:	ea 95       	dec	r30
  c6:	01 f4       	brne	.+0      	; 0xc8 <_ZN6SdFile4readEPvj+0xc8>
  c8:	ec 81       	ldd	r30, Y+4	; 0x04
  ca:	e2 30       	cpi	r30, 0x02	; 2
  cc:	01 f4       	brne	.+0      	; 0xce <_ZN6SdFile4readEPvj+0xce>
  ce:	fc 01       	movw	r30, r24
  d0:	62 8d       	ldd	r22, Z+26	; 0x1a
  d2:	73 8d       	ldd	r23, Z+27	; 0x1b
  d4:	84 8d       	ldd	r24, Z+28	; 0x1c
  d6:	95 8d       	ldd	r25, Z+29	; 0x1d
  d8:	60 0f       	add	r22, r16
  da:	71 1f       	adc	r23, r17
  dc:	82 1f       	adc	r24, r18
  de:	93 1f       	adc	r25, r19
  e0:	61 2c       	mov	r6, r1
  e2:	22 e0       	ldi	r18, 0x02	; 2
  e4:	72 2e       	mov	r7, r18
  e6:	6c 18       	sub	r6, r12
  e8:	7d 08       	sbc	r7, r13
  ea:	86 14       	cp	r8, r6
  ec:	97 04       	cpc	r9, r7
  ee:	00 f4       	brcc	.+0      	; 0xf0 <_ZN6SdFile4readEPvj+0xf0>
  f0:	34 01       	movw	r6, r8
  f2:	2b 81       	ldd	r18, Y+3	; 0x03
  f4:	26 fd       	sbrc	r18, 6
  f6:	00 c0       	rjmp	.+0      	; 0xf8 <_ZN6SdFile4readEPvj+0xf8>
  f8:	61 14       	cp	r6, r1
  fa:	f2 e0       	ldi	r31, 0x02	; 2
  fc:	7f 06       	cpc	r7, r31
  fe:	01 f4       	brne	.+0      	; 0x100 <_ZN6SdFile4readEPvj+0x100>
 100:	00 91 00 00 	lds	r16, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 104:	10 91 00 00 	lds	r17, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 108:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 10c:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 110:	06 17       	cp	r16, r22
 112:	17 07       	cpc	r17, r23
 114:	28 07       	cpc	r18, r24
 116:	39 07       	cpc	r19, r25
 118:	01 f0       	breq	.+0      	; 0x11a <_ZN6SdFile4readEPvj+0x11a>
 11a:	00 c0       	rjmp	.+0      	; 0x11c <_ZN6SdFile4readEPvj+0x11c>
 11c:	40 e0       	ldi	r20, 0x00	; 0
 11e:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile4readEPvj>
 122:	88 23       	and	r24, r24
 124:	01 f4       	brne	.+0      	; 0x126 <_ZN6SdFile4readEPvj+0x126>
 126:	00 c0       	rjmp	.+0      	; 0x128 <_ZN6SdFile4readEPvj+0x128>
 128:	c6 01       	movw	r24, r12
 12a:	80 50       	subi	r24, 0x00	; 0
 12c:	90 40       	sbci	r25, 0x00	; 0
 12e:	d5 01       	movw	r26, r10
 130:	9c 01       	movw	r18, r24
 132:	26 0d       	add	r18, r6
 134:	37 1d       	adc	r19, r7
 136:	fc 01       	movw	r30, r24
 138:	2e 17       	cp	r18, r30
 13a:	3f 07       	cpc	r19, r31
 13c:	01 f4       	brne	.+0      	; 0x13e <_ZN6SdFile4readEPvj+0x13e>
 13e:	00 c0       	rjmp	.+0      	; 0x140 <_ZN6SdFile4readEPvj+0x140>
 140:	41 91       	ld	r20, Z+
 142:	4d 93       	st	X+, r20
 144:	00 c0       	rjmp	.+0      	; 0x146 <_ZN6SdFile4readEPvj+0x146>
 146:	fc 01       	movw	r30, r24
 148:	74 80       	ldd	r7, Z+4	; 0x04
 14a:	7a 94       	dec	r7
 14c:	70 22       	and	r7, r16
 14e:	c1 14       	cp	r12, r1
 150:	d1 04       	cpc	r13, r1
 152:	01 f4       	brne	.+0      	; 0x154 <_ZN6SdFile4readEPvj+0x154>
 154:	71 10       	cpse	r7, r1
 156:	00 c0       	rjmp	.+0      	; 0x158 <_ZN6SdFile4readEPvj+0x158>
 158:	45 2b       	or	r20, r21
 15a:	46 2b       	or	r20, r22
 15c:	47 2b       	or	r20, r23
 15e:	01 f4       	brne	.+0      	; 0x160 <_ZN6SdFile4readEPvj+0x160>
 160:	8e 89       	ldd	r24, Y+22	; 0x16
 162:	9f 89       	ldd	r25, Y+23	; 0x17
 164:	a8 8d       	ldd	r26, Y+24	; 0x18
 166:	b9 8d       	ldd	r27, Y+25	; 0x19
 168:	8d 83       	std	Y+5, r24	; 0x05
 16a:	9e 83       	std	Y+6, r25	; 0x06
 16c:	af 83       	std	Y+7, r26	; 0x07
 16e:	b8 87       	std	Y+8, r27	; 0x08
 170:	ea 8d       	ldd	r30, Y+26	; 0x1a
 172:	fb 8d       	ldd	r31, Y+27	; 0x1b
 174:	6d 81       	ldd	r22, Y+5	; 0x05
 176:	7e 81       	ldd	r23, Y+6	; 0x06
 178:	8f 81       	ldd	r24, Y+7	; 0x07
 17a:	98 85       	ldd	r25, Y+8	; 0x08
 17c:	62 50       	subi	r22, 0x02	; 2
 17e:	71 09       	sbc	r23, r1
 180:	81 09       	sbc	r24, r1
 182:	91 09       	sbc	r25, r1
 184:	25 85       	ldd	r18, Z+13	; 0x0d
 186:	00 c0       	rjmp	.+0      	; 0x188 <_ZN6SdFile4readEPvj+0x188>
 188:	66 0f       	add	r22, r22
 18a:	77 1f       	adc	r23, r23
 18c:	88 1f       	adc	r24, r24
 18e:	99 1f       	adc	r25, r25
 190:	2a 95       	dec	r18
 192:	02 f4       	brpl	.+0      	; 0x194 <_ZN6SdFile4readEPvj+0x194>
 194:	06 85       	ldd	r16, Z+14	; 0x0e
 196:	17 85       	ldd	r17, Z+15	; 0x0f
 198:	20 89       	ldd	r18, Z+16	; 0x10
 19a:	31 89       	ldd	r19, Z+17	; 0x11
 19c:	60 0f       	add	r22, r16
 19e:	71 1f       	adc	r23, r17
 1a0:	82 1f       	adc	r24, r18
 1a2:	93 1f       	adc	r25, r19
 1a4:	67 0d       	add	r22, r7
 1a6:	71 1d       	adc	r23, r1
 1a8:	81 1d       	adc	r24, r1
 1aa:	91 1d       	adc	r25, r1
 1ac:	00 c0       	rjmp	.+0      	; 0x1ae <_ZN6SdFile4readEPvj+0x1ae>
 1ae:	4d 81       	ldd	r20, Y+5	; 0x05
 1b0:	5e 81       	ldd	r21, Y+6	; 0x06
 1b2:	6f 81       	ldd	r22, Y+7	; 0x07
 1b4:	78 85       	ldd	r23, Y+8	; 0x08
 1b6:	91 01       	movw	r18, r2
 1b8:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile4readEPvj>
 1bc:	81 11       	cpse	r24, r1
 1be:	00 c0       	rjmp	.+0      	; 0x1c0 <_ZN6SdFile4readEPvj+0x1c0>
 1c0:	00 c0       	rjmp	.+0      	; 0x1c2 <_ZN6SdFile4readEPvj+0x1c2>
 1c2:	75 01       	movw	r14, r10
 1c4:	83 01       	movw	r16, r6
 1c6:	96 01       	movw	r18, r12
 1c8:	ab 01       	movw	r20, r22
 1ca:	bc 01       	movw	r22, r24
 1cc:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1d0:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1d4:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile4readEPvj>
 1d8:	88 23       	and	r24, r24
 1da:	01 f4       	brne	.+0      	; 0x1dc <_ZN6SdFile4readEPvj+0x1dc>
 1dc:	00 c0       	rjmp	.+0      	; 0x1de <_ZN6SdFile4readEPvj+0x1de>
 1de:	a6 0c       	add	r10, r6
 1e0:	b7 1c       	adc	r11, r7
 1e2:	89 85       	ldd	r24, Y+9	; 0x09
 1e4:	9a 85       	ldd	r25, Y+10	; 0x0a
 1e6:	ab 85       	ldd	r26, Y+11	; 0x0b
 1e8:	bc 85       	ldd	r27, Y+12	; 0x0c
 1ea:	86 0d       	add	r24, r6
 1ec:	97 1d       	adc	r25, r7
 1ee:	a1 1d       	adc	r26, r1
 1f0:	b1 1d       	adc	r27, r1
 1f2:	89 87       	std	Y+9, r24	; 0x09
 1f4:	9a 87       	std	Y+10, r25	; 0x0a
 1f6:	ab 87       	std	Y+11, r26	; 0x0b
 1f8:	bc 87       	std	Y+12, r27	; 0x0c
 1fa:	86 18       	sub	r8, r6
 1fc:	97 08       	sbc	r9, r7
 1fe:	00 c0       	rjmp	.+0      	; 0x200 <_ZN6SdFile4readEPvj+0x200>
 200:	28 1b       	sub	r18, r24
 202:	39 0b       	sbc	r19, r25
 204:	a2 0e       	add	r10, r18
 206:	b3 1e       	adc	r11, r19
 208:	00 c0       	rjmp	.+0      	; 0x20a <_ZN6SdFile4readEPvj+0x20a>
 20a:	c2 01       	movw	r24, r4
 20c:	00 c0       	rjmp	.+0      	; 0x20e <__SREG__+0x1cf>

Disassembly of section .text._ZN6SdFile7readDirEP14directoryEntry:

00000000 <_ZN6SdFile7readDirEP14directoryEntry>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
  write_P(str);
   6:	df 93       	push	r29
   8:	fc 01       	movw	r30, r24
  println();
   a:	24 81       	ldd	r18, Z+4	; 0x04
}
   c:	22 30       	cpi	r18, 0x02	; 2
   e:	00 f0       	brcs	.+0      	; 0x10 <_ZN6SdFile7readDirEP14directoryEntry+0x10>
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	eb 01       	movw	r28, r22
  12:	8c 01       	movw	r16, r24
  14:	81 85       	ldd	r24, Z+9	; 0x09
  16:	92 85       	ldd	r25, Z+10	; 0x0a
  18:	a3 85       	ldd	r26, Z+11	; 0x0b
  1a:	b4 85       	ldd	r27, Z+12	; 0x0c
  1c:	8f 71       	andi	r24, 0x1F	; 31
  1e:	99 27       	eor	r25, r25
  20:	aa 27       	eor	r26, r26
  22:	bb 27       	eor	r27, r27
  24:	89 2b       	or	r24, r25
  26:	8a 2b       	or	r24, r26
  28:	8b 2b       	or	r24, r27
  2a:	01 f4       	brne	.+0      	; 0x2c <_ZN6SdFile7readDirEP14directoryEntry+0x2c>
  2c:	40 e2       	ldi	r20, 0x20	; 32
  2e:	50 e0       	ldi	r21, 0x00	; 0
  30:	be 01       	movw	r22, r28
  32:	c8 01       	movw	r24, r16
  34:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile7readDirEP14directoryEntry>
  38:	80 32       	cpi	r24, 0x20	; 32
  3a:	01 f4       	brne	.+0      	; 0x3c <_ZN6SdFile7readDirEP14directoryEntry+0x3c>
  3c:	98 81       	ld	r25, Y
  3e:	99 23       	and	r25, r25
  40:	01 f0       	breq	.+0      	; 0x42 <_ZN6SdFile7readDirEP14directoryEntry+0x42>
  42:	95 3e       	cpi	r25, 0xE5	; 229
  44:	01 f0       	breq	.+0      	; 0x46 <_ZN6SdFile7readDirEP14directoryEntry+0x46>
  46:	9e 32       	cpi	r25, 0x2E	; 46
  48:	01 f0       	breq	.+0      	; 0x4a <_ZN6SdFile7readDirEP14directoryEntry+0x4a>
  4a:	9b 85       	ldd	r25, Y+11	; 0x0b
  4c:	93 fd       	sbrc	r25, 3
  4e:	00 c0       	rjmp	.+0      	; 0x50 <_ZN6SdFile7readDirEP14directoryEntry+0x50>
  50:	df 91       	pop	r29
  52:	cf 91       	pop	r28
  54:	1f 91       	pop	r17
  56:	0f 91       	pop	r16
  58:	08 95       	ret
  5a:	88 0f       	add	r24, r24
  5c:	88 0b       	sbc	r24, r24
  5e:	00 c0       	rjmp	.+0      	; 0x60 <_ZN6SdFile7readDirEP14directoryEntry+0x60>
  60:	8f ef       	ldi	r24, 0xFF	; 255
  62:	00 c0       	rjmp	.+0      	; 0x64 <_ZN6SdFile7readDirEP14directoryEntry+0x64>
  64:	80 e0       	ldi	r24, 0x00	; 0
  66:	00 c0       	rjmp	.+0      	; 0x68 <__SREG__+0x29>

Disassembly of section .text._ZN6SdFile12readDirCacheEv:

00000000 <_ZN6SdFile12readDirCacheEv>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	ff 92       	push	r15
   2:	0f 93       	push	r16
   4:	1f 93       	push	r17
  write_P(str);
   6:	cf 93       	push	r28
   8:	df 93       	push	r29
  println();
   a:	1f 92       	push	r1
}
   c:	cd b7       	in	r28, 0x3d	; 61
   e:	de b7       	in	r29, 0x3e	; 62
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	fc 01       	movw	r30, r24
  12:	24 81       	ldd	r18, Z+4	; 0x04
  14:	22 30       	cpi	r18, 0x02	; 2
  16:	00 f0       	brcs	.+0      	; 0x18 <_ZN6SdFile12readDirCacheEv+0x18>
  18:	8c 01       	movw	r16, r24
  1a:	41 85       	ldd	r20, Z+9	; 0x09
  1c:	52 85       	ldd	r21, Z+10	; 0x0a
  1e:	63 85       	ldd	r22, Z+11	; 0x0b
  20:	74 85       	ldd	r23, Z+12	; 0x0c
  22:	85 e0       	ldi	r24, 0x05	; 5
  24:	76 95       	lsr	r23
  26:	67 95       	ror	r22
  28:	57 95       	ror	r21
  2a:	47 95       	ror	r20
  2c:	8a 95       	dec	r24
  2e:	01 f4       	brne	.+0      	; 0x30 <_ZN6SdFile12readDirCacheEv+0x30>
  30:	f4 2f       	mov	r31, r20
  32:	ff 70       	andi	r31, 0x0F	; 15
  34:	ff 2e       	mov	r15, r31
  36:	41 e0       	ldi	r20, 0x01	; 1
  38:	50 e0       	ldi	r21, 0x00	; 0
  3a:	be 01       	movw	r22, r28
  3c:	6f 5f       	subi	r22, 0xFF	; 255
  3e:	7f 4f       	sbci	r23, 0xFF	; 255
  40:	c8 01       	movw	r24, r16
  42:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile12readDirCacheEv>
  46:	01 97       	sbiw	r24, 0x01	; 1
  48:	01 f0       	breq	.+0      	; 0x4a <_ZN6SdFile12readDirCacheEv+0x4a>
  4a:	90 e0       	ldi	r25, 0x00	; 0
  4c:	80 e0       	ldi	r24, 0x00	; 0
  4e:	00 c0       	rjmp	.+0      	; 0x50 <_ZN6SdFile12readDirCacheEv+0x50>
  50:	f8 01       	movw	r30, r16
  52:	81 85       	ldd	r24, Z+9	; 0x09
  54:	92 85       	ldd	r25, Z+10	; 0x0a
  56:	a3 85       	ldd	r26, Z+11	; 0x0b
  58:	b4 85       	ldd	r27, Z+12	; 0x0c
  5a:	4f 96       	adiw	r24, 0x1f	; 31
  5c:	a1 1d       	adc	r26, r1
  5e:	b1 1d       	adc	r27, r1
  60:	81 87       	std	Z+9, r24	; 0x09
  62:	92 87       	std	Z+10, r25	; 0x0a
  64:	a3 87       	std	Z+11, r26	; 0x0b
  66:	b4 87       	std	Z+12, r27	; 0x0c
  68:	f0 e2       	ldi	r31, 0x20	; 32
  6a:	ff 9e       	mul	r15, r31
  6c:	c0 01       	movw	r24, r0
  6e:	11 24       	eor	r1, r1
  70:	80 50       	subi	r24, 0x00	; 0
  72:	90 40       	sbci	r25, 0x00	; 0
  74:	0f 90       	pop	r0
  76:	df 91       	pop	r29
  78:	cf 91       	pop	r28
  7a:	1f 91       	pop	r17
  7c:	0f 91       	pop	r16
  7e:	ff 90       	pop	r15
  80:	08 95       	ret

Disassembly of section .text._ZN6SdFile7seekSetEm:

00000000 <_ZN6SdFile7seekSetEm>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
  write_P(str);
   6:	bf 92       	push	r11
   8:	cf 92       	push	r12
  println();
   a:	df 92       	push	r13
}
   c:	ef 92       	push	r14
   e:	ff 92       	push	r15
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	0f 93       	push	r16
  12:	1f 93       	push	r17
  14:	cf 93       	push	r28
  16:	df 93       	push	r29
  18:	ec 01       	movw	r28, r24
  1a:	8c 81       	ldd	r24, Y+4	; 0x04
  1c:	81 11       	cpse	r24, r1
  1e:	00 c0       	rjmp	.+0      	; 0x20 <_ZN6SdFile7seekSetEm+0x20>
  20:	80 e0       	ldi	r24, 0x00	; 0
  22:	df 91       	pop	r29
  24:	cf 91       	pop	r28
  26:	1f 91       	pop	r17
  28:	0f 91       	pop	r16
  2a:	ff 90       	pop	r15
  2c:	ef 90       	pop	r14
  2e:	df 90       	pop	r13
  30:	cf 90       	pop	r12
  32:	bf 90       	pop	r11
  34:	af 90       	pop	r10
  36:	9f 90       	pop	r9
  38:	8f 90       	pop	r8
  3a:	08 95       	ret
  3c:	0a 89       	ldd	r16, Y+18	; 0x12
  3e:	1b 89       	ldd	r17, Y+19	; 0x13
  40:	2c 89       	ldd	r18, Y+20	; 0x14
  42:	3d 89       	ldd	r19, Y+21	; 0x15
  44:	04 17       	cp	r16, r20
  46:	15 07       	cpc	r17, r21
  48:	26 07       	cpc	r18, r22
  4a:	37 07       	cpc	r19, r23
  4c:	00 f0       	brcs	.+0      	; 0x4e <_ZN6SdFile7seekSetEm+0x4e>
  4e:	4a 01       	movw	r8, r20
  50:	5b 01       	movw	r10, r22
  52:	82 30       	cpi	r24, 0x02	; 2
  54:	01 f4       	brne	.+0      	; 0x56 <_ZN6SdFile7seekSetEm+0x56>
  56:	89 86       	std	Y+9, r8	; 0x09
  58:	9a 86       	std	Y+10, r9	; 0x0a
  5a:	ab 86       	std	Y+11, r10	; 0x0b
  5c:	bc 86       	std	Y+12, r11	; 0x0c
  5e:	81 e0       	ldi	r24, 0x01	; 1
  60:	00 c0       	rjmp	.+0      	; 0x62 <_ZN6SdFile7seekSetEm+0x62>
  62:	81 14       	cp	r8, r1
  64:	91 04       	cpc	r9, r1
  66:	a1 04       	cpc	r10, r1
  68:	b1 04       	cpc	r11, r1
  6a:	01 f4       	brne	.+0      	; 0x6c <_ZN6SdFile7seekSetEm+0x6c>
  6c:	1d 82       	std	Y+5, r1	; 0x05
  6e:	1e 82       	std	Y+6, r1	; 0x06
  70:	1f 82       	std	Y+7, r1	; 0x07
  72:	18 86       	std	Y+8, r1	; 0x08
  74:	19 86       	std	Y+9, r1	; 0x09
  76:	1a 86       	std	Y+10, r1	; 0x0a
  78:	1b 86       	std	Y+11, r1	; 0x0b
  7a:	1c 86       	std	Y+12, r1	; 0x0c
  7c:	00 c0       	rjmp	.+0      	; 0x7e <_ZN6SdFile7seekSetEm+0x7e>
  7e:	09 85       	ldd	r16, Y+9	; 0x09
  80:	1a 85       	ldd	r17, Y+10	; 0x0a
  82:	2b 85       	ldd	r18, Y+11	; 0x0b
  84:	3c 85       	ldd	r19, Y+12	; 0x0c
  86:	ea 8d       	ldd	r30, Y+26	; 0x1a
  88:	fb 8d       	ldd	r31, Y+27	; 0x1b
  8a:	85 85       	ldd	r24, Z+13	; 0x0d
  8c:	90 e0       	ldi	r25, 0x00	; 0
  8e:	09 96       	adiw	r24, 0x09	; 9
  90:	b9 01       	movw	r22, r18
  92:	a8 01       	movw	r20, r16
  94:	41 50       	subi	r20, 0x01	; 1
  96:	51 09       	sbc	r21, r1
  98:	61 09       	sbc	r22, r1
  9a:	71 09       	sbc	r23, r1
  9c:	08 2e       	mov	r0, r24
  9e:	00 c0       	rjmp	.+0      	; 0xa0 <_ZN6SdFile7seekSetEm+0xa0>
  a0:	76 95       	lsr	r23
  a2:	67 95       	ror	r22
  a4:	57 95       	ror	r21
  a6:	47 95       	ror	r20
  a8:	0a 94       	dec	r0
  aa:	02 f4       	brpl	.+0      	; 0xac <_ZN6SdFile7seekSetEm+0xac>
  ac:	75 01       	movw	r14, r10
  ae:	64 01       	movw	r12, r8
  b0:	e1 e0       	ldi	r30, 0x01	; 1
  b2:	ce 1a       	sub	r12, r30
  b4:	d1 08       	sbc	r13, r1
  b6:	e1 08       	sbc	r14, r1
  b8:	f1 08       	sbc	r15, r1
  ba:	00 c0       	rjmp	.+0      	; 0xbc <_ZN6SdFile7seekSetEm+0xbc>
  bc:	f6 94       	lsr	r15
  be:	e7 94       	ror	r14
  c0:	d7 94       	ror	r13
  c2:	c7 94       	ror	r12
  c4:	8a 95       	dec	r24
  c6:	02 f4       	brpl	.+0      	; 0xc8 <_ZN6SdFile7seekSetEm+0xc8>
  c8:	c4 16       	cp	r12, r20
  ca:	d5 06       	cpc	r13, r21
  cc:	e6 06       	cpc	r14, r22
  ce:	f7 06       	cpc	r15, r23
  d0:	00 f0       	brcs	.+0      	; 0xd2 <_ZN6SdFile7seekSetEm+0xd2>
  d2:	01 2b       	or	r16, r17
  d4:	02 2b       	or	r16, r18
  d6:	03 2b       	or	r16, r19
  d8:	01 f4       	brne	.+0      	; 0xda <_ZN6SdFile7seekSetEm+0xda>
  da:	8e 89       	ldd	r24, Y+22	; 0x16
  dc:	9f 89       	ldd	r25, Y+23	; 0x17
  de:	a8 8d       	ldd	r26, Y+24	; 0x18
  e0:	b9 8d       	ldd	r27, Y+25	; 0x19
  e2:	8d 83       	std	Y+5, r24	; 0x05
  e4:	9e 83       	std	Y+6, r25	; 0x06
  e6:	af 83       	std	Y+7, r26	; 0x07
  e8:	b8 87       	std	Y+8, r27	; 0x08
  ea:	8e 01       	movw	r16, r28
  ec:	0b 5f       	subi	r16, 0xFB	; 251
  ee:	1f 4f       	sbci	r17, 0xFF	; 255
  f0:	c1 14       	cp	r12, r1
  f2:	d1 04       	cpc	r13, r1
  f4:	e1 04       	cpc	r14, r1
  f6:	f1 04       	cpc	r15, r1
  f8:	01 f4       	brne	.+0      	; 0xfa <_ZN6SdFile7seekSetEm+0xfa>
  fa:	00 c0       	rjmp	.+0      	; 0xfc <_ZN6SdFile7seekSetEm+0xfc>
  fc:	4d 81       	ldd	r20, Y+5	; 0x05
  fe:	5e 81       	ldd	r21, Y+6	; 0x06
 100:	6f 81       	ldd	r22, Y+7	; 0x07
 102:	78 85       	ldd	r23, Y+8	; 0x08
 104:	98 01       	movw	r18, r16
 106:	8a 8d       	ldd	r24, Y+26	; 0x1a
 108:	9b 8d       	ldd	r25, Y+27	; 0x1b
 10a:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile7seekSetEm>
 10e:	91 e0       	ldi	r25, 0x01	; 1
 110:	c9 1a       	sub	r12, r25
 112:	d1 08       	sbc	r13, r1
 114:	e1 08       	sbc	r14, r1
 116:	f1 08       	sbc	r15, r1
 118:	81 11       	cpse	r24, r1
 11a:	00 c0       	rjmp	.+0      	; 0x11c <_ZN6SdFile7seekSetEm+0x11c>
 11c:	00 c0       	rjmp	.+0      	; 0x11e <_ZN6SdFile7seekSetEm+0x11e>
 11e:	c4 1a       	sub	r12, r20
 120:	d5 0a       	sbc	r13, r21
 122:	e6 0a       	sbc	r14, r22
 124:	f7 0a       	sbc	r15, r23
 126:	00 c0       	rjmp	.+0      	; 0x128 <__SREG__+0xe9>

Disassembly of section .text._ZN6SdFile4syncEv:

00000000 <_ZN6SdFile4syncEv>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
  write_P(str);
   6:	df 93       	push	r29
   8:	ec 01       	movw	r28, r24
  println();
   a:	8c 81       	ldd	r24, Y+4	; 0x04
}
   c:	88 23       	and	r24, r24
   e:	01 f0       	breq	.+0      	; 0x10 <_ZN6SdFile4syncEv+0x10>
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	8b 81       	ldd	r24, Y+3	; 0x03
  12:	87 ff       	sbrs	r24, 7
  14:	00 c0       	rjmp	.+0      	; 0x16 <_ZN6SdFile4syncEv+0x16>
  16:	61 e0       	ldi	r22, 0x01	; 1
  18:	ce 01       	movw	r24, r28
  1a:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile4syncEv>
  1e:	8c 01       	movw	r16, r24
  20:	89 2b       	or	r24, r25
  22:	01 f0       	breq	.+0      	; 0x24 <_ZN6SdFile4syncEv+0x24>
  24:	8c 81       	ldd	r24, Y+4	; 0x04
  26:	82 30       	cpi	r24, 0x02	; 2
  28:	00 f4       	brcc	.+0      	; 0x2a <_ZN6SdFile4syncEv+0x2a>
  2a:	8a 89       	ldd	r24, Y+18	; 0x12
  2c:	9b 89       	ldd	r25, Y+19	; 0x13
  2e:	ac 89       	ldd	r26, Y+20	; 0x14
  30:	bd 89       	ldd	r27, Y+21	; 0x15
  32:	f8 01       	movw	r30, r16
  34:	84 8f       	std	Z+28, r24	; 0x1c
  36:	95 8f       	std	Z+29, r25	; 0x1d
  38:	a6 8f       	std	Z+30, r26	; 0x1e
  3a:	b7 8f       	std	Z+31, r27	; 0x1f
  3c:	8e 89       	ldd	r24, Y+22	; 0x16
  3e:	9f 89       	ldd	r25, Y+23	; 0x17
  40:	f8 01       	movw	r30, r16
  42:	93 8f       	std	Z+27, r25	; 0x1b
  44:	82 8f       	std	Z+26, r24	; 0x1a
  46:	8e 89       	ldd	r24, Y+22	; 0x16
  48:	9f 89       	ldd	r25, Y+23	; 0x17
  4a:	a8 8d       	ldd	r26, Y+24	; 0x18
  4c:	b9 8d       	ldd	r27, Y+25	; 0x19
  4e:	b5 8b       	std	Z+21, r27	; 0x15
  50:	a4 8b       	std	Z+20, r26	; 0x14
  52:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  56:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  5a:	30 97       	sbiw	r30, 0x00	; 0
  5c:	01 f0       	breq	.+0      	; 0x5e <_ZN6SdFile4syncEv+0x5e>
  5e:	b8 01       	movw	r22, r16
  60:	6a 5e       	subi	r22, 0xEA	; 234
  62:	7f 4f       	sbci	r23, 0xFF	; 255
  64:	c8 01       	movw	r24, r16
  66:	48 96       	adiw	r24, 0x18	; 24
  68:	09 95       	icall
  6a:	f8 01       	movw	r30, r16
  6c:	80 8d       	ldd	r24, Z+24	; 0x18
  6e:	91 8d       	ldd	r25, Z+25	; 0x19
  70:	93 8b       	std	Z+19, r25	; 0x13
  72:	82 8b       	std	Z+18, r24	; 0x12
  74:	8b 81       	ldd	r24, Y+3	; 0x03
  76:	8f 77       	andi	r24, 0x7F	; 127
  78:	8b 83       	std	Y+3, r24	; 0x03
  7a:	df 91       	pop	r29
  7c:	cf 91       	pop	r28
  7e:	1f 91       	pop	r17
  80:	0f 91       	pop	r16
  82:	0c 94 00 00 	jmp	0	; 0x0 <_ZN6SdFile4syncEv>
  86:	80 e0       	ldi	r24, 0x00	; 0
  88:	df 91       	pop	r29
  8a:	cf 91       	pop	r28
  8c:	1f 91       	pop	r17
  8e:	0f 91       	pop	r16
  90:	08 95       	ret

Disassembly of section .text._ZN6SdFile5closeEv:

00000000 <_ZN6SdFile5closeEv>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
  write_P(str);
   6:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile5closeEv>
  println();
   a:	88 23       	and	r24, r24
}
   c:	01 f0       	breq	.+0      	; 0xe <_ZN6SdFile5closeEv+0xe>
   e:	1c 82       	std	Y+4, r1	; 0x04
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	81 e0       	ldi	r24, 0x01	; 1
  12:	df 91       	pop	r29
  14:	cf 91       	pop	r28
  16:	08 95       	ret

Disassembly of section .text._ZN6SdFile8dirEntryEP14directoryEntry:

00000000 <_ZN6SdFile8dirEntryEP14directoryEntry>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
  write_P(str);
   6:	df 93       	push	r29
   8:	ec 01       	movw	r28, r24
  println();
   a:	8b 01       	movw	r16, r22
}
   c:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile8dirEntryEP14directoryEntry>
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	81 11       	cpse	r24, r1
  12:	00 c0       	rjmp	.+0      	; 0x14 <_ZN6SdFile8dirEntryEP14directoryEntry+0x14>
  14:	80 e0       	ldi	r24, 0x00	; 0
  16:	df 91       	pop	r29
  18:	cf 91       	pop	r28
  1a:	1f 91       	pop	r17
  1c:	0f 91       	pop	r16
  1e:	08 95       	ret
  20:	60 e0       	ldi	r22, 0x00	; 0
  22:	ce 01       	movw	r24, r28
  24:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile8dirEntryEP14directoryEntry>
  28:	fc 01       	movw	r30, r24
  2a:	89 2b       	or	r24, r25
  2c:	01 f0       	breq	.+0      	; 0x2e <_ZN6SdFile8dirEntryEP14directoryEntry+0x2e>
  2e:	90 e2       	ldi	r25, 0x20	; 32
  30:	d8 01       	movw	r26, r16
  32:	01 90       	ld	r0, Z+
  34:	0d 92       	st	X+, r0
  36:	9a 95       	dec	r25
  38:	01 f4       	brne	.+0      	; 0x3a <_ZN6SdFile8dirEntryEP14directoryEntry+0x3a>
  3a:	81 e0       	ldi	r24, 0x01	; 1
  3c:	00 c0       	rjmp	.+0      	; 0x3e <__SP_H__>

Disassembly of section .text._ZN6SdFile9timestampEhjhhhhh:

00000000 <_ZN6SdFile9timestampEhjhhhhh>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
  write_P(str);
   6:	cf 92       	push	r12
   8:	df 92       	push	r13
  println();
   a:	ef 92       	push	r14
}
   c:	ff 92       	push	r15
   e:	0f 93       	push	r16
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	1f 93       	push	r17
  12:	cf 93       	push	r28
  14:	df 93       	push	r29
  16:	fc 01       	movw	r30, r24
  18:	34 81       	ldd	r19, Z+4	; 0x04
  1a:	33 23       	and	r19, r19
  1c:	01 f4       	brne	.+0      	; 0x1e <_ZN6SdFile9timestampEhjhhhhh+0x1e>
  1e:	00 c0       	rjmp	.+0      	; 0x20 <_ZN6SdFile9timestampEhjhhhhh+0x20>
  20:	ea 01       	movw	r28, r20
  22:	cc 5b       	subi	r28, 0xBC	; 188
  24:	d7 40       	sbci	r29, 0x07	; 7
  26:	c0 38       	cpi	r28, 0x80	; 128
  28:	d1 05       	cpc	r29, r1
  2a:	00 f0       	brcs	.+0      	; 0x2c <_ZN6SdFile9timestampEhjhhhhh+0x2c>
  2c:	00 c0       	rjmp	.+0      	; 0x2e <_ZN6SdFile9timestampEhjhhhhh+0x2e>
  2e:	3f ef       	ldi	r19, 0xFF	; 255
  30:	32 0f       	add	r19, r18
  32:	3c 30       	cpi	r19, 0x0C	; 12
  34:	00 f0       	brcs	.+0      	; 0x36 <_ZN6SdFile9timestampEhjhhhhh+0x36>
  36:	00 c0       	rjmp	.+0      	; 0x38 <_ZN6SdFile9timestampEhjhhhhh+0x38>
  38:	3f ef       	ldi	r19, 0xFF	; 255
  3a:	30 0f       	add	r19, r16
  3c:	3f 31       	cpi	r19, 0x1F	; 31
  3e:	00 f0       	brcs	.+0      	; 0x40 <_ZN6SdFile9timestampEhjhhhhh+0x40>
  40:	00 c0       	rjmp	.+0      	; 0x42 <_ZN6SdFile9timestampEhjhhhhh+0x42>
  42:	f7 e1       	ldi	r31, 0x17	; 23
  44:	fe 15       	cp	r31, r14
  46:	00 f4       	brcc	.+0      	; 0x48 <_ZN6SdFile9timestampEhjhhhhh+0x48>
  48:	00 c0       	rjmp	.+0      	; 0x4a <_ZN6SdFile9timestampEhjhhhhh+0x4a>
  4a:	3b e3       	ldi	r19, 0x3B	; 59
  4c:	3c 15       	cp	r19, r12
  4e:	00 f4       	brcc	.+0      	; 0x50 <_ZN6SdFile9timestampEhjhhhhh+0x50>
  50:	00 c0       	rjmp	.+0      	; 0x52 <_ZN6SdFile9timestampEhjhhhhh+0x52>
  52:	3a 15       	cp	r19, r10
  54:	00 f4       	brcc	.+0      	; 0x56 <_ZN6SdFile9timestampEhjhhhhh+0x56>
  56:	00 c0       	rjmp	.+0      	; 0x58 <_ZN6SdFile9timestampEhjhhhhh+0x58>
  58:	f2 2e       	mov	r15, r18
  5a:	16 2f       	mov	r17, r22
  5c:	4c 01       	movw	r8, r24
  5e:	61 e0       	ldi	r22, 0x01	; 1
  60:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile9timestampEhjhhhhh>
  64:	fc 01       	movw	r30, r24
  66:	89 2b       	or	r24, r25
  68:	01 f4       	brne	.+0      	; 0x6a <_ZN6SdFile9timestampEhjhhhhh+0x6a>
  6a:	00 c0       	rjmp	.+0      	; 0x6c <_ZN6SdFile9timestampEhjhhhhh+0x6c>
  6c:	9e 01       	movw	r18, r28
  6e:	32 2f       	mov	r19, r18
  70:	22 27       	eor	r18, r18
  72:	33 0f       	add	r19, r19
  74:	80 e2       	ldi	r24, 0x20	; 32
  76:	f8 9e       	mul	r15, r24
  78:	e0 01       	movw	r28, r0
  7a:	11 24       	eor	r1, r1
  7c:	2c 2b       	or	r18, r28
  7e:	3d 2b       	or	r19, r29
  80:	20 2b       	or	r18, r16
  82:	80 e2       	ldi	r24, 0x20	; 32
  84:	c8 9e       	mul	r12, r24
  86:	a0 01       	movw	r20, r0
  88:	11 24       	eor	r1, r1
  8a:	ca 2c       	mov	r12, r10
  8c:	d1 2c       	mov	r13, r1
  8e:	d5 94       	asr	r13
  90:	c7 94       	ror	r12
  92:	4c 29       	or	r20, r12
  94:	5d 29       	or	r21, r13
  96:	f1 2c       	mov	r15, r1
  98:	fe 2c       	mov	r15, r14
  9a:	ee 24       	eor	r14, r14
  9c:	ff 0c       	add	r15, r15
  9e:	ff 0c       	add	r15, r15
  a0:	ff 0c       	add	r15, r15
  a2:	4e 29       	or	r20, r14
  a4:	5f 29       	or	r21, r15
  a6:	10 ff       	sbrs	r17, 0
  a8:	00 c0       	rjmp	.+0      	; 0xaa <_ZN6SdFile9timestampEhjhhhhh+0xaa>
  aa:	33 8b       	std	Z+19, r19	; 0x13
  ac:	22 8b       	std	Z+18, r18	; 0x12
  ae:	11 ff       	sbrs	r17, 1
  b0:	00 c0       	rjmp	.+0      	; 0xb2 <_ZN6SdFile9timestampEhjhhhhh+0xb2>
  b2:	31 8b       	std	Z+17, r19	; 0x11
  b4:	20 8b       	std	Z+16, r18	; 0x10
  b6:	57 87       	std	Z+15, r21	; 0x0f
  b8:	46 87       	std	Z+14, r20	; 0x0e
  ba:	84 e6       	ldi	r24, 0x64	; 100
  bc:	a0 fe       	sbrs	r10, 0
  be:	80 e0       	ldi	r24, 0x00	; 0
  c0:	85 87       	std	Z+13, r24	; 0x0d
  c2:	12 ff       	sbrs	r17, 2
  c4:	00 c0       	rjmp	.+0      	; 0xc6 <_ZN6SdFile9timestampEhjhhhhh+0xc6>
  c6:	31 8f       	std	Z+25, r19	; 0x19
  c8:	20 8f       	std	Z+24, r18	; 0x18
  ca:	57 8b       	std	Z+23, r21	; 0x17
  cc:	46 8b       	std	Z+22, r20	; 0x16
  ce:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  d2:	81 60       	ori	r24, 0x01	; 1
  d4:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  d8:	c4 01       	movw	r24, r8
  da:	df 91       	pop	r29
  dc:	cf 91       	pop	r28
  de:	1f 91       	pop	r17
  e0:	0f 91       	pop	r16
  e2:	ff 90       	pop	r15
  e4:	ef 90       	pop	r14
  e6:	df 90       	pop	r13
  e8:	cf 90       	pop	r12
  ea:	af 90       	pop	r10
  ec:	9f 90       	pop	r9
  ee:	8f 90       	pop	r8
  f0:	0c 94 00 00 	jmp	0	; 0x0 <_ZN6SdFile9timestampEhjhhhhh>
  f4:	80 e0       	ldi	r24, 0x00	; 0
  f6:	df 91       	pop	r29
  f8:	cf 91       	pop	r28
  fa:	1f 91       	pop	r17
  fc:	0f 91       	pop	r16
  fe:	ff 90       	pop	r15
 100:	ef 90       	pop	r14
 102:	df 90       	pop	r13
 104:	cf 90       	pop	r12
 106:	af 90       	pop	r10
 108:	9f 90       	pop	r9
 10a:	8f 90       	pop	r8
 10c:	08 95       	ret

Disassembly of section .text._ZN6SdFile8truncateEm:

00000000 <_ZN6SdFile8truncateEm>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	4f 92       	push	r4
   2:	5f 92       	push	r5
   4:	6f 92       	push	r6
  write_P(str);
   6:	7f 92       	push	r7
   8:	8f 92       	push	r8
  println();
   a:	9f 92       	push	r9
}
   c:	af 92       	push	r10
   e:	bf 92       	push	r11
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	ef 92       	push	r14
  12:	ff 92       	push	r15
  14:	0f 93       	push	r16
  16:	1f 93       	push	r17
  18:	cf 93       	push	r28
  1a:	df 93       	push	r29
  1c:	00 d0       	rcall	.+0      	; 0x1e <_ZN6SdFile8truncateEm+0x1e>
  1e:	00 d0       	rcall	.+0      	; 0x20 <_ZN6SdFile8truncateEm+0x20>
  20:	cd b7       	in	r28, 0x3d	; 61
  22:	de b7       	in	r29, 0x3e	; 62
  24:	fc 01       	movw	r30, r24
  26:	84 81       	ldd	r24, Z+4	; 0x04
  28:	81 30       	cpi	r24, 0x01	; 1
  2a:	01 f0       	breq	.+0      	; 0x2c <_ZN6SdFile8truncateEm+0x2c>
  2c:	80 e0       	ldi	r24, 0x00	; 0
  2e:	0f 90       	pop	r0
  30:	0f 90       	pop	r0
  32:	0f 90       	pop	r0
  34:	0f 90       	pop	r0
  36:	df 91       	pop	r29
  38:	cf 91       	pop	r28
  3a:	1f 91       	pop	r17
  3c:	0f 91       	pop	r16
  3e:	ff 90       	pop	r15
  40:	ef 90       	pop	r14
  42:	bf 90       	pop	r11
  44:	af 90       	pop	r10
  46:	9f 90       	pop	r9
  48:	8f 90       	pop	r8
  4a:	7f 90       	pop	r7
  4c:	6f 90       	pop	r6
  4e:	5f 90       	pop	r5
  50:	4f 90       	pop	r4
  52:	08 95       	ret
  54:	83 81       	ldd	r24, Z+3	; 0x03
  56:	81 ff       	sbrs	r24, 1
  58:	00 c0       	rjmp	.+0      	; 0x5a <_ZN6SdFile8truncateEm+0x5a>
  5a:	82 89       	ldd	r24, Z+18	; 0x12
  5c:	93 89       	ldd	r25, Z+19	; 0x13
  5e:	a4 89       	ldd	r26, Z+20	; 0x14
  60:	b5 89       	ldd	r27, Z+21	; 0x15
  62:	84 17       	cp	r24, r20
  64:	95 07       	cpc	r25, r21
  66:	a6 07       	cpc	r26, r22
  68:	b7 07       	cpc	r27, r23
  6a:	00 f0       	brcs	.+0      	; 0x6c <_ZN6SdFile8truncateEm+0x6c>
  6c:	89 2b       	or	r24, r25
  6e:	8a 2b       	or	r24, r26
  70:	8b 2b       	or	r24, r27
  72:	01 f4       	brne	.+0      	; 0x74 <_ZN6SdFile8truncateEm+0x74>
  74:	00 c0       	rjmp	.+0      	; 0x76 <_ZN6SdFile8truncateEm+0x76>
  76:	4a 01       	movw	r8, r20
  78:	5b 01       	movw	r10, r22
  7a:	7f 01       	movw	r14, r30
  7c:	41 84       	ldd	r4, Z+9	; 0x09
  7e:	52 84       	ldd	r5, Z+10	; 0x0a
  80:	63 84       	ldd	r6, Z+11	; 0x0b
  82:	74 84       	ldd	r7, Z+12	; 0x0c
  84:	cf 01       	movw	r24, r30
  86:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile8truncateEm>
  8a:	88 23       	and	r24, r24
  8c:	01 f0       	breq	.+0      	; 0x8e <_ZN6SdFile8truncateEm+0x8e>
  8e:	f7 01       	movw	r30, r14
  90:	82 8d       	ldd	r24, Z+26	; 0x1a
  92:	93 8d       	ldd	r25, Z+27	; 0x1b
  94:	81 14       	cp	r8, r1
  96:	91 04       	cpc	r9, r1
  98:	a1 04       	cpc	r10, r1
  9a:	b1 04       	cpc	r11, r1
  9c:	01 f4       	brne	.+0      	; 0x9e <_ZN6SdFile8truncateEm+0x9e>
  9e:	46 89       	ldd	r20, Z+22	; 0x16
  a0:	57 89       	ldd	r21, Z+23	; 0x17
  a2:	60 8d       	ldd	r22, Z+24	; 0x18
  a4:	71 8d       	ldd	r23, Z+25	; 0x19
  a6:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile8truncateEm>
  aa:	88 23       	and	r24, r24
  ac:	01 f4       	brne	.+0      	; 0xae <_ZN6SdFile8truncateEm+0xae>
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <_ZN6SdFile8truncateEm+0xb0>
  b0:	f7 01       	movw	r30, r14
  b2:	16 8a       	std	Z+22, r1	; 0x16
  b4:	17 8a       	std	Z+23, r1	; 0x17
  b6:	10 8e       	std	Z+24, r1	; 0x18
  b8:	11 8e       	std	Z+25, r1	; 0x19
  ba:	f7 01       	movw	r30, r14
  bc:	82 8a       	std	Z+18, r8	; 0x12
  be:	93 8a       	std	Z+19, r9	; 0x13
  c0:	a4 8a       	std	Z+20, r10	; 0x14
  c2:	b5 8a       	std	Z+21, r11	; 0x15
  c4:	83 81       	ldd	r24, Z+3	; 0x03
  c6:	80 68       	ori	r24, 0x80	; 128
  c8:	83 83       	std	Z+3, r24	; 0x03
  ca:	c7 01       	movw	r24, r14
  cc:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile8truncateEm>
  d0:	88 23       	and	r24, r24
  d2:	01 f4       	brne	.+0      	; 0xd4 <_ZN6SdFile8truncateEm+0xd4>
  d4:	00 c0       	rjmp	.+0      	; 0xd6 <_ZN6SdFile8truncateEm+0xd6>
  d6:	b5 01       	movw	r22, r10
  d8:	a4 01       	movw	r20, r8
  da:	44 16       	cp	r4, r20
  dc:	55 06       	cpc	r5, r21
  de:	66 06       	cpc	r6, r22
  e0:	77 06       	cpc	r7, r23
  e2:	00 f4       	brcc	.+0      	; 0xe4 <_ZN6SdFile8truncateEm+0xe4>
  e4:	b3 01       	movw	r22, r6
  e6:	a2 01       	movw	r20, r4
  e8:	c7 01       	movw	r24, r14
  ea:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile8truncateEm>
  ee:	00 c0       	rjmp	.+0      	; 0xf0 <_ZN6SdFile8truncateEm+0xf0>
  f0:	45 81       	ldd	r20, Z+5	; 0x05
  f2:	56 81       	ldd	r21, Z+6	; 0x06
  f4:	67 81       	ldd	r22, Z+7	; 0x07
  f6:	70 85       	ldd	r23, Z+8	; 0x08
  f8:	9e 01       	movw	r18, r28
  fa:	2f 5f       	subi	r18, 0xFF	; 255
  fc:	3f 4f       	sbci	r19, 0xFF	; 255
  fe:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile8truncateEm>
 102:	88 23       	and	r24, r24
 104:	01 f4       	brne	.+0      	; 0x106 <_ZN6SdFile8truncateEm+0x106>
 106:	00 c0       	rjmp	.+0      	; 0x108 <_ZN6SdFile8truncateEm+0x108>
 108:	f7 01       	movw	r30, r14
 10a:	82 8d       	ldd	r24, Z+26	; 0x1a
 10c:	93 8d       	ldd	r25, Z+27	; 0x1b
 10e:	49 81       	ldd	r20, Y+1	; 0x01
 110:	5a 81       	ldd	r21, Y+2	; 0x02
 112:	6b 81       	ldd	r22, Y+3	; 0x03
 114:	7c 81       	ldd	r23, Y+4	; 0x04
 116:	fc 01       	movw	r30, r24
 118:	27 89       	ldd	r18, Z+23	; 0x17
 11a:	20 31       	cpi	r18, 0x10	; 16
 11c:	01 f4       	brne	.+0      	; 0x11e <_ZN6SdFile8truncateEm+0x11e>
 11e:	08 ef       	ldi	r16, 0xF8	; 248
 120:	1f ef       	ldi	r17, 0xFF	; 255
 122:	20 e0       	ldi	r18, 0x00	; 0
 124:	30 e0       	ldi	r19, 0x00	; 0
 126:	40 17       	cp	r20, r16
 128:	51 07       	cpc	r21, r17
 12a:	62 07       	cpc	r22, r18
 12c:	73 07       	cpc	r23, r19
 12e:	00 f4       	brcc	.+0      	; 0x130 <_ZN6SdFile8truncateEm+0x130>
 130:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile8truncateEm>
 134:	88 23       	and	r24, r24
 136:	01 f4       	brne	.+0      	; 0x138 <_ZN6SdFile8truncateEm+0x138>
 138:	00 c0       	rjmp	.+0      	; 0x13a <_ZN6SdFile8truncateEm+0x13a>
 13a:	f7 01       	movw	r30, r14
 13c:	45 81       	ldd	r20, Z+5	; 0x05
 13e:	56 81       	ldd	r21, Z+6	; 0x06
 140:	67 81       	ldd	r22, Z+7	; 0x07
 142:	70 85       	ldd	r23, Z+8	; 0x08
 144:	0f ef       	ldi	r16, 0xFF	; 255
 146:	1f ef       	ldi	r17, 0xFF	; 255
 148:	2f ef       	ldi	r18, 0xFF	; 255
 14a:	3f e0       	ldi	r19, 0x0F	; 15
 14c:	82 8d       	ldd	r24, Z+26	; 0x1a
 14e:	93 8d       	ldd	r25, Z+27	; 0x1b
 150:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile8truncateEm>
 154:	81 11       	cpse	r24, r1
 156:	00 c0       	rjmp	.+0      	; 0x158 <_ZN6SdFile8truncateEm+0x158>
 158:	00 c0       	rjmp	.+0      	; 0x15a <_ZN6SdFile8truncateEm+0x15a>
 15a:	08 ef       	ldi	r16, 0xF8	; 248
 15c:	1f ef       	ldi	r17, 0xFF	; 255
 15e:	2f ef       	ldi	r18, 0xFF	; 255
 160:	3f e0       	ldi	r19, 0x0F	; 15
 162:	00 c0       	rjmp	.+0      	; 0x164 <_ZN6SdFile8truncateEm+0x164>
 164:	81 e0       	ldi	r24, 0x01	; 1
 166:	00 c0       	rjmp	.+0      	; 0x168 <__SREG__+0x129>

Disassembly of section .text._ZN6SdFile15openCachedEntryEhh:

00000000 <_ZN6SdFile15openCachedEntryEhh>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
  write_P(str);
   6:	ff 92       	push	r15
   8:	1f 93       	push	r17
  println();
   a:	cf 93       	push	r28
}
   c:	df 93       	push	r29
   e:	ec 01       	movw	r28, r24
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	80 e2       	ldi	r24, 0x20	; 32
  12:	68 9f       	mul	r22, r24
  14:	f0 01       	movw	r30, r0
  16:	11 24       	eor	r1, r1
  18:	e0 50       	subi	r30, 0x00	; 0
  1a:	f0 40       	sbci	r31, 0x00	; 0
  1c:	93 85       	ldd	r25, Z+11	; 0x0b
  1e:	91 71       	andi	r25, 0x11	; 17
  20:	01 f0       	breq	.+0      	; 0x22 <_ZN6SdFile15openCachedEntryEhh+0x22>
  22:	84 2f       	mov	r24, r20
  24:	82 74       	andi	r24, 0x42	; 66
  26:	01 f0       	breq	.+0      	; 0x28 <_ZN6SdFile15openCachedEntryEhh+0x28>
  28:	80 e0       	ldi	r24, 0x00	; 0
  2a:	df 91       	pop	r29
  2c:	cf 91       	pop	r28
  2e:	1f 91       	pop	r17
  30:	ff 90       	pop	r15
  32:	ef 90       	pop	r14
  34:	df 90       	pop	r13
  36:	cf 90       	pop	r12
  38:	08 95       	ret
  3a:	14 2f       	mov	r17, r20
  3c:	69 8b       	std	Y+17, r22	; 0x11
  3e:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  42:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  46:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  4a:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  4e:	8d 87       	std	Y+13, r24	; 0x0d
  50:	9e 87       	std	Y+14, r25	; 0x0e
  52:	af 87       	std	Y+15, r26	; 0x0f
  54:	b8 8b       	std	Y+16, r27	; 0x10
  56:	c4 88       	ldd	r12, Z+20	; 0x14
  58:	d5 88       	ldd	r13, Z+21	; 0x15
  5a:	f1 2c       	mov	r15, r1
  5c:	e1 2c       	mov	r14, r1
  5e:	76 01       	movw	r14, r12
  60:	dd 24       	eor	r13, r13
  62:	cc 24       	eor	r12, r12
  64:	ce 8a       	std	Y+22, r12	; 0x16
  66:	df 8a       	std	Y+23, r13	; 0x17
  68:	e8 8e       	std	Y+24, r14	; 0x18
  6a:	f9 8e       	std	Y+25, r15	; 0x19
  6c:	82 8d       	ldd	r24, Z+26	; 0x1a
  6e:	93 8d       	ldd	r25, Z+27	; 0x1b
  70:	b0 e0       	ldi	r27, 0x00	; 0
  72:	a0 e0       	ldi	r26, 0x00	; 0
  74:	ac 01       	movw	r20, r24
  76:	bd 01       	movw	r22, r26
  78:	4c 29       	or	r20, r12
  7a:	5d 29       	or	r21, r13
  7c:	6e 29       	or	r22, r14
  7e:	7f 29       	or	r23, r15
  80:	4e 8b       	std	Y+22, r20	; 0x16
  82:	5f 8b       	std	Y+23, r21	; 0x17
  84:	68 8f       	std	Y+24, r22	; 0x18
  86:	79 8f       	std	Y+25, r23	; 0x19
  88:	83 85       	ldd	r24, Z+11	; 0x0b
  8a:	88 71       	andi	r24, 0x18	; 24
  8c:	01 f4       	brne	.+0      	; 0x8e <_ZN6SdFile15openCachedEntryEhh+0x8e>
  8e:	84 8d       	ldd	r24, Z+28	; 0x1c
  90:	95 8d       	ldd	r25, Z+29	; 0x1d
  92:	a6 8d       	ldd	r26, Z+30	; 0x1e
  94:	b7 8d       	ldd	r27, Z+31	; 0x1f
  96:	8a 8b       	std	Y+18, r24	; 0x12
  98:	9b 8b       	std	Y+19, r25	; 0x13
  9a:	ac 8b       	std	Y+20, r26	; 0x14
  9c:	bd 8b       	std	Y+21, r27	; 0x15
  9e:	81 e0       	ldi	r24, 0x01	; 1
  a0:	8c 83       	std	Y+4, r24	; 0x04
  a2:	81 2f       	mov	r24, r17
  a4:	8f 70       	andi	r24, 0x0F	; 15
  a6:	8b 83       	std	Y+3, r24	; 0x03
  a8:	1d 82       	std	Y+5, r1	; 0x05
  aa:	1e 82       	std	Y+6, r1	; 0x06
  ac:	1f 82       	std	Y+7, r1	; 0x07
  ae:	18 86       	std	Y+8, r1	; 0x08
  b0:	19 86       	std	Y+9, r1	; 0x09
  b2:	1a 86       	std	Y+10, r1	; 0x0a
  b4:	1b 86       	std	Y+11, r1	; 0x0b
  b6:	1c 86       	std	Y+12, r1	; 0x0c
  b8:	81 e0       	ldi	r24, 0x01	; 1
  ba:	16 ff       	sbrs	r17, 6
  bc:	00 c0       	rjmp	.+0      	; 0xbe <_ZN6SdFile15openCachedEntryEhh+0xbe>
  be:	40 e0       	ldi	r20, 0x00	; 0
  c0:	50 e0       	ldi	r21, 0x00	; 0
  c2:	ba 01       	movw	r22, r20
  c4:	ce 01       	movw	r24, r28
  c6:	df 91       	pop	r29
  c8:	cf 91       	pop	r28
  ca:	1f 91       	pop	r17
  cc:	ff 90       	pop	r15
  ce:	ef 90       	pop	r14
  d0:	df 90       	pop	r13
  d2:	cf 90       	pop	r12
  d4:	0c 94 00 00 	jmp	0	; 0x0 <_ZN6SdFile15openCachedEntryEhh>
  d8:	80 31       	cpi	r24, 0x10	; 16
  da:	01 f0       	breq	.+0      	; 0xdc <_ZN6SdFile15openCachedEntryEhh+0xdc>
  dc:	00 c0       	rjmp	.+0      	; 0xde <_ZN6SdFile15openCachedEntryEhh+0xde>
  de:	9e 01       	movw	r18, r28
  e0:	2e 5e       	subi	r18, 0xEE	; 238
  e2:	3f 4f       	sbci	r19, 0xFF	; 255
  e4:	8a 8d       	ldd	r24, Y+26	; 0x1a
  e6:	9b 8d       	ldd	r25, Y+27	; 0x1b
  e8:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile15openCachedEntryEhh>
  ec:	88 23       	and	r24, r24
  ee:	01 f4       	brne	.+0      	; 0xf0 <_ZN6SdFile15openCachedEntryEhh+0xf0>
  f0:	00 c0       	rjmp	.+0      	; 0xf2 <_ZN6SdFile15openCachedEntryEhh+0xf2>
  f2:	84 e0       	ldi	r24, 0x04	; 4
  f4:	00 c0       	rjmp	.+0      	; 0xf6 <__SREG__+0xb7>

Disassembly of section .text._ZN6SdFile4openEPS_PKch:

00000000 <_ZN6SdFile4openEPS_PKch>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	bf 92       	push	r11
   2:	cf 92       	push	r12
   4:	df 92       	push	r13
  write_P(str);
   6:	ef 92       	push	r14
   8:	ff 92       	push	r15
  println();
   a:	0f 93       	push	r16
}
   c:	1f 93       	push	r17
   e:	cf 93       	push	r28
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	df 93       	push	r29
  12:	cd b7       	in	r28, 0x3d	; 61
  14:	de b7       	in	r29, 0x3e	; 62
  16:	2b 97       	sbiw	r28, 0x0b	; 11
  18:	0f b6       	in	r0, 0x3f	; 63
  1a:	f8 94       	cli
  1c:	de bf       	out	0x3e, r29	; 62
  1e:	0f be       	out	0x3f, r0	; 63
  20:	cd bf       	out	0x3d, r28	; 61
  22:	fc 01       	movw	r30, r24
  24:	34 81       	ldd	r19, Z+4	; 0x04
  26:	31 11       	cpse	r19, r1
  28:	00 c0       	rjmp	.+0      	; 0x2a <_ZN6SdFile4openEPS_PKch+0x2a>
  2a:	c2 2e       	mov	r12, r18
  2c:	8b 01       	movw	r16, r22
  2e:	7c 01       	movw	r14, r24
  30:	be 01       	movw	r22, r28
  32:	6f 5f       	subi	r22, 0xFF	; 255
  34:	7f 4f       	sbci	r23, 0xFF	; 255
  36:	ca 01       	movw	r24, r20
  38:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile4openEPS_PKch>
  3c:	81 11       	cpse	r24, r1
  3e:	00 c0       	rjmp	.+0      	; 0x40 <_ZN6SdFile4openEPS_PKch+0x40>
  40:	80 e0       	ldi	r24, 0x00	; 0
  42:	00 c0       	rjmp	.+0      	; 0x44 <_ZN6SdFile4openEPS_PKch+0x44>
  44:	f8 01       	movw	r30, r16
  46:	82 8d       	ldd	r24, Z+26	; 0x1a
  48:	93 8d       	ldd	r25, Z+27	; 0x1b
  4a:	f7 01       	movw	r30, r14
  4c:	93 8f       	std	Z+27, r25	; 0x1b
  4e:	82 8f       	std	Z+26, r24	; 0x1a
  50:	f8 01       	movw	r30, r16
  52:	15 82       	std	Z+5, r1	; 0x05
  54:	16 82       	std	Z+6, r1	; 0x06
  56:	17 82       	std	Z+7, r1	; 0x07
  58:	10 86       	std	Z+8, r1	; 0x08
  5a:	11 86       	std	Z+9, r1	; 0x09
  5c:	12 86       	std	Z+10, r1	; 0x0a
  5e:	13 86       	std	Z+11, r1	; 0x0b
  60:	14 86       	std	Z+12, r1	; 0x0c
  62:	b1 2c       	mov	r11, r1
  64:	f8 01       	movw	r30, r16
  66:	81 85       	ldd	r24, Z+9	; 0x09
  68:	92 85       	ldd	r25, Z+10	; 0x0a
  6a:	a3 85       	ldd	r26, Z+11	; 0x0b
  6c:	b4 85       	ldd	r27, Z+12	; 0x0c
  6e:	42 89       	ldd	r20, Z+18	; 0x12
  70:	53 89       	ldd	r21, Z+19	; 0x13
  72:	64 89       	ldd	r22, Z+20	; 0x14
  74:	75 89       	ldd	r23, Z+21	; 0x15
  76:	84 17       	cp	r24, r20
  78:	95 07       	cpc	r25, r21
  7a:	a6 07       	cpc	r26, r22
  7c:	b7 07       	cpc	r27, r23
  7e:	00 f4       	brcc	.+0      	; 0x80 <_ZN6SdFile4openEPS_PKch+0x80>
  80:	25 e0       	ldi	r18, 0x05	; 5
  82:	b6 95       	lsr	r27
  84:	a7 95       	ror	r26
  86:	97 95       	ror	r25
  88:	87 95       	ror	r24
  8a:	2a 95       	dec	r18
  8c:	01 f4       	brne	.+0      	; 0x8e <_ZN6SdFile4openEPS_PKch+0x8e>
  8e:	f8 2f       	mov	r31, r24
  90:	ff 70       	andi	r31, 0x0F	; 15
  92:	df 2e       	mov	r13, r31
  94:	c8 01       	movw	r24, r16
  96:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile4openEPS_PKch>
  9a:	00 97       	sbiw	r24, 0x00	; 0
  9c:	01 f0       	breq	.+0      	; 0x9e <_ZN6SdFile4openEPS_PKch+0x9e>
  9e:	fc 01       	movw	r30, r24
  a0:	20 81       	ld	r18, Z
  a2:	22 23       	and	r18, r18
  a4:	01 f0       	breq	.+0      	; 0xa6 <_ZN6SdFile4openEPS_PKch+0xa6>
  a6:	25 3e       	cpi	r18, 0xE5	; 229
  a8:	01 f0       	breq	.+0      	; 0xaa <_ZN6SdFile4openEPS_PKch+0xaa>
  aa:	00 c0       	rjmp	.+0      	; 0xac <_ZN6SdFile4openEPS_PKch+0xac>
  ac:	bb 20       	and	r11, r11
  ae:	01 f0       	breq	.+0      	; 0xb0 <_ZN6SdFile4openEPS_PKch+0xb0>
  b0:	bb 24       	eor	r11, r11
  b2:	b3 94       	inc	r11
  b4:	00 c0       	rjmp	.+0      	; 0xb6 <_ZN6SdFile4openEPS_PKch+0xb6>
  b6:	b1 10       	cpse	r11, r1
  b8:	00 c0       	rjmp	.+0      	; 0xba <_ZN6SdFile4openEPS_PKch+0xba>
  ba:	f7 01       	movw	r30, r14
  bc:	d1 8a       	std	Z+17, r13	; 0x11
  be:	40 91 00 00 	lds	r20, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  c2:	50 91 00 00 	lds	r21, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  c6:	60 91 00 00 	lds	r22, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  ca:	70 91 00 00 	lds	r23, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  ce:	45 87       	std	Z+13, r20	; 0x0d
  d0:	56 87       	std	Z+14, r21	; 0x0e
  d2:	67 87       	std	Z+15, r22	; 0x0f
  d4:	70 8b       	std	Z+16, r23	; 0x10
  d6:	fc 01       	movw	r30, r24
  d8:	80 81       	ld	r24, Z
  da:	81 11       	cpse	r24, r1
  dc:	00 c0       	rjmp	.+0      	; 0xde <_ZN6SdFile4openEPS_PKch+0xde>
  de:	bb 24       	eor	r11, r11
  e0:	b3 94       	inc	r11
  e2:	8c 2d       	mov	r24, r12
  e4:	82 71       	andi	r24, 0x12	; 18
  e6:	82 31       	cpi	r24, 0x12	; 18
  e8:	01 f0       	breq	.+0      	; 0xea <_ZN6SdFile4openEPS_PKch+0xea>
  ea:	00 c0       	rjmp	.+0      	; 0xec <_ZN6SdFile4openEPS_PKch+0xec>
  ec:	bb 20       	and	r11, r11
  ee:	01 f4       	brne	.+0      	; 0xf0 <_ZN6SdFile4openEPS_PKch+0xf0>
  f0:	00 c0       	rjmp	.+0      	; 0xf2 <_ZN6SdFile4openEPS_PKch+0xf2>
  f2:	61 e0       	ldi	r22, 0x01	; 1
  f4:	c7 01       	movw	r24, r14
  f6:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile4openEPS_PKch>
  fa:	8c 01       	movw	r16, r24
  fc:	89 2b       	or	r24, r25
  fe:	01 f4       	brne	.+0      	; 0x100 <_ZN6SdFile4openEPS_PKch+0x100>
 100:	00 c0       	rjmp	.+0      	; 0x102 <_ZN6SdFile4openEPS_PKch+0x102>
 102:	80 e2       	ldi	r24, 0x20	; 32
 104:	f8 01       	movw	r30, r16
 106:	11 92       	st	Z+, r1
 108:	8a 95       	dec	r24
 10a:	01 f4       	brne	.+0      	; 0x10c <_ZN6SdFile4openEPS_PKch+0x10c>
 10c:	8b e0       	ldi	r24, 0x0B	; 11
 10e:	fe 01       	movw	r30, r28
 110:	31 96       	adiw	r30, 0x01	; 1
 112:	d8 01       	movw	r26, r16
 114:	01 90       	ld	r0, Z+
 116:	0d 92       	st	X+, r0
 118:	8a 95       	dec	r24
 11a:	01 f4       	brne	.+0      	; 0x11c <_ZN6SdFile4openEPS_PKch+0x11c>
 11c:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 120:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 124:	30 97       	sbiw	r30, 0x00	; 0
 126:	01 f4       	brne	.+0      	; 0x128 <_ZN6SdFile4openEPS_PKch+0x128>
 128:	00 c0       	rjmp	.+0      	; 0x12a <_ZN6SdFile4openEPS_PKch+0x12a>
 12a:	b8 01       	movw	r22, r16
 12c:	62 5f       	subi	r22, 0xF2	; 242
 12e:	7f 4f       	sbci	r23, 0xFF	; 255
 130:	c8 01       	movw	r24, r16
 132:	40 96       	adiw	r24, 0x10	; 16
 134:	09 95       	icall
 136:	f8 01       	movw	r30, r16
 138:	80 89       	ldd	r24, Z+16	; 0x10
 13a:	91 89       	ldd	r25, Z+17	; 0x11
 13c:	93 8b       	std	Z+19, r25	; 0x13
 13e:	82 8b       	std	Z+18, r24	; 0x12
 140:	91 8f       	std	Z+25, r25	; 0x19
 142:	80 8f       	std	Z+24, r24	; 0x18
 144:	86 85       	ldd	r24, Z+14	; 0x0e
 146:	97 85       	ldd	r25, Z+15	; 0x0f
 148:	97 8b       	std	Z+23, r25	; 0x17
 14a:	86 8b       	std	Z+22, r24	; 0x16
 14c:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile4openEPS_PKch>
 150:	88 23       	and	r24, r24
 152:	01 f4       	brne	.+0      	; 0x154 <_ZN6SdFile4openEPS_PKch+0x154>
 154:	00 c0       	rjmp	.+0      	; 0x156 <_ZN6SdFile4openEPS_PKch+0x156>
 156:	4c 2d       	mov	r20, r12
 158:	f7 01       	movw	r30, r14
 15a:	61 89       	ldd	r22, Z+17	; 0x11
 15c:	00 c0       	rjmp	.+0      	; 0x15e <_ZN6SdFile4openEPS_PKch+0x15e>
 15e:	4b e0       	ldi	r20, 0x0B	; 11
 160:	50 e0       	ldi	r21, 0x00	; 0
 162:	bc 01       	movw	r22, r24
 164:	ce 01       	movw	r24, r28
 166:	01 96       	adiw	r24, 0x01	; 1
 168:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile4openEPS_PKch>
 16c:	89 2b       	or	r24, r25
 16e:	01 f0       	breq	.+0      	; 0x170 <_ZN6SdFile4openEPS_PKch+0x170>
 170:	00 c0       	rjmp	.+0      	; 0x172 <_ZN6SdFile4openEPS_PKch+0x172>
 172:	8c 2d       	mov	r24, r12
 174:	80 73       	andi	r24, 0x30	; 48
 176:	4c 2d       	mov	r20, r12
 178:	6d 2d       	mov	r22, r13
 17a:	80 33       	cpi	r24, 0x30	; 48
 17c:	01 f4       	brne	.+0      	; 0x17e <_ZN6SdFile4openEPS_PKch+0x17e>
 17e:	00 c0       	rjmp	.+0      	; 0x180 <_ZN6SdFile4openEPS_PKch+0x180>
 180:	c7 01       	movw	r24, r14
 182:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile4openEPS_PKch>
 186:	2b 96       	adiw	r28, 0x0b	; 11
 188:	0f b6       	in	r0, 0x3f	; 63
 18a:	f8 94       	cli
 18c:	de bf       	out	0x3e, r29	; 62
 18e:	0f be       	out	0x3f, r0	; 63
 190:	cd bf       	out	0x3d, r28	; 61
 192:	df 91       	pop	r29
 194:	cf 91       	pop	r28
 196:	1f 91       	pop	r17
 198:	0f 91       	pop	r16
 19a:	ff 90       	pop	r15
 19c:	ef 90       	pop	r14
 19e:	df 90       	pop	r13
 1a0:	cf 90       	pop	r12
 1a2:	bf 90       	pop	r11
 1a4:	08 95       	ret
 1a6:	f8 01       	movw	r30, r16
 1a8:	84 81       	ldd	r24, Z+4	; 0x04
 1aa:	82 30       	cpi	r24, 0x02	; 2
 1ac:	01 f4       	brne	.+0      	; 0x1ae <_ZN6SdFile4openEPS_PKch+0x1ae>
 1ae:	00 c0       	rjmp	.+0      	; 0x1b0 <_ZN6SdFile4openEPS_PKch+0x1b0>
 1b0:	c8 01       	movw	r24, r16
 1b2:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile4openEPS_PKch>
 1b6:	88 23       	and	r24, r24
 1b8:	01 f4       	brne	.+0      	; 0x1ba <_ZN6SdFile4openEPS_PKch+0x1ba>
 1ba:	00 c0       	rjmp	.+0      	; 0x1bc <_ZN6SdFile4openEPS_PKch+0x1bc>
 1bc:	f7 01       	movw	r30, r14
 1be:	11 8a       	std	Z+17, r1	; 0x11
 1c0:	00 e0       	ldi	r16, 0x00	; 0
 1c2:	10 e0       	ldi	r17, 0x00	; 0
 1c4:	00 c0       	rjmp	.+0      	; 0x1c6 <_ZN6SdFile4openEPS_PKch+0x1c6>
 1c6:	81 e2       	ldi	r24, 0x21	; 33
 1c8:	98 e2       	ldi	r25, 0x28	; 40
 1ca:	f8 01       	movw	r30, r16
 1cc:	91 8b       	std	Z+17, r25	; 0x11
 1ce:	80 8b       	std	Z+16, r24	; 0x10
 1d0:	80 e0       	ldi	r24, 0x00	; 0
 1d2:	98 e0       	ldi	r25, 0x08	; 8
 1d4:	97 87       	std	Z+15, r25	; 0x0f
 1d6:	86 87       	std	Z+14, r24	; 0x0e
 1d8:	00 c0       	rjmp	.+0      	; 0x1da <__SREG__+0x19b>

Disassembly of section .text._ZN6SdFile7makeDirEPS_PKc:

00000000 <_ZN6SdFile7makeDirEPS_PKc>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
  write_P(str);
   6:	bf 92       	push	r11
   8:	df 92       	push	r13
  println();
   a:	ef 92       	push	r14
}
   c:	ff 92       	push	r15
   e:	0f 93       	push	r16
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	1f 93       	push	r17
  12:	cf 93       	push	r28
  14:	df 93       	push	r29
  16:	cd b7       	in	r28, 0x3d	; 61
  18:	de b7       	in	r29, 0x3e	; 62
  1a:	a0 97       	sbiw	r28, 0x20	; 32
  1c:	0f b6       	in	r0, 0x3f	; 63
  1e:	f8 94       	cli
  20:	de bf       	out	0x3e, r29	; 62
  22:	0f be       	out	0x3f, r0	; 63
  24:	cd bf       	out	0x3d, r28	; 61
  26:	8c 01       	movw	r16, r24
  28:	7b 01       	movw	r14, r22
  2a:	23 e3       	ldi	r18, 0x33	; 51
  2c:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile7makeDirEPS_PKc>
  30:	88 23       	and	r24, r24
  32:	01 f4       	brne	.+0      	; 0x34 <_ZN6SdFile7makeDirEPS_PKc+0x34>
  34:	00 c0       	rjmp	.+0      	; 0x36 <_ZN6SdFile7makeDirEPS_PKc+0x36>
  36:	81 e0       	ldi	r24, 0x01	; 1
  38:	d8 01       	movw	r26, r16
  3a:	13 96       	adiw	r26, 0x03	; 3
  3c:	8c 93       	st	X, r24
  3e:	13 97       	sbiw	r26, 0x03	; 3
  40:	84 e0       	ldi	r24, 0x04	; 4
  42:	14 96       	adiw	r26, 0x04	; 4
  44:	8c 93       	st	X, r24
  46:	c8 01       	movw	r24, r16
  48:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile7makeDirEPS_PKc>
  4c:	88 23       	and	r24, r24
  4e:	01 f4       	brne	.+0      	; 0x50 <_ZN6SdFile7makeDirEPS_PKc+0x50>
  50:	00 c0       	rjmp	.+0      	; 0x52 <_ZN6SdFile7makeDirEPS_PKc+0x52>
  52:	c8 01       	movw	r24, r16
  54:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile7makeDirEPS_PKc>
  58:	88 23       	and	r24, r24
  5a:	01 f4       	brne	.+0      	; 0x5c <_ZN6SdFile7makeDirEPS_PKc+0x5c>
  5c:	00 c0       	rjmp	.+0      	; 0x5e <_ZN6SdFile7makeDirEPS_PKc+0x5e>
  5e:	61 e0       	ldi	r22, 0x01	; 1
  60:	c8 01       	movw	r24, r16
  62:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile7makeDirEPS_PKc>
  66:	fc 01       	movw	r30, r24
  68:	89 2b       	or	r24, r25
  6a:	01 f4       	brne	.+0      	; 0x6c <_ZN6SdFile7makeDirEPS_PKc+0x6c>
  6c:	00 c0       	rjmp	.+0      	; 0x6e <_ZN6SdFile7makeDirEPS_PKc+0x6e>
  6e:	80 e1       	ldi	r24, 0x10	; 16
  70:	83 87       	std	Z+11, r24	; 0x0b
  72:	80 e2       	ldi	r24, 0x20	; 32
  74:	de 01       	movw	r26, r28
  76:	11 96       	adiw	r26, 0x01	; 1
  78:	01 90       	ld	r0, Z+
  7a:	0d 92       	st	X+, r0
  7c:	8a 95       	dec	r24
  7e:	01 f4       	brne	.+0      	; 0x80 <_ZN6SdFile7makeDirEPS_PKc+0x80>
  80:	fe 01       	movw	r30, r28
  82:	32 96       	adiw	r30, 0x02	; 2
  84:	ce 01       	movw	r24, r28
  86:	0c 96       	adiw	r24, 0x0c	; 12
  88:	20 e2       	ldi	r18, 0x20	; 32
  8a:	21 93       	st	Z+, r18
  8c:	e8 17       	cp	r30, r24
  8e:	f9 07       	cpc	r31, r25
  90:	01 f4       	brne	.+0      	; 0x92 <_ZN6SdFile7makeDirEPS_PKc+0x92>
  92:	8e e2       	ldi	r24, 0x2E	; 46
  94:	d8 2e       	mov	r13, r24
  96:	d9 82       	std	Y+1, r13	; 0x01
  98:	d8 01       	movw	r26, r16
  9a:	5a 96       	adiw	r26, 0x1a	; 26
  9c:	ed 91       	ld	r30, X+
  9e:	fc 91       	ld	r31, X
  a0:	5b 97       	sbiw	r26, 0x1b	; 27
  a2:	56 96       	adiw	r26, 0x16	; 22
  a4:	6d 91       	ld	r22, X+
  a6:	7d 91       	ld	r23, X+
  a8:	8d 91       	ld	r24, X+
  aa:	9c 91       	ld	r25, X
  ac:	59 97       	sbiw	r26, 0x19	; 25
  ae:	62 50       	subi	r22, 0x02	; 2
  b0:	71 09       	sbc	r23, r1
  b2:	81 09       	sbc	r24, r1
  b4:	91 09       	sbc	r25, r1
  b6:	25 85       	ldd	r18, Z+13	; 0x0d
  b8:	00 c0       	rjmp	.+0      	; 0xba <_ZN6SdFile7makeDirEPS_PKc+0xba>
  ba:	66 0f       	add	r22, r22
  bc:	77 1f       	adc	r23, r23
  be:	88 1f       	adc	r24, r24
  c0:	99 1f       	adc	r25, r25
  c2:	2a 95       	dec	r18
  c4:	02 f4       	brpl	.+0      	; 0xc6 <_ZN6SdFile7makeDirEPS_PKc+0xc6>
  c6:	86 84       	ldd	r8, Z+14	; 0x0e
  c8:	97 84       	ldd	r9, Z+15	; 0x0f
  ca:	a0 88       	ldd	r10, Z+16	; 0x10
  cc:	b1 88       	ldd	r11, Z+17	; 0x11
  ce:	68 0d       	add	r22, r8
  d0:	79 1d       	adc	r23, r9
  d2:	8a 1d       	adc	r24, r10
  d4:	9b 1d       	adc	r25, r11
  d6:	41 e0       	ldi	r20, 0x01	; 1
  d8:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile7makeDirEPS_PKc>
  dc:	88 23       	and	r24, r24
  de:	01 f4       	brne	.+0      	; 0xe0 <_ZN6SdFile7makeDirEPS_PKc+0xe0>
  e0:	00 c0       	rjmp	.+0      	; 0xe2 <_ZN6SdFile7makeDirEPS_PKc+0xe2>
  e2:	80 e2       	ldi	r24, 0x20	; 32
  e4:	fe 01       	movw	r30, r28
  e6:	31 96       	adiw	r30, 0x01	; 1
  e8:	a0 e0       	ldi	r26, 0x00	; 0
  ea:	b0 e0       	ldi	r27, 0x00	; 0
  ec:	01 90       	ld	r0, Z+
  ee:	0d 92       	st	X+, r0
  f0:	8a 95       	dec	r24
  f2:	01 f4       	brne	.+0      	; 0xf4 <_ZN6SdFile7makeDirEPS_PKc+0xf4>
  f4:	da 82       	std	Y+2, r13	; 0x02
  f6:	f7 01       	movw	r30, r14
  f8:	84 81       	ldd	r24, Z+4	; 0x04
  fa:	82 50       	subi	r24, 0x02	; 2
  fc:	82 30       	cpi	r24, 0x02	; 2
  fe:	00 f0       	brcs	.+0      	; 0x100 <_ZN6SdFile7makeDirEPS_PKc+0x100>
 100:	46 89       	ldd	r20, Z+22	; 0x16
 102:	57 89       	ldd	r21, Z+23	; 0x17
 104:	60 8d       	ldd	r22, Z+24	; 0x18
 106:	71 8d       	ldd	r23, Z+25	; 0x19
 108:	ca 01       	movw	r24, r20
 10a:	9b 01       	movw	r18, r22
 10c:	3e 8b       	std	Y+22, r19	; 0x16
 10e:	2d 8b       	std	Y+21, r18	; 0x15
 110:	9c 8f       	std	Y+28, r25	; 0x1c
 112:	8b 8f       	std	Y+27, r24	; 0x1b
 114:	80 e2       	ldi	r24, 0x20	; 32
 116:	fe 01       	movw	r30, r28
 118:	31 96       	adiw	r30, 0x01	; 1
 11a:	a0 e0       	ldi	r26, 0x00	; 0
 11c:	b0 e0       	ldi	r27, 0x00	; 0
 11e:	01 90       	ld	r0, Z+
 120:	0d 92       	st	X+, r0
 122:	8a 95       	dec	r24
 124:	01 f4       	brne	.+0      	; 0x126 <_ZN6SdFile7makeDirEPS_PKc+0x126>
 126:	80 e4       	ldi	r24, 0x40	; 64
 128:	90 e0       	ldi	r25, 0x00	; 0
 12a:	a0 e0       	ldi	r26, 0x00	; 0
 12c:	b0 e0       	ldi	r27, 0x00	; 0
 12e:	f8 01       	movw	r30, r16
 130:	81 87       	std	Z+9, r24	; 0x09
 132:	92 87       	std	Z+10, r25	; 0x0a
 134:	a3 87       	std	Z+11, r26	; 0x0b
 136:	b4 87       	std	Z+12, r27	; 0x0c
 138:	a0 96       	adiw	r28, 0x20	; 32
 13a:	0f b6       	in	r0, 0x3f	; 63
 13c:	f8 94       	cli
 13e:	de bf       	out	0x3e, r29	; 62
 140:	0f be       	out	0x3f, r0	; 63
 142:	cd bf       	out	0x3d, r28	; 61
 144:	df 91       	pop	r29
 146:	cf 91       	pop	r28
 148:	1f 91       	pop	r17
 14a:	0f 91       	pop	r16
 14c:	ff 90       	pop	r15
 14e:	ef 90       	pop	r14
 150:	df 90       	pop	r13
 152:	bf 90       	pop	r11
 154:	af 90       	pop	r10
 156:	9f 90       	pop	r9
 158:	8f 90       	pop	r8
 15a:	0c 94 00 00 	jmp	0	; 0x0 <_ZN6SdFile7makeDirEPS_PKc>
 15e:	90 e0       	ldi	r25, 0x00	; 0
 160:	80 e0       	ldi	r24, 0x00	; 0
 162:	30 e0       	ldi	r19, 0x00	; 0
 164:	20 e0       	ldi	r18, 0x00	; 0
 166:	00 c0       	rjmp	.+0      	; 0x168 <_ZN6SdFile7makeDirEPS_PKc+0x168>
 168:	80 e0       	ldi	r24, 0x00	; 0
 16a:	a0 96       	adiw	r28, 0x20	; 32
 16c:	0f b6       	in	r0, 0x3f	; 63
 16e:	f8 94       	cli
 170:	de bf       	out	0x3e, r29	; 62
 172:	0f be       	out	0x3f, r0	; 63
 174:	cd bf       	out	0x3d, r28	; 61
 176:	df 91       	pop	r29
 178:	cf 91       	pop	r28
 17a:	1f 91       	pop	r17
 17c:	0f 91       	pop	r16
 17e:	ff 90       	pop	r15
 180:	ef 90       	pop	r14
 182:	df 90       	pop	r13
 184:	bf 90       	pop	r11
 186:	af 90       	pop	r10
 188:	9f 90       	pop	r9
 18a:	8f 90       	pop	r8
 18c:	08 95       	ret

Disassembly of section .text._ZN6SdFile4openEPS_jh:

00000000 <_ZN6SdFile4openEPS_jh>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	df 92       	push	r13
   2:	ef 92       	push	r14
   4:	ff 92       	push	r15
  write_P(str);
   6:	0f 93       	push	r16
   8:	1f 93       	push	r17
  println();
   a:	cf 93       	push	r28
}
   c:	df 93       	push	r29
   e:	fc 01       	movw	r30, r24
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	34 81       	ldd	r19, Z+4	; 0x04
  12:	31 11       	cpse	r19, r1
  14:	00 c0       	rjmp	.+0      	; 0x16 <_ZN6SdFile4openEPS_jh+0x16>
  16:	32 2f       	mov	r19, r18
  18:	30 73       	andi	r19, 0x30	; 48
  1a:	30 33       	cpi	r19, 0x30	; 48
  1c:	01 f0       	breq	.+0      	; 0x1e <_ZN6SdFile4openEPS_jh+0x1e>
  1e:	d2 2e       	mov	r13, r18
  20:	ea 01       	movw	r28, r20
  22:	7b 01       	movw	r14, r22
  24:	8c 01       	movw	r16, r24
  26:	fb 01       	movw	r30, r22
  28:	82 8d       	ldd	r24, Z+26	; 0x1a
  2a:	93 8d       	ldd	r25, Z+27	; 0x1b
  2c:	f8 01       	movw	r30, r16
  2e:	93 8f       	std	Z+27, r25	; 0x1b
  30:	82 8f       	std	Z+26, r24	; 0x1a
  32:	85 e0       	ldi	r24, 0x05	; 5
  34:	44 0f       	add	r20, r20
  36:	55 1f       	adc	r21, r21
  38:	8a 95       	dec	r24
  3a:	01 f4       	brne	.+0      	; 0x3c <_ZN6SdFile4openEPS_jh+0x3c>
  3c:	70 e0       	ldi	r23, 0x00	; 0
  3e:	60 e0       	ldi	r22, 0x00	; 0
  40:	c7 01       	movw	r24, r14
  42:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile4openEPS_jh>
  46:	88 23       	and	r24, r24
  48:	01 f0       	breq	.+0      	; 0x4a <_ZN6SdFile4openEPS_jh+0x4a>
  4a:	c7 01       	movw	r24, r14
  4c:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile4openEPS_jh>
  50:	00 97       	sbiw	r24, 0x00	; 0
  52:	01 f0       	breq	.+0      	; 0x54 <_ZN6SdFile4openEPS_jh+0x54>
  54:	fc 01       	movw	r30, r24
  56:	80 81       	ld	r24, Z
  58:	88 23       	and	r24, r24
  5a:	01 f0       	breq	.+0      	; 0x5c <_ZN6SdFile4openEPS_jh+0x5c>
  5c:	85 3e       	cpi	r24, 0xE5	; 229
  5e:	01 f0       	breq	.+0      	; 0x60 <_ZN6SdFile4openEPS_jh+0x60>
  60:	8e 32       	cpi	r24, 0x2E	; 46
  62:	01 f0       	breq	.+0      	; 0x64 <_ZN6SdFile4openEPS_jh+0x64>
  64:	6c 2f       	mov	r22, r28
  66:	6f 70       	andi	r22, 0x0F	; 15
  68:	4d 2d       	mov	r20, r13
  6a:	c8 01       	movw	r24, r16
  6c:	df 91       	pop	r29
  6e:	cf 91       	pop	r28
  70:	1f 91       	pop	r17
  72:	0f 91       	pop	r16
  74:	ff 90       	pop	r15
  76:	ef 90       	pop	r14
  78:	df 90       	pop	r13
  7a:	0c 94 00 00 	jmp	0	; 0x0 <_ZN6SdFile4openEPS_jh>
  7e:	80 e0       	ldi	r24, 0x00	; 0
  80:	df 91       	pop	r29
  82:	cf 91       	pop	r28
  84:	1f 91       	pop	r17
  86:	0f 91       	pop	r16
  88:	ff 90       	pop	r15
  8a:	ef 90       	pop	r14
  8c:	df 90       	pop	r13
  8e:	08 95       	ret

Disassembly of section .text._ZN6SdFile2lsEhh:

00000000 <_ZN6SdFile2lsEhh>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
  write_P(str);
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
  println();
   a:	7f 92       	push	r7
}
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  24:	cd b7       	in	r28, 0x3d	; 61
  26:	de b7       	in	r29, 0x3e	; 62
  28:	6e 97       	sbiw	r28, 0x1e	; 30
  2a:	0f b6       	in	r0, 0x3f	; 63
  2c:	f8 94       	cli
  2e:	de bf       	out	0x3e, r29	; 62
  30:	0f be       	out	0x3f, r0	; 63
  32:	cd bf       	out	0x3d, r28	; 61
  34:	7c 01       	movw	r14, r24
  36:	d6 2e       	mov	r13, r22
  38:	fc 01       	movw	r30, r24
  3a:	15 82       	std	Z+5, r1	; 0x05
  3c:	16 82       	std	Z+6, r1	; 0x06
  3e:	17 82       	std	Z+7, r1	; 0x07
  40:	10 86       	std	Z+8, r1	; 0x08
  42:	11 86       	std	Z+9, r1	; 0x09
  44:	12 86       	std	Z+10, r1	; 0x0a
  46:	13 86       	std	Z+11, r1	; 0x0b
  48:	14 86       	std	Z+12, r1	; 0x0c
  4a:	86 2f       	mov	r24, r22
  4c:	83 70       	andi	r24, 0x03	; 3
  4e:	5e e0       	ldi	r21, 0x0E	; 14
  50:	75 2e       	mov	r7, r21
  52:	01 f4       	brne	.+0      	; 0x54 <_ZN6SdFile2lsEhh+0x54>
  54:	71 2c       	mov	r7, r1
  56:	a4 2e       	mov	r10, r20
  58:	b1 2c       	mov	r11, r1
  5a:	fd 2d       	mov	r31, r13
  5c:	f1 70       	andi	r31, 0x01	; 1
  5e:	fd 8f       	std	Y+29, r31	; 0x1d
  60:	8d 2d       	mov	r24, r13
  62:	84 70       	andi	r24, 0x04	; 4
  64:	68 2e       	mov	r6, r24
  66:	20 e0       	ldi	r18, 0x00	; 0
  68:	82 2e       	mov	r8, r18
  6a:	20 e0       	ldi	r18, 0x00	; 0
  6c:	92 2e       	mov	r9, r18
  6e:	32 e0       	ldi	r19, 0x02	; 2
  70:	c3 2e       	mov	r12, r19
  72:	c4 0e       	add	r12, r20
  74:	ed 2d       	mov	r30, r13
  76:	e2 70       	andi	r30, 0x02	; 2
  78:	ee 8f       	std	Y+30, r30	; 0x1e
  7a:	c7 01       	movw	r24, r14
  7c:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile2lsEhh>
  80:	8c 01       	movw	r16, r24
  82:	00 97       	sbiw	r24, 0x00	; 0
  84:	01 f4       	brne	.+0      	; 0x86 <_ZN6SdFile2lsEhh+0x86>
  86:	00 c0       	rjmp	.+0      	; 0x88 <_ZN6SdFile2lsEhh+0x88>
  88:	fc 01       	movw	r30, r24
  8a:	80 81       	ld	r24, Z
  8c:	88 23       	and	r24, r24
  8e:	01 f4       	brne	.+0      	; 0x90 <_ZN6SdFile2lsEhh+0x90>
  90:	00 c0       	rjmp	.+0      	; 0x92 <_ZN6SdFile2lsEhh+0x92>
  92:	85 3e       	cpi	r24, 0xE5	; 229
  94:	01 f0       	breq	.+0      	; 0x96 <_ZN6SdFile2lsEhh+0x96>
  96:	8e 32       	cpi	r24, 0x2E	; 46
  98:	01 f0       	breq	.+0      	; 0x9a <_ZN6SdFile2lsEhh+0x9a>
  9a:	83 85       	ldd	r24, Z+11	; 0x0b
  9c:	83 fd       	sbrc	r24, 3
  9e:	00 c0       	rjmp	.+0      	; 0xa0 <_ZN6SdFile2lsEhh+0xa0>
  a0:	31 2c       	mov	r3, r1
  a2:	83 2d       	mov	r24, r3
  a4:	03 2c       	mov	r0, r3
  a6:	00 0c       	add	r0, r0
  a8:	99 0b       	sbc	r25, r25
  aa:	8a 15       	cp	r24, r10
  ac:	9b 05       	cpc	r25, r11
  ae:	04 f4       	brge	.+0      	; 0xb0 <_ZN6SdFile2lsEhh+0xb0>
  b0:	50 e0       	ldi	r21, 0x00	; 0
  b2:	40 e0       	ldi	r20, 0x00	; 0
  b4:	60 e2       	ldi	r22, 0x20	; 32
  b6:	80 e0       	ldi	r24, 0x00	; 0
  b8:	90 e0       	ldi	r25, 0x00	; 0
  ba:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile2lsEhh>
  be:	33 94       	inc	r3
  c0:	00 c0       	rjmp	.+0      	; 0xc2 <_ZN6SdFile2lsEhh+0xc2>
  c2:	67 2d       	mov	r22, r7
  c4:	c8 01       	movw	r24, r16
  c6:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile2lsEhh>
  ca:	fd 8d       	ldd	r31, Y+29	; 0x1d
  cc:	ff 23       	and	r31, r31
  ce:	01 f0       	breq	.+0      	; 0xd0 <_ZN6SdFile2lsEhh+0xd0>
  d0:	f8 01       	movw	r30, r16
  d2:	80 8d       	ldd	r24, Z+24	; 0x18
  d4:	91 8d       	ldd	r25, Z+25	; 0x19
  d6:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile2lsEhh>
  da:	50 e0       	ldi	r21, 0x00	; 0
  dc:	40 e0       	ldi	r20, 0x00	; 0
  de:	60 e2       	ldi	r22, 0x20	; 32
  e0:	80 e0       	ldi	r24, 0x00	; 0
  e2:	90 e0       	ldi	r25, 0x00	; 0
  e4:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile2lsEhh>
  e8:	f8 01       	movw	r30, r16
  ea:	86 89       	ldd	r24, Z+22	; 0x16
  ec:	97 89       	ldd	r25, Z+23	; 0x17
  ee:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile2lsEhh>
  f2:	f8 01       	movw	r30, r16
  f4:	83 85       	ldd	r24, Z+11	; 0x0b
  f6:	88 71       	andi	r24, 0x18	; 24
  f8:	80 31       	cpi	r24, 0x10	; 16
  fa:	01 f0       	breq	.+0      	; 0xfc <_ZN6SdFile2lsEhh+0xfc>
  fc:	fe 8d       	ldd	r31, Y+30	; 0x1e
  fe:	ff 23       	and	r31, r31
 100:	01 f0       	breq	.+0      	; 0x102 <_ZN6SdFile2lsEhh+0x102>
 102:	50 e0       	ldi	r21, 0x00	; 0
 104:	40 e0       	ldi	r20, 0x00	; 0
 106:	60 e2       	ldi	r22, 0x20	; 32
 108:	80 e0       	ldi	r24, 0x00	; 0
 10a:	90 e0       	ldi	r25, 0x00	; 0
 10c:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile2lsEhh>
 110:	f8 01       	movw	r30, r16
 112:	44 8d       	ldd	r20, Z+28	; 0x1c
 114:	55 8d       	ldd	r21, Z+29	; 0x1d
 116:	66 8d       	ldd	r22, Z+30	; 0x1e
 118:	77 8d       	ldd	r23, Z+31	; 0x1f
 11a:	2a e0       	ldi	r18, 0x0A	; 10
 11c:	30 e0       	ldi	r19, 0x00	; 0
 11e:	80 e0       	ldi	r24, 0x00	; 0
 120:	90 e0       	ldi	r25, 0x00	; 0
 122:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile2lsEhh>
 126:	80 e0       	ldi	r24, 0x00	; 0
 128:	90 e0       	ldi	r25, 0x00	; 0
 12a:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile2lsEhh>
 12e:	66 20       	and	r6, r6
 130:	01 f4       	brne	.+0      	; 0x132 <_ZN6SdFile2lsEhh+0x132>
 132:	00 c0       	rjmp	.+0      	; 0x134 <_ZN6SdFile2lsEhh+0x134>
 134:	f8 01       	movw	r30, r16
 136:	83 85       	ldd	r24, Z+11	; 0x0b
 138:	88 71       	andi	r24, 0x18	; 24
 13a:	80 31       	cpi	r24, 0x10	; 16
 13c:	01 f0       	breq	.+0      	; 0x13e <_ZN6SdFile2lsEhh+0x13e>
 13e:	00 c0       	rjmp	.+0      	; 0x140 <_ZN6SdFile2lsEhh+0x140>
 140:	f7 01       	movw	r30, r14
 142:	41 85       	ldd	r20, Z+9	; 0x09
 144:	52 85       	ldd	r21, Z+10	; 0x0a
 146:	63 85       	ldd	r22, Z+11	; 0x0b
 148:	74 85       	ldd	r23, Z+12	; 0x0c
 14a:	1a 01       	movw	r2, r20
 14c:	2b 01       	movw	r4, r22
 14e:	95 e0       	ldi	r25, 0x05	; 5
 150:	56 94       	lsr	r5
 152:	47 94       	ror	r4
 154:	37 94       	ror	r3
 156:	27 94       	ror	r2
 158:	9a 95       	dec	r25
 15a:	01 f4       	brne	.+0      	; 0x15c <_ZN6SdFile2lsEhh+0x15c>
 15c:	9a 82       	std	Y+2, r9	; 0x02
 15e:	89 82       	std	Y+1, r8	; 0x01
 160:	1d 82       	std	Y+5, r1	; 0x05
 162:	a1 01       	movw	r20, r2
 164:	41 50       	subi	r20, 0x01	; 1
 166:	51 09       	sbc	r21, r1
 168:	21 e0       	ldi	r18, 0x01	; 1
 16a:	b7 01       	movw	r22, r14
 16c:	ce 01       	movw	r24, r28
 16e:	01 96       	adiw	r24, 0x01	; 1
 170:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile2lsEhh>
 174:	88 23       	and	r24, r24
 176:	01 f0       	breq	.+0      	; 0x178 <_ZN6SdFile2lsEhh+0x178>
 178:	4c 2d       	mov	r20, r12
 17a:	6d 2d       	mov	r22, r13
 17c:	ce 01       	movw	r24, r28
 17e:	01 96       	adiw	r24, 0x01	; 1
 180:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile2lsEhh>
 184:	a1 01       	movw	r20, r2
 186:	85 e0       	ldi	r24, 0x05	; 5
 188:	44 0f       	add	r20, r20
 18a:	55 1f       	adc	r21, r21
 18c:	8a 95       	dec	r24
 18e:	01 f4       	brne	.+0      	; 0x190 <_ZN6SdFile2lsEhh+0x190>
 190:	70 e0       	ldi	r23, 0x00	; 0
 192:	60 e0       	ldi	r22, 0x00	; 0
 194:	c7 01       	movw	r24, r14
 196:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile2lsEhh>
 19a:	00 c0       	rjmp	.+0      	; 0x19c <_ZN6SdFile2lsEhh+0x19c>
 19c:	6e 96       	adiw	r28, 0x1e	; 30
 19e:	0f b6       	in	r0, 0x3f	; 63
 1a0:	f8 94       	cli
 1a2:	de bf       	out	0x3e, r29	; 62
 1a4:	0f be       	out	0x3f, r0	; 63
 1a6:	cd bf       	out	0x3d, r28	; 61
 1a8:	df 91       	pop	r29
 1aa:	cf 91       	pop	r28
 1ac:	1f 91       	pop	r17
 1ae:	0f 91       	pop	r16
 1b0:	ff 90       	pop	r15
 1b2:	ef 90       	pop	r14
 1b4:	df 90       	pop	r13
 1b6:	cf 90       	pop	r12
 1b8:	bf 90       	pop	r11
 1ba:	af 90       	pop	r10
 1bc:	9f 90       	pop	r9
 1be:	8f 90       	pop	r8
 1c0:	7f 90       	pop	r7
 1c2:	6f 90       	pop	r6
 1c4:	5f 90       	pop	r5
 1c6:	4f 90       	pop	r4
 1c8:	3f 90       	pop	r3
 1ca:	2f 90       	pop	r2
 1cc:	08 95       	ret

Disassembly of section .text._ZN6SdFile6removeEv:

00000000 <_ZN6SdFile6removeEv>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
  write_P(str);
   6:	40 e0       	ldi	r20, 0x00	; 0
   8:	50 e0       	ldi	r21, 0x00	; 0
  println();
   a:	ba 01       	movw	r22, r20
}
   c:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile6removeEv>
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	88 23       	and	r24, r24
  12:	01 f0       	breq	.+0      	; 0x14 <_ZN6SdFile6removeEv+0x14>
  14:	61 e0       	ldi	r22, 0x01	; 1
  16:	ce 01       	movw	r24, r28
  18:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile6removeEv>
  1c:	00 97       	sbiw	r24, 0x00	; 0
  1e:	01 f0       	breq	.+0      	; 0x20 <_ZN6SdFile6removeEv+0x20>
  20:	25 ee       	ldi	r18, 0xE5	; 229
  22:	fc 01       	movw	r30, r24
  24:	20 83       	st	Z, r18
  26:	1c 82       	std	Y+4, r1	; 0x04
  28:	df 91       	pop	r29
  2a:	cf 91       	pop	r28
  2c:	0c 94 00 00 	jmp	0	; 0x0 <_ZN6SdFile6removeEv>
  30:	80 e0       	ldi	r24, 0x00	; 0
  32:	df 91       	pop	r29
  34:	cf 91       	pop	r28
  36:	08 95       	ret

Disassembly of section .text._ZN6SdFile16createContiguousEPS_PKcm:

00000000 <_ZN6SdFile16createContiguousEPS_PKcm>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
  write_P(str);
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
  println();
   a:	1f 93       	push	r17
}
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	01 15       	cp	r16, r1
  12:	11 05       	cpc	r17, r1
  14:	21 05       	cpc	r18, r1
  16:	31 05       	cpc	r19, r1
  18:	01 f0       	breq	.+0      	; 0x1a <_ZN6SdFile16createContiguousEPS_PKcm+0x1a>
  1a:	68 01       	movw	r12, r16
  1c:	79 01       	movw	r14, r18
  1e:	ec 01       	movw	r28, r24
  20:	23 e3       	ldi	r18, 0x33	; 51
  22:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile16createContiguousEPS_PKcm>
  26:	88 23       	and	r24, r24
  28:	01 f0       	breq	.+0      	; 0x2a <_ZN6SdFile16createContiguousEPS_PKcm+0x2a>
  2a:	8a 8d       	ldd	r24, Y+26	; 0x1a
  2c:	9b 8d       	ldd	r25, Y+27	; 0x1b
  2e:	fc 01       	movw	r30, r24
  30:	25 85       	ldd	r18, Z+13	; 0x0d
  32:	27 5f       	subi	r18, 0xF7	; 247
  34:	b7 01       	movw	r22, r14
  36:	a8 01       	movw	r20, r16
  38:	41 50       	subi	r20, 0x01	; 1
  3a:	51 09       	sbc	r21, r1
  3c:	61 09       	sbc	r22, r1
  3e:	71 09       	sbc	r23, r1
  40:	00 c0       	rjmp	.+0      	; 0x42 <_ZN6SdFile16createContiguousEPS_PKcm+0x42>
  42:	76 95       	lsr	r23
  44:	67 95       	ror	r22
  46:	57 95       	ror	r21
  48:	47 95       	ror	r20
  4a:	2a 95       	dec	r18
  4c:	02 f4       	brpl	.+0      	; 0x4e <_ZN6SdFile16createContiguousEPS_PKcm+0x4e>
  4e:	4f 5f       	subi	r20, 0xFF	; 255
  50:	5f 4f       	sbci	r21, 0xFF	; 255
  52:	6f 4f       	sbci	r22, 0xFF	; 255
  54:	7f 4f       	sbci	r23, 0xFF	; 255
  56:	9e 01       	movw	r18, r28
  58:	2a 5e       	subi	r18, 0xEA	; 234
  5a:	3f 4f       	sbci	r19, 0xFF	; 255
  5c:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile16createContiguousEPS_PKcm>
  60:	81 11       	cpse	r24, r1
  62:	00 c0       	rjmp	.+0      	; 0x64 <_ZN6SdFile16createContiguousEPS_PKcm+0x64>
  64:	ce 01       	movw	r24, r28
  66:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile16createContiguousEPS_PKcm>
  6a:	80 e0       	ldi	r24, 0x00	; 0
  6c:	df 91       	pop	r29
  6e:	cf 91       	pop	r28
  70:	1f 91       	pop	r17
  72:	0f 91       	pop	r16
  74:	ff 90       	pop	r15
  76:	ef 90       	pop	r14
  78:	df 90       	pop	r13
  7a:	cf 90       	pop	r12
  7c:	08 95       	ret
  7e:	ca 8a       	std	Y+18, r12	; 0x12
  80:	db 8a       	std	Y+19, r13	; 0x13
  82:	ec 8a       	std	Y+20, r14	; 0x14
  84:	fd 8a       	std	Y+21, r15	; 0x15
  86:	8b 81       	ldd	r24, Y+3	; 0x03
  88:	80 68       	ori	r24, 0x80	; 128
  8a:	8b 83       	std	Y+3, r24	; 0x03
  8c:	ce 01       	movw	r24, r28
  8e:	df 91       	pop	r29
  90:	cf 91       	pop	r28
  92:	1f 91       	pop	r17
  94:	0f 91       	pop	r16
  96:	ff 90       	pop	r15
  98:	ef 90       	pop	r14
  9a:	df 90       	pop	r13
  9c:	cf 90       	pop	r12
  9e:	0c 94 00 00 	jmp	0	; 0x0 <_ZN6SdFile16createContiguousEPS_PKcm>

Disassembly of section .text._ZN6SdFile6removeEPS_PKc:

00000000 <_ZN6SdFile6removeEPS_PKc>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	cd b7       	in	r28, 0x3d	; 61
  write_P(str);
   6:	de b7       	in	r29, 0x3e	; 62
   8:	6c 97       	sbiw	r28, 0x1c	; 28
  println();
   a:	0f b6       	in	r0, 0x3f	; 63
}
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	ab 01       	movw	r20, r22
  16:	20 e0       	ldi	r18, 0x00	; 0
  18:	30 e0       	ldi	r19, 0x00	; 0
  1a:	3a 83       	std	Y+2, r19	; 0x02
  1c:	29 83       	std	Y+1, r18	; 0x01
  1e:	1d 82       	std	Y+5, r1	; 0x05
  20:	22 e0       	ldi	r18, 0x02	; 2
  22:	bc 01       	movw	r22, r24
  24:	ce 01       	movw	r24, r28
  26:	01 96       	adiw	r24, 0x01	; 1
  28:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile6removeEPS_PKc>
  2c:	88 23       	and	r24, r24
  2e:	01 f0       	breq	.+0      	; 0x30 <_ZN6SdFile6removeEPS_PKc+0x30>
  30:	ce 01       	movw	r24, r28
  32:	01 96       	adiw	r24, 0x01	; 1
  34:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile6removeEPS_PKc>
  38:	6c 96       	adiw	r28, 0x1c	; 28
  3a:	0f b6       	in	r0, 0x3f	; 63
  3c:	f8 94       	cli
  3e:	de bf       	out	0x3e, r29	; 62
  40:	0f be       	out	0x3f, r0	; 63
  42:	cd bf       	out	0x3d, r28	; 61
  44:	df 91       	pop	r29
  46:	cf 91       	pop	r28
  48:	08 95       	ret

Disassembly of section .text._ZN6SdFile5rmDirEv:

00000000 <_ZN6SdFile5rmDirEv>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	fc 01       	movw	r30, r24
  write_P(str);
   6:	24 81       	ldd	r18, Z+4	; 0x04
   8:	24 30       	cpi	r18, 0x04	; 4
  println();
   a:	01 f4       	brne	.+0      	; 0xc <_ZN6SdFile5rmDirEv+0xc>
}
   c:	ec 01       	movw	r28, r24
   e:	15 82       	std	Z+5, r1	; 0x05
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	16 82       	std	Z+6, r1	; 0x06
  12:	17 82       	std	Z+7, r1	; 0x07
  14:	10 86       	std	Z+8, r1	; 0x08
  16:	11 86       	std	Z+9, r1	; 0x09
  18:	12 86       	std	Z+10, r1	; 0x0a
  1a:	13 86       	std	Z+11, r1	; 0x0b
  1c:	14 86       	std	Z+12, r1	; 0x0c
  1e:	49 85       	ldd	r20, Y+9	; 0x09
  20:	5a 85       	ldd	r21, Y+10	; 0x0a
  22:	6b 85       	ldd	r22, Y+11	; 0x0b
  24:	7c 85       	ldd	r23, Y+12	; 0x0c
  26:	8a 89       	ldd	r24, Y+18	; 0x12
  28:	9b 89       	ldd	r25, Y+19	; 0x13
  2a:	ac 89       	ldd	r26, Y+20	; 0x14
  2c:	bd 89       	ldd	r27, Y+21	; 0x15
  2e:	48 17       	cp	r20, r24
  30:	59 07       	cpc	r21, r25
  32:	6a 07       	cpc	r22, r26
  34:	7b 07       	cpc	r23, r27
  36:	00 f4       	brcc	.+0      	; 0x38 <_ZN6SdFile5rmDirEv+0x38>
  38:	ce 01       	movw	r24, r28
  3a:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile5rmDirEv>
  3e:	00 97       	sbiw	r24, 0x00	; 0
  40:	01 f0       	breq	.+0      	; 0x42 <_ZN6SdFile5rmDirEv+0x42>
  42:	fc 01       	movw	r30, r24
  44:	20 81       	ld	r18, Z
  46:	22 23       	and	r18, r18
  48:	01 f0       	breq	.+0      	; 0x4a <_ZN6SdFile5rmDirEv+0x4a>
  4a:	25 3e       	cpi	r18, 0xE5	; 229
  4c:	01 f0       	breq	.+0      	; 0x4e <_ZN6SdFile5rmDirEv+0x4e>
  4e:	2e 32       	cpi	r18, 0x2E	; 46
  50:	01 f0       	breq	.+0      	; 0x52 <_ZN6SdFile5rmDirEv+0x52>
  52:	83 85       	ldd	r24, Z+11	; 0x0b
  54:	83 fd       	sbrc	r24, 3
  56:	00 c0       	rjmp	.+0      	; 0x58 <_ZN6SdFile5rmDirEv+0x58>
  58:	80 e0       	ldi	r24, 0x00	; 0
  5a:	df 91       	pop	r29
  5c:	cf 91       	pop	r28
  5e:	08 95       	ret
  60:	81 e0       	ldi	r24, 0x01	; 1
  62:	8c 83       	std	Y+4, r24	; 0x04
  64:	8b 81       	ldd	r24, Y+3	; 0x03
  66:	82 60       	ori	r24, 0x02	; 2
  68:	8b 83       	std	Y+3, r24	; 0x03
  6a:	ce 01       	movw	r24, r28
  6c:	df 91       	pop	r29
  6e:	cf 91       	pop	r28
  70:	0c 94 00 00 	jmp	0	; 0x0 <_ZN6SdFile5rmDirEv>

Disassembly of section .text._ZN6SdFile8rmRfStarEv:

00000000 <_ZN6SdFile8rmRfStarEv>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	af 92       	push	r10
   2:	bf 92       	push	r11
   4:	cf 92       	push	r12
  write_P(str);
   6:	df 92       	push	r13
   8:	ef 92       	push	r14
  println();
   a:	ff 92       	push	r15
}
   c:	0f 93       	push	r16
   e:	1f 93       	push	r17
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	cf 93       	push	r28
  12:	df 93       	push	r29
  14:	cd b7       	in	r28, 0x3d	; 61
  16:	de b7       	in	r29, 0x3e	; 62
  18:	6c 97       	sbiw	r28, 0x1c	; 28
  1a:	0f b6       	in	r0, 0x3f	; 63
  1c:	f8 94       	cli
  1e:	de bf       	out	0x3e, r29	; 62
  20:	0f be       	out	0x3f, r0	; 63
  22:	cd bf       	out	0x3d, r28	; 61
  24:	8c 01       	movw	r16, r24
  26:	fc 01       	movw	r30, r24
  28:	15 82       	std	Z+5, r1	; 0x05
  2a:	16 82       	std	Z+6, r1	; 0x06
  2c:	17 82       	std	Z+7, r1	; 0x07
  2e:	10 86       	std	Z+8, r1	; 0x08
  30:	11 86       	std	Z+9, r1	; 0x09
  32:	12 86       	std	Z+10, r1	; 0x0a
  34:	13 86       	std	Z+11, r1	; 0x0b
  36:	14 86       	std	Z+12, r1	; 0x0c
  38:	20 e0       	ldi	r18, 0x00	; 0
  3a:	a2 2e       	mov	r10, r18
  3c:	20 e0       	ldi	r18, 0x00	; 0
  3e:	b2 2e       	mov	r11, r18
  40:	f8 01       	movw	r30, r16
  42:	c1 84       	ldd	r12, Z+9	; 0x09
  44:	d2 84       	ldd	r13, Z+10	; 0x0a
  46:	e3 84       	ldd	r14, Z+11	; 0x0b
  48:	f4 84       	ldd	r15, Z+12	; 0x0c
  4a:	82 89       	ldd	r24, Z+18	; 0x12
  4c:	93 89       	ldd	r25, Z+19	; 0x13
  4e:	a4 89       	ldd	r26, Z+20	; 0x14
  50:	b5 89       	ldd	r27, Z+21	; 0x15
  52:	c8 16       	cp	r12, r24
  54:	d9 06       	cpc	r13, r25
  56:	ea 06       	cpc	r14, r26
  58:	fb 06       	cpc	r15, r27
  5a:	00 f0       	brcs	.+0      	; 0x5c <_ZN6SdFile8rmRfStarEv+0x5c>
  5c:	00 c0       	rjmp	.+0      	; 0x5e <_ZN6SdFile8rmRfStarEv+0x5e>
  5e:	ba 82       	std	Y+2, r11	; 0x02
  60:	a9 82       	std	Y+1, r10	; 0x01
  62:	1d 82       	std	Y+5, r1	; 0x05
  64:	c8 01       	movw	r24, r16
  66:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile8rmRfStarEv>
  6a:	00 97       	sbiw	r24, 0x00	; 0
  6c:	01 f4       	brne	.+0      	; 0x6e <_ZN6SdFile8rmRfStarEv+0x6e>
  6e:	00 c0       	rjmp	.+0      	; 0x70 <_ZN6SdFile8rmRfStarEv+0x70>
  70:	fc 01       	movw	r30, r24
  72:	20 81       	ld	r18, Z
  74:	22 23       	and	r18, r18
  76:	01 f4       	brne	.+0      	; 0x78 <_ZN6SdFile8rmRfStarEv+0x78>
  78:	00 c0       	rjmp	.+0      	; 0x7a <_ZN6SdFile8rmRfStarEv+0x7a>
  7a:	25 3e       	cpi	r18, 0xE5	; 229
  7c:	01 f0       	breq	.+0      	; 0x7e <_ZN6SdFile8rmRfStarEv+0x7e>
  7e:	2e 32       	cpi	r18, 0x2E	; 46
  80:	01 f0       	breq	.+0      	; 0x82 <_ZN6SdFile8rmRfStarEv+0x82>
  82:	83 85       	ldd	r24, Z+11	; 0x0b
  84:	83 fd       	sbrc	r24, 3
  86:	00 c0       	rjmp	.+0      	; 0x88 <_ZN6SdFile8rmRfStarEv+0x88>
  88:	95 e0       	ldi	r25, 0x05	; 5
  8a:	f6 94       	lsr	r15
  8c:	e7 94       	ror	r14
  8e:	d7 94       	ror	r13
  90:	c7 94       	ror	r12
  92:	9a 95       	dec	r25
  94:	01 f4       	brne	.+0      	; 0x96 <_ZN6SdFile8rmRfStarEv+0x96>
  96:	21 e0       	ldi	r18, 0x01	; 1
  98:	a6 01       	movw	r20, r12
  9a:	b8 01       	movw	r22, r16
  9c:	ce 01       	movw	r24, r28
  9e:	01 96       	adiw	r24, 0x01	; 1
  a0:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile8rmRfStarEv>
  a4:	88 23       	and	r24, r24
  a6:	01 f0       	breq	.+0      	; 0xa8 <_ZN6SdFile8rmRfStarEv+0xa8>
  a8:	8d 81       	ldd	r24, Y+5	; 0x05
  aa:	84 30       	cpi	r24, 0x04	; 4
  ac:	01 f4       	brne	.+0      	; 0xae <_ZN6SdFile8rmRfStarEv+0xae>
  ae:	ce 01       	movw	r24, r28
  b0:	01 96       	adiw	r24, 0x01	; 1
  b2:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile8rmRfStarEv>
  b6:	88 23       	and	r24, r24
  b8:	01 f0       	breq	.+0      	; 0xba <_ZN6SdFile8rmRfStarEv+0xba>
  ba:	ff ef       	ldi	r31, 0xFF	; 255
  bc:	cf 1a       	sub	r12, r31
  be:	df 0a       	sbc	r13, r31
  c0:	85 e0       	ldi	r24, 0x05	; 5
  c2:	cc 0c       	add	r12, r12
  c4:	dd 1c       	adc	r13, r13
  c6:	8a 95       	dec	r24
  c8:	01 f4       	brne	.+0      	; 0xca <_ZN6SdFile8rmRfStarEv+0xca>
  ca:	a6 01       	movw	r20, r12
  cc:	70 e0       	ldi	r23, 0x00	; 0
  ce:	60 e0       	ldi	r22, 0x00	; 0
  d0:	f8 01       	movw	r30, r16
  d2:	81 85       	ldd	r24, Z+9	; 0x09
  d4:	92 85       	ldd	r25, Z+10	; 0x0a
  d6:	a3 85       	ldd	r26, Z+11	; 0x0b
  d8:	b4 85       	ldd	r27, Z+12	; 0x0c
  da:	84 17       	cp	r24, r20
  dc:	95 07       	cpc	r25, r21
  de:	a6 07       	cpc	r26, r22
  e0:	b7 07       	cpc	r27, r23
  e2:	01 f4       	brne	.+0      	; 0xe4 <_ZN6SdFile8rmRfStarEv+0xe4>
  e4:	00 c0       	rjmp	.+0      	; 0xe6 <_ZN6SdFile8rmRfStarEv+0xe6>
  e6:	c8 01       	movw	r24, r16
  e8:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile8rmRfStarEv>
  ec:	81 11       	cpse	r24, r1
  ee:	00 c0       	rjmp	.+0      	; 0xf0 <_ZN6SdFile8rmRfStarEv+0xf0>
  f0:	80 e0       	ldi	r24, 0x00	; 0
  f2:	6c 96       	adiw	r28, 0x1c	; 28
  f4:	0f b6       	in	r0, 0x3f	; 63
  f6:	f8 94       	cli
  f8:	de bf       	out	0x3e, r29	; 62
  fa:	0f be       	out	0x3f, r0	; 63
  fc:	cd bf       	out	0x3d, r28	; 61
  fe:	df 91       	pop	r29
 100:	cf 91       	pop	r28
 102:	1f 91       	pop	r17
 104:	0f 91       	pop	r16
 106:	ff 90       	pop	r15
 108:	ef 90       	pop	r14
 10a:	df 90       	pop	r13
 10c:	cf 90       	pop	r12
 10e:	bf 90       	pop	r11
 110:	af 90       	pop	r10
 112:	08 95       	ret
 114:	8c 81       	ldd	r24, Y+4	; 0x04
 116:	82 60       	ori	r24, 0x02	; 2
 118:	8c 83       	std	Y+4, r24	; 0x04
 11a:	ce 01       	movw	r24, r28
 11c:	01 96       	adiw	r24, 0x01	; 1
 11e:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile8rmRfStarEv>
 122:	00 c0       	rjmp	.+0      	; 0x124 <_ZN6SdFile8rmRfStarEv+0x124>
 124:	f8 01       	movw	r30, r16
 126:	84 81       	ldd	r24, Z+4	; 0x04
 128:	82 50       	subi	r24, 0x02	; 2
 12a:	82 30       	cpi	r24, 0x02	; 2
 12c:	00 f0       	brcs	.+0      	; 0x12e <_ZN6SdFile8rmRfStarEv+0x12e>
 12e:	c8 01       	movw	r24, r16
 130:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile8rmRfStarEv>
 134:	00 c0       	rjmp	.+0      	; 0x136 <_ZN6SdFile8rmRfStarEv+0x136>
 136:	81 e0       	ldi	r24, 0x01	; 1
 138:	00 c0       	rjmp	.+0      	; 0x13a <__SREG__+0xfb>

Disassembly of section .text._ZN6SdFile5writeEPKvj:

00000000 <_ZN6SdFile5writeEPKvj>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
  write_P(str);
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
  println();
   a:	7f 92       	push	r7
}
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  24:	00 d0       	rcall	.+0      	; 0x26 <_ZN6SdFile5writeEPKvj+0x26>
  26:	00 d0       	rcall	.+0      	; 0x28 <_ZN6SdFile5writeEPKvj+0x28>
  28:	cd b7       	in	r28, 0x3d	; 61
  2a:	de b7       	in	r29, 0x3e	; 62
  2c:	8c 01       	movw	r16, r24
  2e:	6b 01       	movw	r12, r22
  30:	1a 01       	movw	r2, r20
  32:	dc 01       	movw	r26, r24
  34:	14 96       	adiw	r26, 0x04	; 4
  36:	8c 91       	ld	r24, X
  38:	14 97       	sbiw	r26, 0x04	; 4
  3a:	81 30       	cpi	r24, 0x01	; 1
  3c:	01 f0       	breq	.+0      	; 0x3e <_ZN6SdFile5writeEPKvj+0x3e>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <_ZN6SdFile5writeEPKvj+0x40>
  40:	13 96       	adiw	r26, 0x03	; 3
  42:	8c 91       	ld	r24, X
  44:	81 ff       	sbrs	r24, 1
  46:	00 c0       	rjmp	.+0      	; 0x48 <_ZN6SdFile5writeEPKvj+0x48>
  48:	82 fd       	sbrc	r24, 2
  4a:	00 c0       	rjmp	.+0      	; 0x4c <_ZN6SdFile5writeEPKvj+0x4c>
  4c:	41 01       	movw	r8, r2
  4e:	d8 01       	movw	r26, r16
  50:	19 96       	adiw	r26, 0x09	; 9
  52:	4d 91       	ld	r20, X+
  54:	5d 91       	ld	r21, X+
  56:	6d 91       	ld	r22, X+
  58:	7c 91       	ld	r23, X
  5a:	1c 97       	sbiw	r26, 0x0c	; 12
  5c:	81 14       	cp	r8, r1
  5e:	91 04       	cpc	r9, r1
  60:	01 f4       	brne	.+0      	; 0x62 <_ZN6SdFile5writeEPKvj+0x62>
  62:	00 c0       	rjmp	.+0      	; 0x64 <_ZN6SdFile5writeEPKvj+0x64>
  64:	5a 96       	adiw	r26, 0x1a	; 26
  66:	8d 91       	ld	r24, X+
  68:	9c 91       	ld	r25, X
  6a:	5b 97       	sbiw	r26, 0x1b	; 27
  6c:	fc 01       	movw	r30, r24
  6e:	74 80       	ldd	r7, Z+4	; 0x04
  70:	2f ef       	ldi	r18, 0xFF	; 255
  72:	27 0d       	add	r18, r7
  74:	2a 01       	movw	r4, r20
  76:	3b 01       	movw	r6, r22
  78:	39 e0       	ldi	r19, 0x09	; 9
  7a:	76 94       	lsr	r7
  7c:	67 94       	ror	r6
  7e:	57 94       	ror	r5
  80:	47 94       	ror	r4
  82:	3a 95       	dec	r19
  84:	01 f4       	brne	.+0      	; 0x86 <_ZN6SdFile5writeEPKvj+0x86>
  86:	72 2e       	mov	r7, r18
  88:	74 20       	and	r7, r4
  8a:	7a 01       	movw	r14, r20
  8c:	f1 e0       	ldi	r31, 0x01	; 1
  8e:	ff 22       	and	r15, r31
  90:	71 10       	cpse	r7, r1
  92:	00 c0       	rjmp	.+0      	; 0x94 <_ZN6SdFile5writeEPKvj+0x94>
  94:	e1 14       	cp	r14, r1
  96:	f1 04       	cpc	r15, r1
  98:	01 f4       	brne	.+0      	; 0x9a <_ZN6SdFile5writeEPKvj+0x9a>
  9a:	15 96       	adiw	r26, 0x05	; 5
  9c:	4d 91       	ld	r20, X+
  9e:	5d 91       	ld	r21, X+
  a0:	6d 91       	ld	r22, X+
  a2:	7c 91       	ld	r23, X
  a4:	18 97       	sbiw	r26, 0x08	; 8
  a6:	41 15       	cp	r20, r1
  a8:	51 05       	cpc	r21, r1
  aa:	61 05       	cpc	r22, r1
  ac:	71 05       	cpc	r23, r1
  ae:	01 f0       	breq	.+0      	; 0xb0 <_ZN6SdFile5writeEPKvj+0xb0>
  b0:	00 c0       	rjmp	.+0      	; 0xb2 <_ZN6SdFile5writeEPKvj+0xb2>
  b2:	56 96       	adiw	r26, 0x16	; 22
  b4:	8d 91       	ld	r24, X+
  b6:	9d 91       	ld	r25, X+
  b8:	0d 90       	ld	r0, X+
  ba:	bc 91       	ld	r27, X
  bc:	a0 2d       	mov	r26, r0
  be:	00 97       	sbiw	r24, 0x00	; 0
  c0:	a1 05       	cpc	r26, r1
  c2:	b1 05       	cpc	r27, r1
  c4:	01 f0       	breq	.+0      	; 0xc6 <_ZN6SdFile5writeEPKvj+0xc6>
  c6:	00 c0       	rjmp	.+0      	; 0xc8 <_ZN6SdFile5writeEPKvj+0xc8>
  c8:	c8 01       	movw	r24, r16
  ca:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile5writeEPKvj>
  ce:	88 23       	and	r24, r24
  d0:	01 f4       	brne	.+0      	; 0xd2 <_ZN6SdFile5writeEPKvj+0xd2>
  d2:	00 c0       	rjmp	.+0      	; 0xd4 <_ZN6SdFile5writeEPKvj+0xd4>
  d4:	80 e0       	ldi	r24, 0x00	; 0
  d6:	92 e0       	ldi	r25, 0x02	; 2
  d8:	8e 19       	sub	r24, r14
  da:	9f 09       	sbc	r25, r15
  dc:	54 01       	movw	r10, r8
  de:	88 15       	cp	r24, r8
  e0:	99 05       	cpc	r25, r9
  e2:	00 f4       	brcc	.+0      	; 0xe4 <_ZN6SdFile5writeEPKvj+0xe4>
  e4:	5c 01       	movw	r10, r24
  e6:	d8 01       	movw	r26, r16
  e8:	5a 96       	adiw	r26, 0x1a	; 26
  ea:	4d 91       	ld	r20, X+
  ec:	5c 91       	ld	r21, X
  ee:	5b 97       	sbiw	r26, 0x1b	; 27
  f0:	15 96       	adiw	r26, 0x05	; 5
  f2:	8d 91       	ld	r24, X+
  f4:	9d 91       	ld	r25, X+
  f6:	0d 90       	ld	r0, X+
  f8:	bc 91       	ld	r27, X
  fa:	a0 2d       	mov	r26, r0
  fc:	02 97       	sbiw	r24, 0x02	; 2
  fe:	a1 09       	sbc	r26, r1
 100:	b1 09       	sbc	r27, r1
 102:	fa 01       	movw	r30, r20
 104:	25 85       	ldd	r18, Z+13	; 0x0d
 106:	00 c0       	rjmp	.+0      	; 0x108 <_ZN6SdFile5writeEPKvj+0x108>
 108:	88 0f       	add	r24, r24
 10a:	99 1f       	adc	r25, r25
 10c:	aa 1f       	adc	r26, r26
 10e:	bb 1f       	adc	r27, r27
 110:	2a 95       	dec	r18
 112:	02 f4       	brpl	.+0      	; 0x114 <_ZN6SdFile5writeEPKvj+0x114>
 114:	46 85       	ldd	r20, Z+14	; 0x0e
 116:	57 85       	ldd	r21, Z+15	; 0x0f
 118:	60 89       	ldd	r22, Z+16	; 0x10
 11a:	71 89       	ldd	r23, Z+17	; 0x11
 11c:	84 0f       	add	r24, r20
 11e:	95 1f       	adc	r25, r21
 120:	a6 1f       	adc	r26, r22
 122:	b7 1f       	adc	r27, r23
 124:	9c 01       	movw	r18, r24
 126:	ad 01       	movw	r20, r26
 128:	27 0d       	add	r18, r7
 12a:	31 1d       	adc	r19, r1
 12c:	41 1d       	adc	r20, r1
 12e:	51 1d       	adc	r21, r1
 130:	29 01       	movw	r4, r18
 132:	3a 01       	movw	r6, r20
 134:	a1 14       	cp	r10, r1
 136:	32 e0       	ldi	r19, 0x02	; 2
 138:	b3 06       	cpc	r11, r19
 13a:	01 f0       	breq	.+0      	; 0x13c <_ZN6SdFile5writeEPKvj+0x13c>
 13c:	00 c0       	rjmp	.+0      	; 0x13e <_ZN6SdFile5writeEPKvj+0x13e>
 13e:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 142:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 146:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 14a:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 14e:	84 15       	cp	r24, r4
 150:	95 05       	cpc	r25, r5
 152:	a6 05       	cpc	r26, r6
 154:	b7 05       	cpc	r27, r7
 156:	01 f4       	brne	.+0      	; 0x158 <_ZN6SdFile5writeEPKvj+0x158>
 158:	8f ef       	ldi	r24, 0xFF	; 255
 15a:	9f ef       	ldi	r25, 0xFF	; 255
 15c:	dc 01       	movw	r26, r24
 15e:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
 162:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
 166:	a0 93 00 00 	sts	0x0000, r26	; 0x800000 <__SREG__+0x7fffc1>
 16a:	b0 93 00 00 	sts	0x0000, r27	; 0x800000 <__SREG__+0x7fffc1>
 16e:	96 01       	movw	r18, r12
 170:	b3 01       	movw	r22, r6
 172:	a2 01       	movw	r20, r4
 174:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 178:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 17c:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile5writeEPKvj>
 180:	88 23       	and	r24, r24
 182:	01 f0       	breq	.+0      	; 0x184 <_ZN6SdFile5writeEPKvj+0x184>
 184:	9e ef       	ldi	r25, 0xFE	; 254
 186:	d9 1a       	sub	r13, r25
 188:	8a 18       	sub	r8, r10
 18a:	9b 08       	sbc	r9, r11
 18c:	f8 01       	movw	r30, r16
 18e:	81 85       	ldd	r24, Z+9	; 0x09
 190:	92 85       	ldd	r25, Z+10	; 0x0a
 192:	a3 85       	ldd	r26, Z+11	; 0x0b
 194:	b4 85       	ldd	r27, Z+12	; 0x0c
 196:	8a 0d       	add	r24, r10
 198:	9b 1d       	adc	r25, r11
 19a:	a1 1d       	adc	r26, r1
 19c:	b1 1d       	adc	r27, r1
 19e:	81 87       	std	Z+9, r24	; 0x09
 1a0:	92 87       	std	Z+10, r25	; 0x0a
 1a2:	a3 87       	std	Z+11, r26	; 0x0b
 1a4:	b4 87       	std	Z+12, r27	; 0x0c
 1a6:	00 c0       	rjmp	.+0      	; 0x1a8 <_ZN6SdFile5writeEPKvj+0x1a8>
 1a8:	f8 01       	movw	r30, r16
 1aa:	42 89       	ldd	r20, Z+18	; 0x12
 1ac:	53 89       	ldd	r21, Z+19	; 0x13
 1ae:	64 89       	ldd	r22, Z+20	; 0x14
 1b0:	75 89       	ldd	r23, Z+21	; 0x15
 1b2:	81 85       	ldd	r24, Z+9	; 0x09
 1b4:	92 85       	ldd	r25, Z+10	; 0x0a
 1b6:	a3 85       	ldd	r26, Z+11	; 0x0b
 1b8:	b4 85       	ldd	r27, Z+12	; 0x0c
 1ba:	48 17       	cp	r20, r24
 1bc:	59 07       	cpc	r21, r25
 1be:	6a 07       	cpc	r22, r26
 1c0:	7b 07       	cpc	r23, r27
 1c2:	01 f4       	brne	.+0      	; 0x1c4 <_ZN6SdFile5writeEPKvj+0x1c4>
 1c4:	00 c0       	rjmp	.+0      	; 0x1c6 <_ZN6SdFile5writeEPKvj+0x1c6>
 1c6:	c8 01       	movw	r24, r16
 1c8:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile5writeEPKvj>
 1cc:	81 11       	cpse	r24, r1
 1ce:	00 c0       	rjmp	.+0      	; 0x1d0 <_ZN6SdFile5writeEPKvj+0x1d0>
 1d0:	81 e0       	ldi	r24, 0x01	; 1
 1d2:	d8 01       	movw	r26, r16
 1d4:	12 96       	adiw	r26, 0x02	; 2
 1d6:	8c 93       	st	X, r24
 1d8:	8f ef       	ldi	r24, 0xFF	; 255
 1da:	9f ef       	ldi	r25, 0xFF	; 255
 1dc:	00 c0       	rjmp	.+0      	; 0x1de <_ZN6SdFile5writeEPKvj+0x1de>
 1de:	9e 01       	movw	r18, r28
 1e0:	2f 5f       	subi	r18, 0xFF	; 255
 1e2:	3f 4f       	sbci	r19, 0xFF	; 255
 1e4:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile5writeEPKvj>
 1e8:	81 11       	cpse	r24, r1
 1ea:	00 c0       	rjmp	.+0      	; 0x1ec <_ZN6SdFile5writeEPKvj+0x1ec>
 1ec:	90 e0       	ldi	r25, 0x00	; 0
 1ee:	0f 90       	pop	r0
 1f0:	0f 90       	pop	r0
 1f2:	0f 90       	pop	r0
 1f4:	0f 90       	pop	r0
 1f6:	df 91       	pop	r29
 1f8:	cf 91       	pop	r28
 1fa:	1f 91       	pop	r17
 1fc:	0f 91       	pop	r16
 1fe:	ff 90       	pop	r15
 200:	ef 90       	pop	r14
 202:	df 90       	pop	r13
 204:	cf 90       	pop	r12
 206:	bf 90       	pop	r11
 208:	af 90       	pop	r10
 20a:	9f 90       	pop	r9
 20c:	8f 90       	pop	r8
 20e:	7f 90       	pop	r7
 210:	6f 90       	pop	r6
 212:	5f 90       	pop	r5
 214:	4f 90       	pop	r4
 216:	3f 90       	pop	r3
 218:	2f 90       	pop	r2
 21a:	08 95       	ret
 21c:	89 81       	ldd	r24, Y+1	; 0x01
 21e:	9a 81       	ldd	r25, Y+2	; 0x02
 220:	ab 81       	ldd	r26, Y+3	; 0x03
 222:	bc 81       	ldd	r27, Y+4	; 0x04
 224:	f8 01       	movw	r30, r16
 226:	22 8d       	ldd	r18, Z+26	; 0x1a
 228:	33 8d       	ldd	r19, Z+27	; 0x1b
 22a:	f9 01       	movw	r30, r18
 22c:	27 89       	ldd	r18, Z+23	; 0x17
 22e:	48 ef       	ldi	r20, 0xF8	; 248
 230:	5f ef       	ldi	r21, 0xFF	; 255
 232:	60 e0       	ldi	r22, 0x00	; 0
 234:	70 e0       	ldi	r23, 0x00	; 0
 236:	20 31       	cpi	r18, 0x10	; 16
 238:	01 f0       	breq	.+0      	; 0x23a <_ZN6SdFile5writeEPKvj+0x23a>
 23a:	48 ef       	ldi	r20, 0xF8	; 248
 23c:	5f ef       	ldi	r21, 0xFF	; 255
 23e:	6f ef       	ldi	r22, 0xFF	; 255
 240:	7f e0       	ldi	r23, 0x0F	; 15
 242:	84 17       	cp	r24, r20
 244:	95 07       	cpc	r25, r21
 246:	a6 07       	cpc	r26, r22
 248:	b7 07       	cpc	r27, r23
 24a:	00 f0       	brcs	.+0      	; 0x24c <_ZN6SdFile5writeEPKvj+0x24c>
 24c:	00 c0       	rjmp	.+0      	; 0x24e <_ZN6SdFile5writeEPKvj+0x24e>
 24e:	f8 01       	movw	r30, r16
 250:	85 83       	std	Z+5, r24	; 0x05
 252:	96 83       	std	Z+6, r25	; 0x06
 254:	a7 83       	std	Z+7, r26	; 0x07
 256:	b0 87       	std	Z+8, r27	; 0x08
 258:	00 c0       	rjmp	.+0      	; 0x25a <_ZN6SdFile5writeEPKvj+0x25a>
 25a:	e1 14       	cp	r14, r1
 25c:	f1 04       	cpc	r15, r1
 25e:	01 f4       	brne	.+0      	; 0x260 <_ZN6SdFile5writeEPKvj+0x260>
 260:	d8 01       	movw	r26, r16
 262:	19 96       	adiw	r26, 0x09	; 9
 264:	4d 91       	ld	r20, X+
 266:	5d 91       	ld	r21, X+
 268:	6d 91       	ld	r22, X+
 26a:	7c 91       	ld	r23, X
 26c:	1c 97       	sbiw	r26, 0x0c	; 12
 26e:	52 96       	adiw	r26, 0x12	; 18
 270:	8d 91       	ld	r24, X+
 272:	9d 91       	ld	r25, X+
 274:	0d 90       	ld	r0, X+
 276:	bc 91       	ld	r27, X
 278:	a0 2d       	mov	r26, r0
 27a:	48 17       	cp	r20, r24
 27c:	59 07       	cpc	r21, r25
 27e:	6a 07       	cpc	r22, r26
 280:	7b 07       	cpc	r23, r27
 282:	00 f0       	brcs	.+0      	; 0x284 <_ZN6SdFile5writeEPKvj+0x284>
 284:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile5writeEPKvj>
 288:	88 23       	and	r24, r24
 28a:	01 f4       	brne	.+0      	; 0x28c <_ZN6SdFile5writeEPKvj+0x28c>
 28c:	00 c0       	rjmp	.+0      	; 0x28e <_ZN6SdFile5writeEPKvj+0x28e>
 28e:	40 92 00 00 	sts	0x0000, r4	; 0x800000 <__SREG__+0x7fffc1>
 292:	50 92 00 00 	sts	0x0000, r5	; 0x800000 <__SREG__+0x7fffc1>
 296:	60 92 00 00 	sts	0x0000, r6	; 0x800000 <__SREG__+0x7fffc1>
 29a:	70 92 00 00 	sts	0x0000, r7	; 0x800000 <__SREG__+0x7fffc1>
 29e:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 2a2:	81 60       	ori	r24, 0x01	; 1
 2a4:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
 2a8:	97 01       	movw	r18, r14
 2aa:	20 50       	subi	r18, 0x00	; 0
 2ac:	30 40       	sbci	r19, 0x00	; 0
 2ae:	d6 01       	movw	r26, r12
 2b0:	c9 01       	movw	r24, r18
 2b2:	8a 0d       	add	r24, r10
 2b4:	9b 1d       	adc	r25, r11
 2b6:	f9 01       	movw	r30, r18
 2b8:	8e 17       	cp	r24, r30
 2ba:	9f 07       	cpc	r25, r31
 2bc:	01 f0       	breq	.+0      	; 0x2be <_ZN6SdFile5writeEPKvj+0x2be>
 2be:	4d 91       	ld	r20, X+
 2c0:	41 93       	st	Z+, r20
 2c2:	00 c0       	rjmp	.+0      	; 0x2c4 <_ZN6SdFile5writeEPKvj+0x2c4>
 2c4:	41 e0       	ldi	r20, 0x01	; 1
 2c6:	c3 01       	movw	r24, r6
 2c8:	b2 01       	movw	r22, r4
 2ca:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile5writeEPKvj>
 2ce:	81 11       	cpse	r24, r1
 2d0:	00 c0       	rjmp	.+0      	; 0x2d2 <_ZN6SdFile5writeEPKvj+0x2d2>
 2d2:	00 c0       	rjmp	.+0      	; 0x2d4 <_ZN6SdFile5writeEPKvj+0x2d4>
 2d4:	82 1b       	sub	r24, r18
 2d6:	93 0b       	sbc	r25, r19
 2d8:	c8 0e       	add	r12, r24
 2da:	d9 1e       	adc	r13, r25
 2dc:	00 c0       	rjmp	.+0      	; 0x2de <_ZN6SdFile5writeEPKvj+0x2de>
 2de:	13 96       	adiw	r26, 0x03	; 3
 2e0:	8c 91       	ld	r24, X
 2e2:	13 97       	sbiw	r26, 0x03	; 3
 2e4:	52 96       	adiw	r26, 0x12	; 18
 2e6:	cd 90       	ld	r12, X+
 2e8:	dd 90       	ld	r13, X+
 2ea:	ed 90       	ld	r14, X+
 2ec:	fc 90       	ld	r15, X
 2ee:	55 97       	sbiw	r26, 0x15	; 21
 2f0:	c4 16       	cp	r12, r20
 2f2:	d5 06       	cpc	r13, r21
 2f4:	e6 06       	cpc	r14, r22
 2f6:	f7 06       	cpc	r15, r23
 2f8:	00 f4       	brcc	.+0      	; 0x2fa <_ZN6SdFile5writeEPKvj+0x2fa>
 2fa:	f8 01       	movw	r30, r16
 2fc:	42 8b       	std	Z+18, r20	; 0x12
 2fe:	53 8b       	std	Z+19, r21	; 0x13
 300:	64 8b       	std	Z+20, r22	; 0x14
 302:	75 8b       	std	Z+21, r23	; 0x15
 304:	80 68       	ori	r24, 0x80	; 128
 306:	83 83       	std	Z+3, r24	; 0x03
 308:	f8 01       	movw	r30, r16
 30a:	83 81       	ldd	r24, Z+3	; 0x03
 30c:	83 fd       	sbrc	r24, 3
 30e:	00 c0       	rjmp	.+0      	; 0x310 <_ZN6SdFile5writeEPKvj+0x310>
 310:	c1 01       	movw	r24, r2
 312:	00 c0       	rjmp	.+0      	; 0x314 <_ZN6SdFile5writeEPKvj+0x314>
 314:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 318:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 31c:	23 2b       	or	r18, r19
 31e:	01 f0       	breq	.+0      	; 0x320 <_ZN6SdFile5writeEPKvj+0x320>
 320:	21 14       	cp	r2, r1
 322:	31 04       	cpc	r3, r1
 324:	01 f0       	breq	.+0      	; 0x326 <_ZN6SdFile5writeEPKvj+0x326>
 326:	80 68       	ori	r24, 0x80	; 128
 328:	13 96       	adiw	r26, 0x03	; 3
 32a:	8c 93       	st	X, r24
 32c:	00 c0       	rjmp	.+0      	; 0x32e <_ZN6SdFile5writeEPKvj+0x32e>
 32e:	c8 01       	movw	r24, r16
 330:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile5writeEPKvj>
 334:	81 11       	cpse	r24, r1
 336:	00 c0       	rjmp	.+0      	; 0x338 <_ZN6SdFile5writeEPKvj+0x338>
 338:	00 c0       	rjmp	.+0      	; 0x33a <__SREG__+0x2fb>

Disassembly of section .text._ZN6SdFile5writeEh:

00000000 <_ZN6SdFile5writeEh>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	1f 92       	push	r1
  write_P(str);
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
  println();
   a:	69 83       	std	Y+1, r22	; 0x01
}
   c:	41 e0       	ldi	r20, 0x01	; 1
   e:	50 e0       	ldi	r21, 0x00	; 0
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	be 01       	movw	r22, r28
  12:	6f 5f       	subi	r22, 0xFF	; 255
  14:	7f 4f       	sbci	r23, 0xFF	; 255
  16:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile5writeEh>
  1a:	0f 90       	pop	r0
  1c:	df 91       	pop	r29
  1e:	cf 91       	pop	r28
  20:	08 95       	ret

Disassembly of section .text._ZN6SdFile5writeEPKc:

00000000 <_ZN6SdFile5writeEPKc>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	fb 01       	movw	r30, r22
   2:	01 90       	ld	r0, Z+
   4:	00 20       	and	r0, r0
  write_P(str);
   6:	01 f4       	brne	.+0      	; 0x8 <_ZN6SdFile5writeEPKc+0x8>
   8:	31 97       	sbiw	r30, 0x01	; 1
  println();
   a:	af 01       	movw	r20, r30
}
   c:	46 1b       	sub	r20, r22
   e:	57 0b       	sbc	r21, r23
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	0c 94 00 00 	jmp	0	; 0x0 <_ZN6SdFile5writeEPKc>

Disassembly of section .text._ZN6SdFile7write_PEPKc:

00000000 <_ZN6SdFile7write_PEPKc>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
  write_P(str);
   6:	df 93       	push	r29
   8:	8c 01       	movw	r16, r24
  println();
   a:	eb 01       	movw	r28, r22
}
   c:	fe 01       	movw	r30, r28
   e:	64 91       	lpm	r22, Z
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	66 23       	and	r22, r22
  12:	01 f0       	breq	.+0      	; 0x14 <_ZN6SdFile7write_PEPKc+0x14>
  14:	d8 01       	movw	r26, r16
  16:	ed 91       	ld	r30, X+
  18:	fc 91       	ld	r31, X
  1a:	01 90       	ld	r0, Z+
  1c:	f0 81       	ld	r31, Z
  1e:	e0 2d       	mov	r30, r0
  20:	c8 01       	movw	r24, r16
  22:	09 95       	icall
  24:	21 96       	adiw	r28, 0x01	; 1
  26:	00 c0       	rjmp	.+0      	; 0x28 <_ZN6SdFile7write_PEPKc+0x28>
  28:	df 91       	pop	r29
  2a:	cf 91       	pop	r28
  2c:	1f 91       	pop	r17
  2e:	0f 91       	pop	r16
  30:	08 95       	ret

Disassembly of section .text._ZN6SdFile9writeln_PEPKc:

00000000 <_ZN6SdFile9writeln_PEPKc>:
/**
 * Write a PROGMEM string followed by CR/LF to a file.
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
  write_P(str);
   6:	0e 94 00 00 	call	0	; 0x0 <_ZN6SdFile9writeln_PEPKc>
  println();
   a:	ce 01       	movw	r24, r28
}
   c:	df 91       	pop	r29
   e:	cf 91       	pop	r28
 *
 * Use SdFile::writeError to check for errors.
 */
void SdFile::writeln_P(PGM_P str) {
  write_P(str);
  println();
  10:	0c 94 00 00 	jmp	0	; 0x0 <_ZN6SdFile9writeln_PEPKc>

SdVolume.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00001704  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00003382  00000000  00000000  00001738  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text._ZN8SdVolume10cacheFlushEv 00000076  00000000  00000000  00004aba  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text._ZN8SdVolume13cacheRawBlockEmh 00000076  00000000  00000000  00004b30  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text._ZN8SdVolume14cacheZeroBlockEm 00000048  00000000  00000000  00004ba6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text._ZNK8SdVolume6fatGetEmPm 00000102  00000000  00000000  00004bee  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text._ZNK8SdVolume9chainSizeEmPm 000000d6  00000000  00000000  00004cf0  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text._ZN8SdVolume6fatPutEmm 00000144  00000000  00000000  00004dc6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text._ZN8SdVolume15allocContiguousEmPm 00000216  00000000  00000000  00004f0a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text._ZN8SdVolume9freeChainEm 000000ac  00000000  00000000  00005120  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text._ZN8SdVolume4initEP7Sd2Cardh 00000240  00000000  00000000  000051cc  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .bss._ZN8SdVolume17cacheMirrorBlock_E 00000004  00000000  00000000  0000540c  2**0
                  ALLOC
 15 .bss._ZN8SdVolume11cacheDirty_E 00000001  00000000  00000000  0000540c  2**0
                  ALLOC
 16 .bss._ZN8SdVolume7sdCard_E 00000002  00000000  00000000  0000540c  2**0
                  ALLOC
 17 .bss._ZN8SdVolume12cacheBuffer_E 00000200  00000000  00000000  0000540c  2**0
                  ALLOC
 18 .data._ZN8SdVolume17cacheBlockNumber_E 00000004  00000000  00000000  0000540c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 19 .comment      00000012  00000000  00000000  00005410  2**0
                  CONTENTS, READONLY

Disassembly of section .text._ZN8SdVolume10cacheFlushEv:

00000000 <_ZN8SdVolume10cacheFlushEv>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.  Reasons for
 * failure include not finding a valid partition, not finding a valid
 * FAT file system in the specified partition or an I/O error.
 */
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
   0:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	88 23       	and	r24, r24
   6:	01 f0       	breq	.+0      	; 0x8 <_ZN8SdVolume10cacheFlushEv+0x8>
   8:	40 91 00 00 	lds	r20, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   c:	50 91 00 00 	lds	r21, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  10:	60 91 00 00 	lds	r22, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  14:	70 91 00 00 	lds	r23, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  18:	20 e0       	ldi	r18, 0x00	; 0
  1a:	30 e0       	ldi	r19, 0x00	; 0
  uint32_t volumeStartBlock = 0;
  sdCard_ = dev;
  1c:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  20:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
  24:	0e 94 00 00 	call	0	; 0x0 <_ZN8SdVolume10cacheFlushEv>
  28:	81 11       	cpse	r24, r1
    if (part > 4)return false;
  2a:	00 c0       	rjmp	.+0      	; 0x2c <_ZN8SdVolume10cacheFlushEv+0x2c>
  2c:	80 e0       	ldi	r24, 0x00	; 0
  2e:	08 95       	ret
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
  }
  return true;
}
  30:	40 91 00 00 	lds	r20, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  34:	50 91 00 00 	lds	r21, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  38:	60 91 00 00 	lds	r22, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  3c:	70 91 00 00 	lds	r23, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  40:	41 15       	cp	r20, r1
  42:	51 05       	cpc	r21, r1
  44:	61 05       	cpc	r22, r1
  46:	71 05       	cpc	r23, r1
  48:	01 f0       	breq	.+0      	; 0x4a <_ZN8SdVolume10cacheFlushEv+0x4a>
  sdCard_ = dev;
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  4a:	20 e0       	ldi	r18, 0x00	; 0
  4c:	30 e0       	ldi	r19, 0x00	; 0
  4e:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  52:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  56:	0e 94 00 00 	call	0	; 0x0 <_ZN8SdVolume10cacheFlushEv>
    part_t* p = &cacheBuffer_.mbr.part[part-1];
  5a:	88 23       	and	r24, r24
  5c:	01 f0       	breq	.+0      	; 0x5e <_ZN8SdVolume10cacheFlushEv+0x5e>
  5e:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
    if ((p->boot & 0X7F) !=0  ||
  62:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  66:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  6a:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  6e:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  72:	81 e0       	ldi	r24, 0x01	; 1
  74:	08 95       	ret

Disassembly of section .text._ZN8SdVolume13cacheRawBlockEmh:

00000000 <_ZN8SdVolume13cacheRawBlockEmh>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.  Reasons for
 * failure include not finding a valid partition, not finding a valid
 * FAT file system in the specified partition or an I/O error.
 */
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	cf 93       	push	r28
   a:	6b 01       	movw	r12, r22
   c:	7c 01       	movw	r14, r24
   e:	c4 2f       	mov	r28, r20
  10:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  14:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  18:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  uint32_t volumeStartBlock = 0;
  sdCard_ = dev;
  1c:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  20:	8c 15       	cp	r24, r12
  22:	9d 05       	cpc	r25, r13
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
  24:	ae 05       	cpc	r26, r14
  26:	bf 05       	cpc	r27, r15
  28:	01 f0       	breq	.+0      	; 0x2a <_ZN8SdVolume13cacheRawBlockEmh+0x2a>
    if (part > 4)return false;
  2a:	0e 94 00 00 	call	0	; 0x0 <_ZN8SdVolume13cacheRawBlockEmh>
  2e:	81 11       	cpse	r24, r1
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
  }
  return true;
}
  30:	00 c0       	rjmp	.+0      	; 0x32 <_ZN8SdVolume13cacheRawBlockEmh+0x32>
  32:	80 e0       	ldi	r24, 0x00	; 0
  34:	cf 91       	pop	r28
  36:	ff 90       	pop	r15
  38:	ef 90       	pop	r14
  3a:	df 90       	pop	r13
  3c:	cf 90       	pop	r12
  3e:	08 95       	ret
  40:	20 e0       	ldi	r18, 0x00	; 0
  42:	30 e0       	ldi	r19, 0x00	; 0
  44:	b7 01       	movw	r22, r14
  46:	a6 01       	movw	r20, r12
  48:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  sdCard_ = dev;
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  4c:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  50:	0e 94 00 00 	call	0	; 0x0 <_ZN8SdVolume13cacheRawBlockEmh>
  54:	88 23       	and	r24, r24
  56:	01 f0       	breq	.+0      	; 0x58 <_ZN8SdVolume13cacheRawBlockEmh+0x58>
  58:	c0 92 00 00 	sts	0x0000, r12	; 0x800000 <__SREG__+0x7fffc1>
    part_t* p = &cacheBuffer_.mbr.part[part-1];
  5c:	d0 92 00 00 	sts	0x0000, r13	; 0x800000 <__SREG__+0x7fffc1>
  60:	e0 92 00 00 	sts	0x0000, r14	; 0x800000 <__SREG__+0x7fffc1>
    if ((p->boot & 0X7F) !=0  ||
  64:	f0 92 00 00 	sts	0x0000, r15	; 0x800000 <__SREG__+0x7fffc1>
  68:	40 91 00 00 	lds	r20, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  6c:	4c 2b       	or	r20, r28
  6e:	40 93 00 00 	sts	0x0000, r20	; 0x800000 <__SREG__+0x7fffc1>
  72:	81 e0       	ldi	r24, 0x01	; 1
  74:	00 c0       	rjmp	.+0      	; 0x76 <__SREG__+0x37>

Disassembly of section .text._ZN8SdVolume14cacheZeroBlockEm:

00000000 <_ZN8SdVolume14cacheZeroBlockEm>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.  Reasons for
 * failure include not finding a valid partition, not finding a valid
 * FAT file system in the specified partition or an I/O error.
 */
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	6b 01       	movw	r12, r22
   a:	7c 01       	movw	r14, r24
   c:	0e 94 00 00 	call	0	; 0x0 <_ZN8SdVolume14cacheZeroBlockEm>
  10:	88 23       	and	r24, r24
  12:	01 f0       	breq	.+0      	; 0x14 <_ZN8SdVolume14cacheZeroBlockEm+0x14>
  14:	e0 e0       	ldi	r30, 0x00	; 0
  16:	f0 e0       	ldi	r31, 0x00	; 0
  18:	11 92       	st	Z+, r1
  1a:	80 e0       	ldi	r24, 0x00	; 0
  uint32_t volumeStartBlock = 0;
  sdCard_ = dev;
  1c:	e0 30       	cpi	r30, 0x00	; 0
  1e:	f8 07       	cpc	r31, r24
  20:	01 f4       	brne	.+0      	; 0x22 <_ZN8SdVolume14cacheZeroBlockEm+0x22>
  22:	c0 92 00 00 	sts	0x0000, r12	; 0x800000 <__SREG__+0x7fffc1>
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
  26:	d0 92 00 00 	sts	0x0000, r13	; 0x800000 <__SREG__+0x7fffc1>
    if (part > 4)return false;
  2a:	e0 92 00 00 	sts	0x0000, r14	; 0x800000 <__SREG__+0x7fffc1>
  2e:	f0 92 00 00 	sts	0x0000, r15	; 0x800000 <__SREG__+0x7fffc1>
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
  }
  return true;
}
  32:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  36:	81 60       	ori	r24, 0x01	; 1
  38:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  3c:	81 e0       	ldi	r24, 0x01	; 1
  3e:	ff 90       	pop	r15
  40:	ef 90       	pop	r14
  42:	df 90       	pop	r13
  44:	cf 90       	pop	r12
  46:	08 95       	ret

Disassembly of section .text._ZNK8SdVolume6fatGetEmPm:

00000000 <_ZNK8SdVolume6fatGetEmPm>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.  Reasons for
 * failure include not finding a valid partition, not finding a valid
 * FAT file system in the specified partition or an I/O error.
 */
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
   6:	bf 92       	push	r11
   8:	cf 92       	push	r12
   a:	df 92       	push	r13
   c:	ef 92       	push	r14
   e:	ff 92       	push	r15
  10:	0f 93       	push	r16
  12:	1f 93       	push	r17
  14:	cf 93       	push	r28
  16:	df 93       	push	r29
  18:	fc 01       	movw	r30, r24
  1a:	81 85       	ldd	r24, Z+9	; 0x09
  uint32_t volumeStartBlock = 0;
  sdCard_ = dev;
  1c:	92 85       	ldd	r25, Z+10	; 0x0a
  1e:	a3 85       	ldd	r26, Z+11	; 0x0b
  20:	b4 85       	ldd	r27, Z+12	; 0x0c
  22:	01 96       	adiw	r24, 0x01	; 1
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
  24:	a1 1d       	adc	r26, r1
  26:	b1 1d       	adc	r27, r1
  28:	84 17       	cp	r24, r20
    if (part > 4)return false;
  2a:	95 07       	cpc	r25, r21
  2c:	a6 07       	cpc	r26, r22
  2e:	b7 07       	cpc	r27, r23
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
  }
  return true;
}
  30:	00 f4       	brcc	.+0      	; 0x32 <_ZNK8SdVolume6fatGetEmPm+0x32>
  32:	80 e0       	ldi	r24, 0x00	; 0
  34:	df 91       	pop	r29
  36:	cf 91       	pop	r28
  38:	1f 91       	pop	r17
  3a:	0f 91       	pop	r16
  3c:	ff 90       	pop	r15
  3e:	ef 90       	pop	r14
  40:	df 90       	pop	r13
  42:	cf 90       	pop	r12
  44:	bf 90       	pop	r11
  46:	af 90       	pop	r10
  48:	9f 90       	pop	r9
  sdCard_ = dev;
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  4a:	8f 90       	pop	r8
  4c:	08 95       	ret
  4e:	83 88       	ldd	r8, Z+19	; 0x13
  50:	94 88       	ldd	r9, Z+20	; 0x14
  52:	a5 88       	ldd	r10, Z+21	; 0x15
  54:	b6 88       	ldd	r11, Z+22	; 0x16
  56:	87 89       	ldd	r24, Z+23	; 0x17
  58:	80 31       	cpi	r24, 0x10	; 16
    part_t* p = &cacheBuffer_.mbr.part[part-1];
  5a:	01 f4       	brne	.+0      	; 0x5c <_ZNK8SdVolume6fatGetEmPm+0x5c>
  5c:	bb 27       	eor	r27, r27
  5e:	a7 2f       	mov	r26, r23
  60:	96 2f       	mov	r25, r22
    if ((p->boot & 0X7F) !=0  ||
  62:	85 2f       	mov	r24, r21
  64:	e9 01       	movw	r28, r18
  66:	6a 01       	movw	r12, r20
  68:	7b 01       	movw	r14, r22
  6a:	8f 01       	movw	r16, r30
  6c:	bc 01       	movw	r22, r24
  6e:	cd 01       	movw	r24, r26
  70:	68 0d       	add	r22, r8
  72:	79 1d       	adc	r23, r9
  74:	8a 1d       	adc	r24, r10
  76:	9b 1d       	adc	r25, r11
  78:	80 90 00 00 	lds	r8, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
      p->totalSectors < 100 ||
  7c:	90 90 00 00 	lds	r9, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
    part_t* p = &cacheBuffer_.mbr.part[part-1];
    if ((p->boot & 0X7F) !=0  ||
  80:	a0 90 00 00 	lds	r10, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  84:	b0 90 00 00 	lds	r11, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  88:	86 16       	cp	r8, r22
  8a:	97 06       	cpc	r9, r23
  8c:	a8 06       	cpc	r10, r24
  8e:	b9 06       	cpc	r11, r25
      p->totalSectors < 100 ||
      p->firstSector == 0) {
  90:	01 f4       	brne	.+0      	; 0x92 <_ZNK8SdVolume6fatGetEmPm+0x92>
  92:	f8 01       	movw	r30, r16
  94:	87 89       	ldd	r24, Z+23	; 0x17
  96:	80 31       	cpi	r24, 0x10	; 16
  98:	01 f4       	brne	.+0      	; 0x9a <_ZNK8SdVolume6fatGetEmPm+0x9a>
  9a:	dd 24       	eor	r13, r13
  9c:	ee 24       	eor	r14, r14
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
    part_t* p = &cacheBuffer_.mbr.part[part-1];
    if ((p->boot & 0X7F) !=0  ||
      p->totalSectors < 100 ||
  9e:	ff 24       	eor	r15, r15
  a0:	f6 01       	movw	r30, r12
  a2:	ee 0f       	add	r30, r30
  a4:	ff 1f       	adc	r31, r31
  a6:	e0 50       	subi	r30, 0x00	; 0
      // not a valid partition
      return false;
    }
    volumeStartBlock = p->firstSector;
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  a8:	f0 40       	sbci	r31, 0x00	; 0
  aa:	80 81       	ld	r24, Z
  ac:	91 81       	ldd	r25, Z+1	; 0x01
  ae:	b0 e0       	ldi	r27, 0x00	; 0
  b0:	a0 e0       	ldi	r26, 0x00	; 0
  b2:	88 83       	st	Y, r24
  b4:	99 83       	std	Y+1, r25	; 0x01
  b6:	aa 83       	std	Y+2, r26	; 0x02
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
  b8:	bb 83       	std	Y+3, r27	; 0x03
  ba:	81 e0       	ldi	r24, 0x01	; 1
  bc:	00 c0       	rjmp	.+0      	; 0xbe <_ZNK8SdVolume6fatGetEmPm+0xbe>
  be:	db 01       	movw	r26, r22
  c0:	ca 01       	movw	r24, r20
  c2:	c7 e0       	ldi	r28, 0x07	; 7
  c4:	b6 95       	lsr	r27
  c6:	a7 95       	ror	r26
    bpb->fatCount == 0 ||
  c8:	97 95       	ror	r25
  ca:	87 95       	ror	r24
    }
    volumeStartBlock = p->firstSector;
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
  cc:	ca 95       	dec	r28
  ce:	01 f4       	brne	.+0      	; 0xd0 <_ZNK8SdVolume6fatGetEmPm+0xd0>
  d0:	00 c0       	rjmp	.+0      	; 0xd2 <_ZNK8SdVolume6fatGetEmPm+0xd2>
    bpb->fatCount == 0 ||
  d2:	40 e0       	ldi	r20, 0x00	; 0
  d4:	0e 94 00 00 	call	0	; 0x0 <_ZNK8SdVolume6fatGetEmPm>
  d8:	81 11       	cpse	r24, r1
  da:	00 c0       	rjmp	.+0      	; 0xdc <_ZNK8SdVolume6fatGetEmPm+0xdc>
  dc:	00 c0       	rjmp	.+0      	; 0xde <_ZNK8SdVolume6fatGetEmPm+0xde>
  de:	e8 94       	clt
    bpb->reservedSectorCount == 0 ||
    bpb->sectorsPerCluster == 0) {
  e0:	c7 f8       	bld	r12, 7
  e2:	dd 24       	eor	r13, r13
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
    bpb->fatCount == 0 ||
    bpb->reservedSectorCount == 0 ||
  e4:	ee 24       	eor	r14, r14
  e6:	ff 24       	eor	r15, r15
  e8:	f6 01       	movw	r30, r12
    bpb->sectorsPerCluster == 0) {
       // not valid FAT volume
      return false;
  }
  fatCount_ = bpb->fatCount;
  ea:	ee 0f       	add	r30, r30
  blocksPerCluster_ = bpb->sectorsPerCluster;
  ec:	ff 1f       	adc	r31, r31

  // determine shift that is same as multiply by blocksPerCluster_
  clusterSizeShift_ = 0;
  ee:	ee 0f       	add	r30, r30
  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
  f0:	ff 1f       	adc	r31, r31
  f2:	e0 50       	subi	r30, 0x00	; 0
  f4:	f0 40       	sbci	r31, 0x00	; 0
  f6:	80 81       	ld	r24, Z
  f8:	91 81       	ldd	r25, Z+1	; 0x01
  fa:	a2 81       	ldd	r26, Z+2	; 0x02
  fc:	b3 81       	ldd	r27, Z+3	; 0x03
  fe:	bf 70       	andi	r27, 0x0F	; 15
 100:	00 c0       	rjmp	.+0      	; 0x102 <__SREG__+0xc3>

Disassembly of section .text._ZNK8SdVolume9chainSizeEmPm:

00000000 <_ZNK8SdVolume9chainSizeEmPm>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.  Reasons for
 * failure include not finding a valid partition, not finding a valid
 * FAT file system in the specified partition or an I/O error.
 */
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
   0:	4f 92       	push	r4
   2:	5f 92       	push	r5
   4:	6f 92       	push	r6
   6:	7f 92       	push	r7
   8:	af 92       	push	r10
   a:	bf 92       	push	r11
   c:	cf 92       	push	r12
   e:	df 92       	push	r13
  10:	ef 92       	push	r14
  12:	ff 92       	push	r15
  14:	0f 93       	push	r16
  16:	1f 93       	push	r17
  18:	cf 93       	push	r28
  1a:	df 93       	push	r29
  uint32_t volumeStartBlock = 0;
  sdCard_ = dev;
  1c:	00 d0       	rcall	.+0      	; 0x1e <_ZNK8SdVolume9chainSizeEmPm+0x1e>
  1e:	00 d0       	rcall	.+0      	; 0x20 <_ZNK8SdVolume9chainSizeEmPm+0x20>
  20:	cd b7       	in	r28, 0x3d	; 61
  22:	de b7       	in	r29, 0x3e	; 62
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
  24:	8c 01       	movw	r16, r24
  26:	49 83       	std	Y+1, r20	; 0x01
  28:	5a 83       	std	Y+2, r21	; 0x02
    if (part > 4)return false;
  2a:	6b 83       	std	Y+3, r22	; 0x03
  2c:	7c 83       	std	Y+4, r23	; 0x04
  2e:	59 01       	movw	r10, r18
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
  }
  return true;
}
  30:	c1 2c       	mov	r12, r1
  32:	d1 2c       	mov	r13, r1
  34:	76 01       	movw	r14, r12
  36:	41 2c       	mov	r4, r1
  38:	82 e0       	ldi	r24, 0x02	; 2
  3a:	58 2e       	mov	r5, r24
  3c:	61 2c       	mov	r6, r1
  3e:	71 2c       	mov	r7, r1
  40:	49 81       	ldd	r20, Y+1	; 0x01
  42:	5a 81       	ldd	r21, Y+2	; 0x02
  44:	6b 81       	ldd	r22, Y+3	; 0x03
  46:	7c 81       	ldd	r23, Y+4	; 0x04
  48:	9e 01       	movw	r18, r28
  sdCard_ = dev;
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  4a:	2f 5f       	subi	r18, 0xFF	; 255
  4c:	3f 4f       	sbci	r19, 0xFF	; 255
  4e:	c8 01       	movw	r24, r16
  50:	0e 94 00 00 	call	0	; 0x0 <_ZNK8SdVolume9chainSizeEmPm>
  54:	88 23       	and	r24, r24
  56:	01 f0       	breq	.+0      	; 0x58 <_ZNK8SdVolume9chainSizeEmPm+0x58>
  58:	f8 01       	movw	r30, r16
    part_t* p = &cacheBuffer_.mbr.part[part-1];
  5a:	85 85       	ldd	r24, Z+13	; 0x0d
  5c:	a3 01       	movw	r20, r6
  5e:	92 01       	movw	r18, r4
  60:	00 c0       	rjmp	.+0      	; 0x62 <_ZNK8SdVolume9chainSizeEmPm+0x62>
    if ((p->boot & 0X7F) !=0  ||
  62:	22 0f       	add	r18, r18
  64:	33 1f       	adc	r19, r19
  66:	44 1f       	adc	r20, r20
  68:	55 1f       	adc	r21, r21
  6a:	8a 95       	dec	r24
  6c:	02 f4       	brpl	.+0      	; 0x6e <_ZNK8SdVolume9chainSizeEmPm+0x6e>
  6e:	da 01       	movw	r26, r20
  70:	c9 01       	movw	r24, r18
  72:	c8 0e       	add	r12, r24
  74:	d9 1e       	adc	r13, r25
  76:	ea 1e       	adc	r14, r26
  78:	fb 1e       	adc	r15, r27
  7a:	49 81       	ldd	r20, Y+1	; 0x01
      p->totalSectors < 100 ||
  7c:	5a 81       	ldd	r21, Y+2	; 0x02
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
    part_t* p = &cacheBuffer_.mbr.part[part-1];
    if ((p->boot & 0X7F) !=0  ||
  7e:	6b 81       	ldd	r22, Y+3	; 0x03
  80:	7c 81       	ldd	r23, Y+4	; 0x04
  82:	87 89       	ldd	r24, Z+23	; 0x17
  84:	80 31       	cpi	r24, 0x10	; 16
  86:	01 f0       	breq	.+0      	; 0x88 <_ZNK8SdVolume9chainSizeEmPm+0x88>
  88:	88 ef       	ldi	r24, 0xF8	; 248
  8a:	9f ef       	ldi	r25, 0xFF	; 255
  8c:	af ef       	ldi	r26, 0xFF	; 255
  8e:	bf e0       	ldi	r27, 0x0F	; 15
      p->totalSectors < 100 ||
      p->firstSector == 0) {
  90:	48 17       	cp	r20, r24
  92:	59 07       	cpc	r21, r25
  94:	6a 07       	cpc	r22, r26
  96:	7b 07       	cpc	r23, r27
  98:	00 f0       	brcs	.+0      	; 0x9a <_ZNK8SdVolume9chainSizeEmPm+0x9a>
  9a:	f5 01       	movw	r30, r10
  9c:	c0 82       	st	Z, r12
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
    part_t* p = &cacheBuffer_.mbr.part[part-1];
    if ((p->boot & 0X7F) !=0  ||
      p->totalSectors < 100 ||
  9e:	d1 82       	std	Z+1, r13	; 0x01
  a0:	e2 82       	std	Z+2, r14	; 0x02
  a2:	f3 82       	std	Z+3, r15	; 0x03
  a4:	81 e0       	ldi	r24, 0x01	; 1
  a6:	0f 90       	pop	r0
      // not a valid partition
      return false;
    }
    volumeStartBlock = p->firstSector;
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  a8:	0f 90       	pop	r0
  aa:	0f 90       	pop	r0
  ac:	0f 90       	pop	r0
  ae:	df 91       	pop	r29
  b0:	cf 91       	pop	r28
  b2:	1f 91       	pop	r17
  b4:	0f 91       	pop	r16
  b6:	ff 90       	pop	r15
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
  b8:	ef 90       	pop	r14
  ba:	df 90       	pop	r13
  bc:	cf 90       	pop	r12
  be:	bf 90       	pop	r11
  c0:	af 90       	pop	r10
  c2:	7f 90       	pop	r7
  c4:	6f 90       	pop	r6
  c6:	5f 90       	pop	r5
    bpb->fatCount == 0 ||
  c8:	4f 90       	pop	r4
  ca:	08 95       	ret
    }
    volumeStartBlock = p->firstSector;
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
  cc:	88 ef       	ldi	r24, 0xF8	; 248
  ce:	9f ef       	ldi	r25, 0xFF	; 255
  d0:	a0 e0       	ldi	r26, 0x00	; 0
    bpb->fatCount == 0 ||
  d2:	b0 e0       	ldi	r27, 0x00	; 0
  d4:	00 c0       	rjmp	.+0      	; 0xd6 <__SREG__+0x97>

Disassembly of section .text._ZN8SdVolume6fatPutEmm:

00000000 <_ZN8SdVolume6fatPutEmm>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.  Reasons for
 * failure include not finding a valid partition, not finding a valid
 * FAT file system in the specified partition or an I/O error.
 */
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
   0:	4f 92       	push	r4
   2:	5f 92       	push	r5
   4:	6f 92       	push	r6
   6:	7f 92       	push	r7
   8:	8f 92       	push	r8
   a:	9f 92       	push	r9
   c:	af 92       	push	r10
   e:	bf 92       	push	r11
  10:	cf 92       	push	r12
  12:	df 92       	push	r13
  14:	ef 92       	push	r14
  16:	ff 92       	push	r15
  18:	0f 93       	push	r16
  1a:	1f 93       	push	r17
  uint32_t volumeStartBlock = 0;
  sdCard_ = dev;
  1c:	cf 93       	push	r28
  1e:	df 93       	push	r29
  20:	ec 01       	movw	r28, r24
  22:	42 30       	cpi	r20, 0x02	; 2
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
  24:	51 05       	cpc	r21, r1
  26:	61 05       	cpc	r22, r1
  28:	71 05       	cpc	r23, r1
    if (part > 4)return false;
  2a:	00 f4       	brcc	.+0      	; 0x2c <_ZN8SdVolume6fatPutEmm+0x2c>
  2c:	80 e0       	ldi	r24, 0x00	; 0
  2e:	df 91       	pop	r29
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
  }
  return true;
}
  30:	cf 91       	pop	r28
  32:	1f 91       	pop	r17
  34:	0f 91       	pop	r16
  36:	ff 90       	pop	r15
  38:	ef 90       	pop	r14
  3a:	df 90       	pop	r13
  3c:	cf 90       	pop	r12
  3e:	bf 90       	pop	r11
  40:	af 90       	pop	r10
  42:	9f 90       	pop	r9
  44:	8f 90       	pop	r8
  46:	7f 90       	pop	r7
  48:	6f 90       	pop	r6
  sdCard_ = dev;
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  4a:	5f 90       	pop	r5
  4c:	4f 90       	pop	r4
  4e:	08 95       	ret
  50:	89 85       	ldd	r24, Y+9	; 0x09
  52:	9a 85       	ldd	r25, Y+10	; 0x0a
  54:	ab 85       	ldd	r26, Y+11	; 0x0b
  56:	bc 85       	ldd	r27, Y+12	; 0x0c
  58:	01 96       	adiw	r24, 0x01	; 1
    part_t* p = &cacheBuffer_.mbr.part[part-1];
  5a:	a1 1d       	adc	r26, r1
  5c:	b1 1d       	adc	r27, r1
  5e:	84 17       	cp	r24, r20
  60:	95 07       	cpc	r25, r21
    if ((p->boot & 0X7F) !=0  ||
  62:	a6 07       	cpc	r26, r22
  64:	b7 07       	cpc	r27, r23
  66:	00 f0       	brcs	.+0      	; 0x68 <_ZN8SdVolume6fatPutEmm+0x68>
  68:	cb 88       	ldd	r12, Y+19	; 0x13
  6a:	dc 88       	ldd	r13, Y+20	; 0x14
  6c:	ed 88       	ldd	r14, Y+21	; 0x15
  6e:	fe 88       	ldd	r15, Y+22	; 0x16
  70:	8f 89       	ldd	r24, Y+23	; 0x17
  72:	80 31       	cpi	r24, 0x10	; 16
  74:	01 f0       	breq	.+0      	; 0x76 <_ZN8SdVolume6fatPutEmm+0x76>
  76:	00 c0       	rjmp	.+0      	; 0x78 <_ZN8SdVolume6fatPutEmm+0x78>
  78:	bb 27       	eor	r27, r27
  7a:	a7 2f       	mov	r26, r23
      p->totalSectors < 100 ||
  7c:	96 2f       	mov	r25, r22
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
    part_t* p = &cacheBuffer_.mbr.part[part-1];
    if ((p->boot & 0X7F) !=0  ||
  7e:	85 2f       	mov	r24, r21
  80:	48 01       	movw	r8, r16
  82:	59 01       	movw	r10, r18
  84:	2a 01       	movw	r4, r20
  86:	3b 01       	movw	r6, r22
  88:	c8 0e       	add	r12, r24
  8a:	d9 1e       	adc	r13, r25
  8c:	ea 1e       	adc	r14, r26
  8e:	fb 1e       	adc	r15, r27
      p->totalSectors < 100 ||
      p->firstSector == 0) {
  90:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  94:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  98:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  9c:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
    part_t* p = &cacheBuffer_.mbr.part[part-1];
    if ((p->boot & 0X7F) !=0  ||
      p->totalSectors < 100 ||
  a0:	c8 16       	cp	r12, r24
  a2:	d9 06       	cpc	r13, r25
  a4:	ea 06       	cpc	r14, r26
  a6:	fb 06       	cpc	r15, r27
      // not a valid partition
      return false;
    }
    volumeStartBlock = p->firstSector;
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  a8:	01 f4       	brne	.+0      	; 0xaa <_ZN8SdVolume6fatPutEmm+0xaa>
  aa:	8f 89       	ldd	r24, Y+23	; 0x17
  ac:	80 31       	cpi	r24, 0x10	; 16
  ae:	01 f4       	brne	.+0      	; 0xb0 <_ZN8SdVolume6fatPutEmm+0xb0>
  b0:	b3 01       	movw	r22, r6
  b2:	a2 01       	movw	r20, r4
  b4:	55 27       	eor	r21, r21
  b6:	66 27       	eor	r22, r22
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
  b8:	77 27       	eor	r23, r23
  ba:	44 0f       	add	r20, r20
  bc:	55 1f       	adc	r21, r21
  be:	40 50       	subi	r20, 0x00	; 0
  c0:	50 40       	sbci	r21, 0x00	; 0
  c2:	fa 01       	movw	r30, r20
  c4:	91 82       	std	Z+1, r9	; 0x01
  c6:	80 82       	st	Z, r8
    bpb->fatCount == 0 ||
  c8:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    volumeStartBlock = p->firstSector;
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
  cc:	81 60       	ori	r24, 0x01	; 1
  ce:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
    bpb->fatCount == 0 ||
  d2:	8a 89       	ldd	r24, Y+18	; 0x12
  d4:	82 30       	cpi	r24, 0x02	; 2
  d6:	00 f0       	brcs	.+0      	; 0xd8 <_ZN8SdVolume6fatPutEmm+0xd8>
  d8:	8d 81       	ldd	r24, Y+5	; 0x05
  da:	9e 81       	ldd	r25, Y+6	; 0x06
  dc:	af 81       	ldd	r26, Y+7	; 0x07
  de:	b8 85       	ldd	r27, Y+8	; 0x08
    bpb->reservedSectorCount == 0 ||
    bpb->sectorsPerCluster == 0) {
  e0:	8c 0d       	add	r24, r12
  e2:	9d 1d       	adc	r25, r13
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
    bpb->fatCount == 0 ||
    bpb->reservedSectorCount == 0 ||
  e4:	ae 1d       	adc	r26, r14
  e6:	bf 1d       	adc	r27, r15
  e8:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
    bpb->sectorsPerCluster == 0) {
       // not valid FAT volume
      return false;
  }
  fatCount_ = bpb->fatCount;
  blocksPerCluster_ = bpb->sectorsPerCluster;
  ec:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>

  // determine shift that is same as multiply by blocksPerCluster_
  clusterSizeShift_ = 0;
  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
  f0:	a0 93 00 00 	sts	0x0000, r26	; 0x800000 <__SREG__+0x7fffc1>
  f4:	b0 93 00 00 	sts	0x0000, r27	; 0x800000 <__SREG__+0x7fffc1>
  f8:	81 e0       	ldi	r24, 0x01	; 1
  fa:	00 c0       	rjmp	.+0      	; 0xfc <_ZN8SdVolume6fatPutEmm+0xfc>
  fc:	db 01       	movw	r26, r22
  fe:	ca 01       	movw	r24, r20
 100:	e7 e0       	ldi	r30, 0x07	; 7
 102:	b6 95       	lsr	r27
 104:	a7 95       	ror	r26
 106:	97 95       	ror	r25
 108:	87 95       	ror	r24
 10a:	ea 95       	dec	r30
 10c:	01 f4       	brne	.+0      	; 0x10e <_ZN8SdVolume6fatPutEmm+0x10e>
    // error if not power of 2
    if (clusterSizeShift_++ > 7) return false;
 10e:	00 c0       	rjmp	.+0      	; 0x110 <_ZN8SdVolume6fatPutEmm+0x110>
 110:	40 e0       	ldi	r20, 0x00	; 0
 112:	c7 01       	movw	r24, r14
 114:	b6 01       	movw	r22, r12
 116:	0e 94 00 00 	call	0	; 0x0 <_ZN8SdVolume6fatPutEmm>
 * the value zero, false, is returned for failure.  Reasons for
 * failure include not finding a valid partition, not finding a valid
 * FAT file system in the specified partition or an I/O error.
 */
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
  uint32_t volumeStartBlock = 0;
 11a:	81 11       	cpse	r24, r1
 11c:	00 c0       	rjmp	.+0      	; 0x11e <_ZN8SdVolume6fatPutEmm+0x11e>
 11e:	00 c0       	rjmp	.+0      	; 0x120 <_ZN8SdVolume6fatPutEmm+0x120>
 120:	b3 01       	movw	r22, r6
  clusterSizeShift_ = 0;
  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
    // error if not power of 2
    if (clusterSizeShift_++ > 7) return false;
  }
  blocksPerFat_ = bpb->sectorsPerFat16 ?
 122:	a2 01       	movw	r20, r4
 124:	4f 77       	andi	r20, 0x7F	; 127
 126:	55 27       	eor	r21, r21
 128:	66 27       	eor	r22, r22
 12a:	77 27       	eor	r23, r23
 12c:	44 0f       	add	r20, r20
 12e:	55 1f       	adc	r21, r21
 130:	44 0f       	add	r20, r20
 132:	55 1f       	adc	r21, r21
 134:	40 50       	subi	r20, 0x00	; 0
 136:	50 40       	sbci	r21, 0x00	; 0
 138:	fa 01       	movw	r30, r20
 13a:	80 82       	st	Z, r8
 13c:	91 82       	std	Z+1, r9	; 0x01
 13e:	a2 82       	std	Z+2, r10	; 0x02
 140:	b3 82       	std	Z+3, r11	; 0x03
 142:	00 c0       	rjmp	.+0      	; 0x144 <__SREG__+0x105>

Disassembly of section .text._ZN8SdVolume15allocContiguousEmPm:

00000000 <_ZN8SdVolume15allocContiguousEmPm>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.  Reasons for
 * failure include not finding a valid partition, not finding a valid
 * FAT file system in the specified partition or an I/O error.
 */
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
   a:	7f 92       	push	r7
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  uint32_t volumeStartBlock = 0;
  sdCard_ = dev;
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
  24:	cd b7       	in	r28, 0x3d	; 61
  26:	de b7       	in	r29, 0x3e	; 62
  28:	2f 97       	sbiw	r28, 0x0f	; 15
    if (part > 4)return false;
  2a:	0f b6       	in	r0, 0x3f	; 63
  2c:	f8 94       	cli
  2e:	de bf       	out	0x3e, r29	; 62
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
  }
  return true;
}
  30:	0f be       	out	0x3f, r0	; 63
  32:	cd bf       	out	0x3d, r28	; 61
  34:	3c 01       	movw	r6, r24
  36:	48 87       	std	Y+8, r20	; 0x08
  38:	59 87       	std	Y+9, r21	; 0x09
  3a:	6a 87       	std	Y+10, r22	; 0x0a
  3c:	7b 87       	std	Y+11, r23	; 0x0b
  3e:	3f 83       	std	Y+7, r19	; 0x07
  40:	2e 83       	std	Y+6, r18	; 0x06
  42:	d9 01       	movw	r26, r18
  44:	cd 90       	ld	r12, X+
  46:	dd 90       	ld	r13, X+
  48:	ed 90       	ld	r14, X+
  sdCard_ = dev;
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  4a:	fc 90       	ld	r15, X
  4c:	c1 14       	cp	r12, r1
  4e:	d1 04       	cpc	r13, r1
  50:	e1 04       	cpc	r14, r1
  52:	f1 04       	cpc	r15, r1
  54:	01 f0       	breq	.+0      	; 0x56 <_ZN8SdVolume15allocContiguousEmPm+0x56>
  56:	bf ef       	ldi	r27, 0xFF	; 255
  58:	cb 1a       	sub	r12, r27
    part_t* p = &cacheBuffer_.mbr.part[part-1];
  5a:	db 0a       	sbc	r13, r27
  5c:	eb 0a       	sbc	r14, r27
  5e:	fb 0a       	sbc	r15, r27
  60:	1d 82       	std	Y+5, r1	; 0x05
    if ((p->boot & 0X7F) !=0  ||
  62:	00 c0       	rjmp	.+0      	; 0x64 <_ZN8SdVolume15allocContiguousEmPm+0x64>
  64:	fc 01       	movw	r30, r24
  66:	c0 80       	ld	r12, Z
  68:	d1 80       	ldd	r13, Z+1	; 0x01
  6a:	e2 80       	ldd	r14, Z+2	; 0x02
  6c:	f3 80       	ldd	r15, Z+3	; 0x03
  6e:	f1 e0       	ldi	r31, 0x01	; 1
  70:	fd 83       	std	Y+5, r31	; 0x05
  72:	08 85       	ldd	r16, Y+8	; 0x08
  74:	19 85       	ldd	r17, Y+9	; 0x09
  76:	2a 85       	ldd	r18, Y+10	; 0x0a
  78:	3b 85       	ldd	r19, Y+11	; 0x0b
  7a:	01 30       	cpi	r16, 0x01	; 1
      p->totalSectors < 100 ||
  7c:	11 05       	cpc	r17, r1
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
    part_t* p = &cacheBuffer_.mbr.part[part-1];
    if ((p->boot & 0X7F) !=0  ||
  7e:	21 05       	cpc	r18, r1
  80:	31 05       	cpc	r19, r1
  82:	01 f4       	brne	.+0      	; 0x84 <_ZN8SdVolume15allocContiguousEmPm+0x84>
  84:	f3 01       	movw	r30, r6
  86:	81 85       	ldd	r24, Z+9	; 0x09
  88:	92 85       	ldd	r25, Z+10	; 0x0a
  8a:	a3 85       	ldd	r26, Z+11	; 0x0b
  8c:	b4 85       	ldd	r27, Z+12	; 0x0c
  8e:	8c 01       	movw	r16, r24
      p->totalSectors < 100 ||
      p->firstSector == 0) {
  90:	9d 01       	movw	r18, r26
  92:	0f 5f       	subi	r16, 0xFF	; 255
  94:	1f 4f       	sbci	r17, 0xFF	; 255
  96:	2f 4f       	sbci	r18, 0xFF	; 255
  98:	3f 4f       	sbci	r19, 0xFF	; 255
  9a:	0c 87       	std	Y+12, r16	; 0x0c
  9c:	1d 87       	std	Y+13, r17	; 0x0d
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
    part_t* p = &cacheBuffer_.mbr.part[part-1];
    if ((p->boot & 0X7F) !=0  ||
      p->totalSectors < 100 ||
  9e:	2e 87       	std	Y+14, r18	; 0x0e
  a0:	3f 87       	std	Y+15, r19	; 0x0f
  a2:	46 01       	movw	r8, r12
  a4:	57 01       	movw	r10, r14
  a6:	21 2c       	mov	r2, r1
      // not a valid partition
      return false;
    }
    volumeStartBlock = p->firstSector;
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  a8:	31 2c       	mov	r3, r1
  aa:	21 01       	movw	r4, r2
  ac:	f3 01       	movw	r30, r6
  ae:	81 85       	ldd	r24, Z+9	; 0x09
  b0:	92 85       	ldd	r25, Z+10	; 0x0a
  b2:	a3 85       	ldd	r26, Z+11	; 0x0b
  b4:	b4 85       	ldd	r27, Z+12	; 0x0c
  b6:	28 16       	cp	r2, r24
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
  b8:	39 06       	cpc	r3, r25
  ba:	4a 06       	cpc	r4, r26
  bc:	5b 06       	cpc	r5, r27
  be:	00 f0       	brcs	.+0      	; 0xc0 <_ZN8SdVolume15allocContiguousEmPm+0xc0>
  c0:	00 c0       	rjmp	.+0      	; 0xc2 <_ZN8SdVolume15allocContiguousEmPm+0xc2>
  c2:	0c 85       	ldd	r16, Y+12	; 0x0c
  c4:	1d 85       	ldd	r17, Y+13	; 0x0d
  c6:	2e 85       	ldd	r18, Y+14	; 0x0e
    bpb->fatCount == 0 ||
  c8:	3f 85       	ldd	r19, Y+15	; 0x0f
  ca:	08 15       	cp	r16, r8
    }
    volumeStartBlock = p->firstSector;
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
  cc:	19 05       	cpc	r17, r9
  ce:	2a 05       	cpc	r18, r10
  d0:	3b 05       	cpc	r19, r11
    bpb->fatCount == 0 ||
  d2:	00 f4       	brcc	.+0      	; 0xd4 <_ZN8SdVolume15allocContiguousEmPm+0xd4>
  d4:	82 e0       	ldi	r24, 0x02	; 2
  d6:	88 2e       	mov	r8, r24
  d8:	91 2c       	mov	r9, r1
  da:	a1 2c       	mov	r10, r1
  dc:	b1 2c       	mov	r11, r1
  de:	92 e0       	ldi	r25, 0x02	; 2
    bpb->reservedSectorCount == 0 ||
    bpb->sectorsPerCluster == 0) {
  e0:	c9 2e       	mov	r12, r25
  e2:	d1 2c       	mov	r13, r1
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
    bpb->fatCount == 0 ||
    bpb->reservedSectorCount == 0 ||
  e4:	e1 2c       	mov	r14, r1
  e6:	f1 2c       	mov	r15, r1
  e8:	9e 01       	movw	r18, r28
    bpb->sectorsPerCluster == 0) {
       // not valid FAT volume
      return false;
  }
  fatCount_ = bpb->fatCount;
  ea:	2f 5f       	subi	r18, 0xFF	; 255
  blocksPerCluster_ = bpb->sectorsPerCluster;
  ec:	3f 4f       	sbci	r19, 0xFF	; 255

  // determine shift that is same as multiply by blocksPerCluster_
  clusterSizeShift_ = 0;
  ee:	b5 01       	movw	r22, r10
  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
  f0:	a4 01       	movw	r20, r8
  f2:	c3 01       	movw	r24, r6
  f4:	0e 94 00 00 	call	0	; 0x0 <_ZN8SdVolume15allocContiguousEmPm>
  f8:	88 23       	and	r24, r24
  fa:	01 f0       	breq	.+0      	; 0xfc <_ZN8SdVolume15allocContiguousEmPm+0xfc>
  fc:	d5 01       	movw	r26, r10
  fe:	c4 01       	movw	r24, r8
 100:	01 96       	adiw	r24, 0x01	; 1
 102:	a1 1d       	adc	r26, r1
 104:	b1 1d       	adc	r27, r1
 106:	49 81       	ldd	r20, Y+1	; 0x01
 108:	5a 81       	ldd	r21, Y+2	; 0x02
 10a:	6b 81       	ldd	r22, Y+3	; 0x03
 10c:	7c 81       	ldd	r23, Y+4	; 0x04
    // error if not power of 2
    if (clusterSizeShift_++ > 7) return false;
 10e:	45 2b       	or	r20, r21
 110:	46 2b       	or	r20, r22
 112:	47 2b       	or	r20, r23
 114:	01 f4       	brne	.+0      	; 0x116 <_ZN8SdVolume15allocContiguousEmPm+0x116>
 116:	ac 01       	movw	r20, r24
 118:	bd 01       	movw	r22, r26
 * the value zero, false, is returned for failure.  Reasons for
 * failure include not finding a valid partition, not finding a valid
 * FAT file system in the specified partition or an I/O error.
 */
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
  uint32_t volumeStartBlock = 0;
 11a:	4c 19       	sub	r20, r12
 11c:	5d 09       	sbc	r21, r13
 11e:	6e 09       	sbc	r22, r14
 120:	7f 09       	sbc	r23, r15
  clusterSizeShift_ = 0;
  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
    // error if not power of 2
    if (clusterSizeShift_++ > 7) return false;
  }
  blocksPerFat_ = bpb->sectorsPerFat16 ?
 122:	08 85       	ldd	r16, Y+8	; 0x08
 124:	19 85       	ldd	r17, Y+9	; 0x09
 126:	2a 85       	ldd	r18, Y+10	; 0x0a
 128:	3b 85       	ldd	r19, Y+11	; 0x0b
 12a:	40 17       	cp	r20, r16
 12c:	51 07       	cpc	r21, r17
 12e:	62 07       	cpc	r22, r18
 130:	73 07       	cpc	r23, r19
 132:	01 f4       	brne	.+0      	; 0x134 <_ZN8SdVolume15allocContiguousEmPm+0x134>
 134:	0f ef       	ldi	r16, 0xFF	; 255
 136:	1f ef       	ldi	r17, 0xFF	; 255
 138:	2f ef       	ldi	r18, 0xFF	; 255
 13a:	3f e0       	ldi	r19, 0x0F	; 15
 13c:	b5 01       	movw	r22, r10
 13e:	a4 01       	movw	r20, r8
 140:	c3 01       	movw	r24, r6
 142:	0e 94 00 00 	call	0	; 0x0 <_ZN8SdVolume15allocContiguousEmPm>
 146:	81 11       	cpse	r24, r1
 148:	00 c0       	rjmp	.+0      	; 0x14a <_ZN8SdVolume15allocContiguousEmPm+0x14a>
 14a:	1d 82       	std	Y+5, r1	; 0x05
                    bpb->sectorsPerFat16 : bpb->sectorsPerFat32;

  fatStartBlock_ = volumeStartBlock + bpb->reservedSectorCount;
 14c:	8d 81       	ldd	r24, Y+5	; 0x05
 14e:	2f 96       	adiw	r28, 0x0f	; 15
 150:	0f b6       	in	r0, 0x3f	; 63
 152:	f8 94       	cli
 154:	de bf       	out	0x3e, r29	; 62
 156:	0f be       	out	0x3f, r0	; 63
 158:	cd bf       	out	0x3d, r28	; 61
 15a:	df 91       	pop	r29
 15c:	cf 91       	pop	r28
 15e:	1f 91       	pop	r17
 160:	0f 91       	pop	r16
 162:	ff 90       	pop	r15
 164:	ef 90       	pop	r14
 166:	df 90       	pop	r13

  // count for FAT16 zero for FAT32
  rootDirEntryCount_ = bpb->rootDirEntryCount;
 168:	cf 90       	pop	r12
 16a:	bf 90       	pop	r11
 16c:	af 90       	pop	r10
 16e:	9f 90       	pop	r9
 170:	8f 90       	pop	r8
 172:	7f 90       	pop	r7

  // directory start for FAT16 dataStart for FAT32
  rootDirStart_ = fatStartBlock_ + bpb->fatCount * blocksPerFat_;
 174:	6f 90       	pop	r6
 176:	5f 90       	pop	r5
 178:	4f 90       	pop	r4
 17a:	3f 90       	pop	r3
 17c:	2f 90       	pop	r2
 17e:	08 95       	ret
 180:	6c 01       	movw	r12, r24
 182:	7d 01       	movw	r14, r26
 184:	1f ef       	ldi	r17, 0xFF	; 255
 186:	21 1a       	sub	r2, r17
 188:	31 0a       	sbc	r3, r17
 18a:	41 0a       	sbc	r4, r17
 18c:	51 0a       	sbc	r5, r17
 18e:	4c 01       	movw	r8, r24
 190:	5d 01       	movw	r10, r26

  // data start for FAT16 and FAT32
  dataStartBlock_ = rootDirStart_ + ((32 * bpb->rootDirEntryCount + 511)/512);
 192:	00 c0       	rjmp	.+0      	; 0x194 <_ZN8SdVolume15allocContiguousEmPm+0x194>
 194:	c8 14       	cp	r12, r8
 196:	d9 04       	cpc	r13, r9
 198:	ea 04       	cpc	r14, r10
 19a:	fb 04       	cpc	r15, r11
 19c:	00 f4       	brcc	.+0      	; 0x19e <_ZN8SdVolume15allocContiguousEmPm+0x19e>
 19e:	14 01       	movw	r2, r8
 1a0:	25 01       	movw	r4, r10
 1a2:	21 e0       	ldi	r18, 0x01	; 1
 1a4:	22 1a       	sub	r2, r18
 1a6:	31 08       	sbc	r3, r1
 1a8:	41 08       	sbc	r4, r1
 1aa:	51 08       	sbc	r5, r1
 1ac:	95 01       	movw	r18, r10
 1ae:	84 01       	movw	r16, r8
 1b0:	b2 01       	movw	r22, r4
 1b2:	a1 01       	movw	r20, r2
 1b4:	c3 01       	movw	r24, r6

  // total blocks for FAT16 or FAT32
  uint32_t totalBlocks = bpb->totalSectors16 ?
 1b6:	0e 94 00 00 	call	0	; 0x0 <_ZN8SdVolume15allocContiguousEmPm>
 1ba:	52 01       	movw	r10, r4
 1bc:	41 01       	movw	r8, r2
 1be:	00 c0       	rjmp	.+0      	; 0x1c0 <_ZN8SdVolume15allocContiguousEmPm+0x1c0>
 1c0:	ae 81       	ldd	r26, Y+6	; 0x06
 1c2:	bf 81       	ldd	r27, Y+7	; 0x07
 1c4:	4d 91       	ld	r20, X+
 1c6:	5d 91       	ld	r21, X+
 1c8:	6d 91       	ld	r22, X+
 1ca:	7c 91       	ld	r23, X
 1cc:	41 15       	cp	r20, r1
 1ce:	51 05       	cpc	r21, r1
 1d0:	61 05       	cpc	r22, r1
 1d2:	71 05       	cpc	r23, r1
 1d4:	01 f4       	brne	.+0      	; 0x1d6 <_ZN8SdVolume15allocContiguousEmPm+0x1d6>
 1d6:	ee 81       	ldd	r30, Y+6	; 0x06
                           bpb->totalSectors16 : bpb->totalSectors32;
  // total data blocks
  clusterCount_ = totalBlocks - (dataStartBlock_ - volumeStartBlock);
 1d8:	ff 81       	ldd	r31, Y+7	; 0x07
 1da:	c0 82       	st	Z, r12
 1dc:	d1 82       	std	Z+1, r13	; 0x01
 1de:	e2 82       	std	Z+2, r14	; 0x02
 1e0:	f3 82       	std	Z+3, r15	; 0x03
 1e2:	fd 81       	ldd	r31, Y+5	; 0x05
 1e4:	f1 11       	cpse	r31, r1
 1e6:	00 c0       	rjmp	.+0      	; 0x1e8 <_ZN8SdVolume15allocContiguousEmPm+0x1e8>

  // divide by cluster size to get cluster count
  clusterCount_ >>= clusterSizeShift_;
 1e8:	01 e0       	ldi	r16, 0x01	; 1
 1ea:	0d 83       	std	Y+5, r16	; 0x05
 1ec:	00 c0       	rjmp	.+0      	; 0x1ee <_ZN8SdVolume15allocContiguousEmPm+0x1ee>
 1ee:	97 01       	movw	r18, r14
 1f0:	86 01       	movw	r16, r12
 1f2:	c3 01       	movw	r24, r6
 1f4:	0e 94 00 00 	call	0	; 0x0 <_ZN8SdVolume15allocContiguousEmPm>
 1f8:	81 11       	cpse	r24, r1
 1fa:	00 c0       	rjmp	.+0      	; 0x1fc <_ZN8SdVolume15allocContiguousEmPm+0x1fc>
 1fc:	00 c0       	rjmp	.+0      	; 0x1fe <_ZN8SdVolume15allocContiguousEmPm+0x1fe>

  // FAT type is determined by cluster count
  if (clusterCount_ < 4085) {
    fatType_ = 12;
 1fe:	1f ef       	ldi	r17, 0xFF	; 255

  // divide by cluster size to get cluster count
  clusterCount_ >>= clusterSizeShift_;

  // FAT type is determined by cluster count
  if (clusterCount_ < 4085) {
 200:	c1 1a       	sub	r12, r17
 202:	d1 0a       	sbc	r13, r17
 204:	e1 0a       	sbc	r14, r17
 206:	f1 0a       	sbc	r15, r17
 208:	d3 01       	movw	r26, r6
 20a:	cd 92       	st	X+, r12
 20c:	dd 92       	st	X+, r13
    fatType_ = 12;
  } else if (clusterCount_ < 65525) {
 20e:	ed 92       	st	X+, r14
 210:	fc 92       	st	X, r15
 212:	13 97       	sbiw	r26, 0x03	; 3
 214:	00 c0       	rjmp	.+0      	; 0x216 <__SREG__+0x1d7>

Disassembly of section .text._ZN8SdVolume9freeChainEm:

00000000 <_ZN8SdVolume9freeChainEm>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.  Reasons for
 * failure include not finding a valid partition, not finding a valid
 * FAT file system in the specified partition or an I/O error.
 */
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
   0:	af 92       	push	r10
   2:	bf 92       	push	r11
   4:	cf 92       	push	r12
   6:	df 92       	push	r13
   8:	ef 92       	push	r14
   a:	ff 92       	push	r15
   c:	0f 93       	push	r16
   e:	1f 93       	push	r17
  10:	cf 93       	push	r28
  12:	df 93       	push	r29
  14:	00 d0       	rcall	.+0      	; 0x16 <_ZN8SdVolume9freeChainEm+0x16>
  16:	00 d0       	rcall	.+0      	; 0x18 <_ZN8SdVolume9freeChainEm+0x18>
  18:	cd b7       	in	r28, 0x3d	; 61
  1a:	de b7       	in	r29, 0x3e	; 62
  uint32_t volumeStartBlock = 0;
  sdCard_ = dev;
  1c:	5c 01       	movw	r10, r24
  1e:	6a 01       	movw	r12, r20
  20:	7b 01       	movw	r14, r22
  22:	82 e0       	ldi	r24, 0x02	; 2
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
  24:	90 e0       	ldi	r25, 0x00	; 0
  26:	a0 e0       	ldi	r26, 0x00	; 0
  28:	b0 e0       	ldi	r27, 0x00	; 0
    if (part > 4)return false;
  2a:	f5 01       	movw	r30, r10
  2c:	80 83       	st	Z, r24
  2e:	91 83       	std	Z+1, r25	; 0x01
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
  }
  return true;
}
  30:	a2 83       	std	Z+2, r26	; 0x02
  32:	b3 83       	std	Z+3, r27	; 0x03
  34:	9e 01       	movw	r18, r28
  36:	2f 5f       	subi	r18, 0xFF	; 255
  38:	3f 4f       	sbci	r19, 0xFF	; 255
  3a:	b7 01       	movw	r22, r14
  3c:	a6 01       	movw	r20, r12
  3e:	c5 01       	movw	r24, r10
  40:	0e 94 00 00 	call	0	; 0x0 <_ZN8SdVolume9freeChainEm>
  44:	88 23       	and	r24, r24
  46:	01 f0       	breq	.+0      	; 0x48 <_ZN8SdVolume9freeChainEm+0x48>
  48:	00 e0       	ldi	r16, 0x00	; 0
  sdCard_ = dev;
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  4a:	10 e0       	ldi	r17, 0x00	; 0
  4c:	98 01       	movw	r18, r16
  4e:	b7 01       	movw	r22, r14
  50:	a6 01       	movw	r20, r12
  52:	c5 01       	movw	r24, r10
  54:	0e 94 00 00 	call	0	; 0x0 <_ZN8SdVolume9freeChainEm>
  58:	88 23       	and	r24, r24
    part_t* p = &cacheBuffer_.mbr.part[part-1];
  5a:	01 f0       	breq	.+0      	; 0x5c <_ZN8SdVolume9freeChainEm+0x5c>
  5c:	c9 80       	ldd	r12, Y+1	; 0x01
  5e:	da 80       	ldd	r13, Y+2	; 0x02
  60:	eb 80       	ldd	r14, Y+3	; 0x03
    if ((p->boot & 0X7F) !=0  ||
  62:	fc 80       	ldd	r15, Y+4	; 0x04
  64:	f5 01       	movw	r30, r10
  66:	87 89       	ldd	r24, Z+23	; 0x17
  68:	80 31       	cpi	r24, 0x10	; 16
  6a:	01 f0       	breq	.+0      	; 0x6c <_ZN8SdVolume9freeChainEm+0x6c>
  6c:	88 ef       	ldi	r24, 0xF8	; 248
  6e:	9f ef       	ldi	r25, 0xFF	; 255
  70:	af ef       	ldi	r26, 0xFF	; 255
  72:	bf e0       	ldi	r27, 0x0F	; 15
  74:	c8 16       	cp	r12, r24
  76:	d9 06       	cpc	r13, r25
  78:	ea 06       	cpc	r14, r26
  7a:	fb 06       	cpc	r15, r27
      p->totalSectors < 100 ||
  7c:	00 f0       	brcs	.+0      	; 0x7e <_ZN8SdVolume9freeChainEm+0x7e>
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
    part_t* p = &cacheBuffer_.mbr.part[part-1];
    if ((p->boot & 0X7F) !=0  ||
  7e:	81 e0       	ldi	r24, 0x01	; 1
  80:	0f 90       	pop	r0
  82:	0f 90       	pop	r0
  84:	0f 90       	pop	r0
  86:	0f 90       	pop	r0
  88:	df 91       	pop	r29
  8a:	cf 91       	pop	r28
  8c:	1f 91       	pop	r17
  8e:	0f 91       	pop	r16
      p->totalSectors < 100 ||
      p->firstSector == 0) {
  90:	ff 90       	pop	r15
  92:	ef 90       	pop	r14
  94:	df 90       	pop	r13
  96:	cf 90       	pop	r12
  98:	bf 90       	pop	r11
  9a:	af 90       	pop	r10
  9c:	08 95       	ret
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
    part_t* p = &cacheBuffer_.mbr.part[part-1];
    if ((p->boot & 0X7F) !=0  ||
      p->totalSectors < 100 ||
  9e:	88 ef       	ldi	r24, 0xF8	; 248
  a0:	9f ef       	ldi	r25, 0xFF	; 255
  a2:	a0 e0       	ldi	r26, 0x00	; 0
  a4:	b0 e0       	ldi	r27, 0x00	; 0
  a6:	00 c0       	rjmp	.+0      	; 0xa8 <_ZN8SdVolume9freeChainEm+0xa8>
      // not a valid partition
      return false;
    }
    volumeStartBlock = p->firstSector;
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  a8:	80 e0       	ldi	r24, 0x00	; 0
  aa:	00 c0       	rjmp	.+0      	; 0xac <__SREG__+0x6d>

Disassembly of section .text._ZN8SdVolume4initEP7Sd2Cardh:

00000000 <_ZN8SdVolume4initEP7Sd2Cardh>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.  Reasons for
 * failure include not finding a valid partition, not finding a valid
 * FAT file system in the specified partition or an I/O error.
 */
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
   6:	bf 92       	push	r11
   8:	cf 92       	push	r12
   a:	df 92       	push	r13
   c:	ef 92       	push	r14
   e:	ff 92       	push	r15
  10:	0f 93       	push	r16
  12:	1f 93       	push	r17
  14:	cf 93       	push	r28
  16:	df 93       	push	r29
  18:	ec 01       	movw	r28, r24
  1a:	14 2f       	mov	r17, r20
  uint32_t volumeStartBlock = 0;
  sdCard_ = dev;
  1c:	70 93 00 00 	sts	0x0000, r23	; 0x800000 <__SREG__+0x7fffc1>
  20:	60 93 00 00 	sts	0x0000, r22	; 0x800000 <__SREG__+0x7fffc1>
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
  24:	44 23       	and	r20, r20
  26:	01 f4       	brne	.+0      	; 0x28 <_ZN8SdVolume4initEP7Sd2Cardh+0x28>
  28:	00 c0       	rjmp	.+0      	; 0x2a <_ZN8SdVolume4initEP7Sd2Cardh+0x2a>
    if (part > 4)return false;
  2a:	45 30       	cpi	r20, 0x05	; 5
  2c:	00 f0       	brcs	.+0      	; 0x2e <_ZN8SdVolume4initEP7Sd2Cardh+0x2e>
  2e:	80 e0       	ldi	r24, 0x00	; 0
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
  }
  return true;
}
  30:	df 91       	pop	r29
  32:	cf 91       	pop	r28
  34:	1f 91       	pop	r17
  36:	0f 91       	pop	r16
  38:	ff 90       	pop	r15
  3a:	ef 90       	pop	r14
  3c:	df 90       	pop	r13
  3e:	cf 90       	pop	r12
  40:	bf 90       	pop	r11
  42:	af 90       	pop	r10
  44:	9f 90       	pop	r9
  46:	8f 90       	pop	r8
  48:	08 95       	ret
  sdCard_ = dev;
  // if part == 0 assume super floppy with FAT boot sector in block zero
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  4a:	40 e0       	ldi	r20, 0x00	; 0
  4c:	60 e0       	ldi	r22, 0x00	; 0
  4e:	70 e0       	ldi	r23, 0x00	; 0
  50:	cb 01       	movw	r24, r22
  52:	0e 94 00 00 	call	0	; 0x0 <_ZN8SdVolume4initEP7Sd2Cardh>
  56:	88 23       	and	r24, r24
  58:	01 f0       	breq	.+0      	; 0x5a <_ZN8SdVolume4initEP7Sd2Cardh+0x5a>
    part_t* p = &cacheBuffer_.mbr.part[part-1];
  5a:	81 2f       	mov	r24, r17
  5c:	81 50       	subi	r24, 0x01	; 1
  5e:	99 0b       	sbc	r25, r25
  60:	ac 01       	movw	r20, r24
    if ((p->boot & 0X7F) !=0  ||
  62:	64 e0       	ldi	r22, 0x04	; 4
  64:	44 0f       	add	r20, r20
  66:	55 1f       	adc	r21, r21
  68:	6a 95       	dec	r22
  6a:	01 f4       	brne	.+0      	; 0x6c <_ZN8SdVolume4initEP7Sd2Cardh+0x6c>
  6c:	40 50       	subi	r20, 0x00	; 0
  6e:	50 40       	sbci	r21, 0x00	; 0
  70:	fa 01       	movw	r30, r20
  72:	e2 54       	subi	r30, 0x42	; 66
  74:	fe 4f       	sbci	r31, 0xFE	; 254
  76:	80 81       	ld	r24, Z
  78:	8f 77       	andi	r24, 0x7F	; 127
  7a:	01 f4       	brne	.+0      	; 0x7c <_ZN8SdVolume4initEP7Sd2Cardh+0x7c>
      p->totalSectors < 100 ||
  7c:	3c 96       	adiw	r30, 0x0c	; 12
  // if part > 0 assume mbr volume with partition table
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
    part_t* p = &cacheBuffer_.mbr.part[part-1];
    if ((p->boot & 0X7F) !=0  ||
  7e:	80 81       	ld	r24, Z
  80:	91 81       	ldd	r25, Z+1	; 0x01
  82:	a2 81       	ldd	r26, Z+2	; 0x02
  84:	b3 81       	ldd	r27, Z+3	; 0x03
  86:	84 36       	cpi	r24, 0x64	; 100
  88:	91 05       	cpc	r25, r1
  8a:	a1 05       	cpc	r26, r1
  8c:	b1 05       	cpc	r27, r1
  8e:	00 f0       	brcs	.+0      	; 0x90 <_ZN8SdVolume4initEP7Sd2Cardh+0x90>
      p->totalSectors < 100 ||
      p->firstSector == 0) {
  90:	4a 53       	subi	r20, 0x3A	; 58
  92:	5e 4f       	sbci	r21, 0xFE	; 254
  94:	fa 01       	movw	r30, r20
  96:	c0 80       	ld	r12, Z
  98:	d1 80       	ldd	r13, Z+1	; 0x01
  9a:	e2 80       	ldd	r14, Z+2	; 0x02
  9c:	f3 80       	ldd	r15, Z+3	; 0x03
  if (part) {
    if (part > 4)return false;
    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
    part_t* p = &cacheBuffer_.mbr.part[part-1];
    if ((p->boot & 0X7F) !=0  ||
      p->totalSectors < 100 ||
  9e:	c1 14       	cp	r12, r1
  a0:	d1 04       	cpc	r13, r1
  a2:	e1 04       	cpc	r14, r1
  a4:	f1 04       	cpc	r15, r1
  a6:	01 f0       	breq	.+0      	; 0xa8 <_ZN8SdVolume4initEP7Sd2Cardh+0xa8>
      // not a valid partition
      return false;
    }
    volumeStartBlock = p->firstSector;
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  a8:	40 e0       	ldi	r20, 0x00	; 0
  aa:	c7 01       	movw	r24, r14
  ac:	b6 01       	movw	r22, r12
  ae:	0e 94 00 00 	call	0	; 0x0 <_ZN8SdVolume4initEP7Sd2Cardh>
  b2:	88 23       	and	r24, r24
  b4:	01 f4       	brne	.+0      	; 0xb6 <_ZN8SdVolume4initEP7Sd2Cardh+0xb6>
  b6:	00 c0       	rjmp	.+0      	; 0xb8 <_ZN8SdVolume4initEP7Sd2Cardh+0xb8>
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
  b8:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  bc:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  c0:	81 15       	cp	r24, r1
  c2:	92 40       	sbci	r25, 0x02	; 2
  c4:	01 f0       	breq	.+0      	; 0xc6 <_ZN8SdVolume4initEP7Sd2Cardh+0xc6>
  c6:	00 c0       	rjmp	.+0      	; 0xc8 <_ZN8SdVolume4initEP7Sd2Cardh+0xc8>
    bpb->fatCount == 0 ||
  c8:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    volumeStartBlock = p->firstSector;
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
  cc:	99 23       	and	r25, r25
  ce:	01 f4       	brne	.+0      	; 0xd0 <_ZN8SdVolume4initEP7Sd2Cardh+0xd0>
  d0:	00 c0       	rjmp	.+0      	; 0xd2 <_ZN8SdVolume4initEP7Sd2Cardh+0xd2>
    bpb->fatCount == 0 ||
  d2:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  d6:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  da:	23 2b       	or	r18, r19
  dc:	01 f4       	brne	.+0      	; 0xde <_ZN8SdVolume4initEP7Sd2Cardh+0xde>
  de:	00 c0       	rjmp	.+0      	; 0xe0 <_ZN8SdVolume4initEP7Sd2Cardh+0xe0>
    bpb->reservedSectorCount == 0 ||
    bpb->sectorsPerCluster == 0) {
  e0:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  }
  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
  bpb_t* bpb = &cacheBuffer_.fbs.bpb;
  if (bpb->bytesPerSector != 512 ||
    bpb->fatCount == 0 ||
    bpb->reservedSectorCount == 0 ||
  e4:	88 23       	and	r24, r24
  e6:	01 f4       	brne	.+0      	; 0xe8 <_ZN8SdVolume4initEP7Sd2Cardh+0xe8>
  e8:	00 c0       	rjmp	.+0      	; 0xea <_ZN8SdVolume4initEP7Sd2Cardh+0xea>
    bpb->sectorsPerCluster == 0) {
       // not valid FAT volume
      return false;
  }
  fatCount_ = bpb->fatCount;
  ea:	9a 8b       	std	Y+18, r25	; 0x12
  blocksPerCluster_ = bpb->sectorsPerCluster;
  ec:	8c 83       	std	Y+4, r24	; 0x04

  // determine shift that is same as multiply by blocksPerCluster_
  clusterSizeShift_ = 0;
  ee:	1d 86       	std	Y+13, r1	; 0x0d
  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
  f0:	90 e0       	ldi	r25, 0x00	; 0
  f2:	41 e0       	ldi	r20, 0x01	; 1
  f4:	50 e0       	ldi	r21, 0x00	; 0
  f6:	2d 85       	ldd	r18, Y+13	; 0x0d
  f8:	e2 2f       	mov	r30, r18
  fa:	ba 01       	movw	r22, r20
  fc:	02 2e       	mov	r0, r18
  fe:	00 c0       	rjmp	.+0      	; 0x100 <_ZN8SdVolume4initEP7Sd2Cardh+0x100>
 100:	66 0f       	add	r22, r22
 102:	77 1f       	adc	r23, r23
 104:	0a 94       	dec	r0
 106:	02 f4       	brpl	.+0      	; 0x108 <_ZN8SdVolume4initEP7Sd2Cardh+0x108>
 108:	86 17       	cp	r24, r22
 10a:	97 07       	cpc	r25, r23
 10c:	01 f0       	breq	.+0      	; 0x10e <_ZN8SdVolume4initEP7Sd2Cardh+0x10e>
    // error if not power of 2
    if (clusterSizeShift_++ > 7) return false;
 10e:	31 e0       	ldi	r19, 0x01	; 1
 110:	32 0f       	add	r19, r18
 112:	3d 87       	std	Y+13, r19	; 0x0d
 114:	28 30       	cpi	r18, 0x08	; 8
 116:	00 f0       	brcs	.+0      	; 0x118 <_ZN8SdVolume4initEP7Sd2Cardh+0x118>
 118:	00 c0       	rjmp	.+0      	; 0x11a <_ZN8SdVolume4initEP7Sd2Cardh+0x11a>
 * the value zero, false, is returned for failure.  Reasons for
 * failure include not finding a valid partition, not finding a valid
 * FAT file system in the specified partition or an I/O error.
 */
uint8_t SdVolume::init(Sd2Card* dev, uint8_t part) {
  uint32_t volumeStartBlock = 0;
 11a:	c1 2c       	mov	r12, r1
 11c:	d1 2c       	mov	r13, r1
 11e:	76 01       	movw	r14, r12
 120:	00 c0       	rjmp	.+0      	; 0x122 <_ZN8SdVolume4initEP7Sd2Cardh+0x122>
  clusterSizeShift_ = 0;
  while (blocksPerCluster_ != (1 << clusterSizeShift_)) {
    // error if not power of 2
    if (clusterSizeShift_++ > 7) return false;
  }
  blocksPerFat_ = bpb->sectorsPerFat16 ?
 122:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 126:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 12a:	50 e0       	ldi	r21, 0x00	; 0
 12c:	40 e0       	ldi	r20, 0x00	; 0
 12e:	21 15       	cp	r18, r1
 130:	31 05       	cpc	r19, r1
 132:	01 f4       	brne	.+0      	; 0x134 <_ZN8SdVolume4initEP7Sd2Cardh+0x134>
 134:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 138:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 13c:	40 91 00 00 	lds	r20, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 140:	50 91 00 00 	lds	r21, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 144:	2d 83       	std	Y+5, r18	; 0x05
 146:	3e 83       	std	Y+6, r19	; 0x06
 148:	4f 83       	std	Y+7, r20	; 0x07
 14a:	58 87       	std	Y+8, r21	; 0x08
                    bpb->sectorsPerFat16 : bpb->sectorsPerFat32;

  fatStartBlock_ = volumeStartBlock + bpb->reservedSectorCount;
 14c:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 150:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 154:	46 01       	movw	r8, r12
 156:	57 01       	movw	r10, r14
 158:	88 0e       	add	r8, r24
 15a:	99 1e       	adc	r9, r25
 15c:	a1 1c       	adc	r10, r1
 15e:	b1 1c       	adc	r11, r1
 160:	8b 8a       	std	Y+19, r8	; 0x13
 162:	9c 8a       	std	Y+20, r9	; 0x14
 164:	ad 8a       	std	Y+21, r10	; 0x15
 166:	be 8a       	std	Y+22, r11	; 0x16

  // count for FAT16 zero for FAT32
  rootDirEntryCount_ = bpb->rootDirEntryCount;
 168:	00 91 00 00 	lds	r16, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 16c:	10 91 00 00 	lds	r17, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 170:	19 8f       	std	Y+25, r17	; 0x19
 172:	08 8f       	std	Y+24, r16	; 0x18

  // directory start for FAT16 dataStart for FAT32
  rootDirStart_ = fatStartBlock_ + bpb->fatCount * blocksPerFat_;
 174:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 178:	b0 e0       	ldi	r27, 0x00	; 0
 17a:	0e 94 00 00 	call	0	; 0x0 <_ZN8SdVolume4initEP7Sd2Cardh>
 17e:	dc 01       	movw	r26, r24
 180:	cb 01       	movw	r24, r22
 182:	88 0d       	add	r24, r8
 184:	99 1d       	adc	r25, r9
 186:	aa 1d       	adc	r26, r10
 188:	bb 1d       	adc	r27, r11
 18a:	8a 8f       	std	Y+26, r24	; 0x1a
 18c:	9b 8f       	std	Y+27, r25	; 0x1b
 18e:	ac 8f       	std	Y+28, r26	; 0x1c
 190:	bd 8f       	std	Y+29, r27	; 0x1d

  // data start for FAT16 and FAT32
  dataStartBlock_ = rootDirStart_ + ((32 * bpb->rootDirEntryCount + 511)/512);
 192:	25 e0       	ldi	r18, 0x05	; 5
 194:	00 0f       	add	r16, r16
 196:	11 1f       	adc	r17, r17
 198:	2a 95       	dec	r18
 19a:	01 f4       	brne	.+0      	; 0x19c <_ZN8SdVolume4initEP7Sd2Cardh+0x19c>
 19c:	01 50       	subi	r16, 0x01	; 1
 19e:	1e 4f       	sbci	r17, 0xFE	; 254
 1a0:	01 2f       	mov	r16, r17
 1a2:	11 27       	eor	r17, r17
 1a4:	06 95       	lsr	r16
 1a6:	80 0f       	add	r24, r16
 1a8:	91 1f       	adc	r25, r17
 1aa:	a1 1d       	adc	r26, r1
 1ac:	b1 1d       	adc	r27, r1
 1ae:	8e 87       	std	Y+14, r24	; 0x0e
 1b0:	9f 87       	std	Y+15, r25	; 0x0f
 1b2:	a8 8b       	std	Y+16, r26	; 0x10
 1b4:	b9 8b       	std	Y+17, r27	; 0x11

  // total blocks for FAT16 or FAT32
  uint32_t totalBlocks = bpb->totalSectors16 ?
 1b6:	00 91 00 00 	lds	r16, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1ba:	10 91 00 00 	lds	r17, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1be:	30 e0       	ldi	r19, 0x00	; 0
 1c0:	20 e0       	ldi	r18, 0x00	; 0
 1c2:	01 15       	cp	r16, r1
 1c4:	11 05       	cpc	r17, r1
 1c6:	01 f4       	brne	.+0      	; 0x1c8 <_ZN8SdVolume4initEP7Sd2Cardh+0x1c8>
 1c8:	00 91 00 00 	lds	r16, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1cc:	10 91 00 00 	lds	r17, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1d0:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1d4:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
                           bpb->totalSectors16 : bpb->totalSectors32;
  // total data blocks
  clusterCount_ = totalBlocks - (dataStartBlock_ - volumeStartBlock);
 1d8:	c8 1a       	sub	r12, r24
 1da:	d9 0a       	sbc	r13, r25
 1dc:	ea 0a       	sbc	r14, r26
 1de:	fb 0a       	sbc	r15, r27
 1e0:	c0 0e       	add	r12, r16
 1e2:	d1 1e       	adc	r13, r17
 1e4:	e2 1e       	adc	r14, r18
 1e6:	f3 1e       	adc	r15, r19

  // divide by cluster size to get cluster count
  clusterCount_ >>= clusterSizeShift_;
 1e8:	00 c0       	rjmp	.+0      	; 0x1ea <_ZN8SdVolume4initEP7Sd2Cardh+0x1ea>
 1ea:	f6 94       	lsr	r15
 1ec:	e7 94       	ror	r14
 1ee:	d7 94       	ror	r13
 1f0:	c7 94       	ror	r12
 1f2:	ea 95       	dec	r30
 1f4:	02 f4       	brpl	.+0      	; 0x1f6 <_ZN8SdVolume4initEP7Sd2Cardh+0x1f6>
 1f6:	c9 86       	std	Y+9, r12	; 0x09
 1f8:	da 86       	std	Y+10, r13	; 0x0a
 1fa:	eb 86       	std	Y+11, r14	; 0x0b
 1fc:	fc 86       	std	Y+12, r15	; 0x0c

  // FAT type is determined by cluster count
  if (clusterCount_ < 4085) {
    fatType_ = 12;
 1fe:	8c e0       	ldi	r24, 0x0C	; 12

  // divide by cluster size to get cluster count
  clusterCount_ >>= clusterSizeShift_;

  // FAT type is determined by cluster count
  if (clusterCount_ < 4085) {
 200:	25 ef       	ldi	r18, 0xF5	; 245
 202:	c2 16       	cp	r12, r18
 204:	2f e0       	ldi	r18, 0x0F	; 15
 206:	d2 06       	cpc	r13, r18
 208:	e1 04       	cpc	r14, r1
 20a:	f1 04       	cpc	r15, r1
 20c:	00 f0       	brcs	.+0      	; 0x20e <_ZN8SdVolume4initEP7Sd2Cardh+0x20e>
    fatType_ = 12;
  } else if (clusterCount_ < 65525) {
 20e:	85 ef       	ldi	r24, 0xF5	; 245
 210:	c8 16       	cp	r12, r24
 212:	8f ef       	ldi	r24, 0xFF	; 255
 214:	d8 06       	cpc	r13, r24
 216:	e1 04       	cpc	r14, r1
 218:	f1 04       	cpc	r15, r1
 21a:	00 f4       	brcc	.+0      	; 0x21c <_ZN8SdVolume4initEP7Sd2Cardh+0x21c>
    fatType_ = 16;
 21c:	80 e1       	ldi	r24, 0x10	; 16
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
    fatType_ = 32;
 21e:	8f 8b       	std	Y+23, r24	; 0x17
  }
  return true;
 220:	81 e0       	ldi	r24, 0x01	; 1
 222:	00 c0       	rjmp	.+0      	; 0x224 <_ZN8SdVolume4initEP7Sd2Cardh+0x224>
  if (clusterCount_ < 4085) {
    fatType_ = 12;
  } else if (clusterCount_ < 65525) {
    fatType_ = 16;
  } else {
    rootDirStart_ = bpb->fat32RootCluster;
 224:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 228:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 22c:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 230:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 234:	8a 8f       	std	Y+26, r24	; 0x1a
 236:	9b 8f       	std	Y+27, r25	; 0x1b
 238:	ac 8f       	std	Y+28, r26	; 0x1c
 23a:	bd 8f       	std	Y+29, r27	; 0x1d
    fatType_ = 32;
 23c:	80 e2       	ldi	r24, 0x20	; 32
 23e:	00 c0       	rjmp	.+0      	; 0x240 <__SREG__+0x201>

PID_v1.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000d50  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000014f7  00000000  00000000  00000d84  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text._ZN3PID7ComputeEv 00000244  00000000  00000000  0000227b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text._ZN3PID10SetTuningsEddd 00000178  00000000  00000000  000024bf  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text._ZN3PID13SetSampleTimeEi 00000090  00000000  00000000  00002637  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text._ZN3PID15SetOutputLimitsEdd 00000102  00000000  00000000  000026c7  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text._ZN3PID10InitializeEv 0000008e  00000000  00000000  000027c9  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text._ZN3PID7SetModeEi 0000002c  00000000  00000000  00002857  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text._ZN3PID22SetControllerDirectionEi 00000078  00000000  00000000  00002883  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text._ZN3PIDC2EPdS0_S0_dddi 000000f6  00000000  00000000  000028fb  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text._ZN3PID5GetKpEv 0000000c  00000000  00000000  000029f1  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .text._ZN3PID5GetKiEv 0000000c  00000000  00000000  000029fd  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .text._ZN3PID5GetKdEv 0000000c  00000000  00000000  00002a09  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text._ZN3PID7GetModeEv 00000008  00000000  00000000  00002a15  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .text._ZN3PID12GetDirectionEv 00000008  00000000  00000000  00002a1d  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .comment      00000012  00000000  00000000  00002a25  2**0
                  CONTENTS, READONLY

Disassembly of section .text._ZN3PID7ComputeEv:

00000000 <_ZN3PID7ComputeEv>:
 ******************************************************************************/
double PID::GetKp(){ return  dispKp; }
double PID::GetKi(){ return  dispKi;}
double PID::GetKd(){ return  dispKd;}
int PID::GetMode(){ return  inAuto ? AUTOMATIC : MANUAL;}
int PID::GetDirection(){ return controllerDirection;}
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
   a:	7f 92       	push	r7
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  24:	cd b7       	in	r28, 0x3d	; 61
  26:	de b7       	in	r29, 0x3e	; 62
  28:	2a 97       	sbiw	r28, 0x0a	; 10
  2a:	0f b6       	in	r0, 0x3f	; 63
  2c:	f8 94       	cli
  2e:	de bf       	out	0x3e, r29	; 62
  30:	0f be       	out	0x3f, r0	; 63
  32:	cd bf       	out	0x3d, r28	; 61
  34:	dc 01       	movw	r26, r24
  36:	d6 96       	adiw	r26, 0x36	; 54
  38:	2c 91       	ld	r18, X
  3a:	22 23       	and	r18, r18
  3c:	01 f4       	brne	.+0      	; 0x3e <_ZN3PID7ComputeEv+0x3e>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <_ZN3PID7ComputeEv+0x40>
  40:	9a 87       	std	Y+10, r25	; 0x0a
  42:	89 87       	std	Y+9, r24	; 0x09
  44:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID7ComputeEv>
  48:	6d 83       	std	Y+5, r22	; 0x05
  4a:	7e 83       	std	Y+6, r23	; 0x06
  4c:	8f 83       	std	Y+7, r24	; 0x07
  4e:	98 87       	std	Y+8, r25	; 0x08
  50:	e9 85       	ldd	r30, Y+9	; 0x09
  52:	fa 85       	ldd	r31, Y+10	; 0x0a
  54:	80 a1       	ldd	r24, Z+32	; 0x20
  56:	91 a1       	ldd	r25, Z+33	; 0x21
  58:	2d 81       	ldd	r18, Y+5	; 0x05
  5a:	3e 81       	ldd	r19, Y+6	; 0x06
  5c:	28 1b       	sub	r18, r24
  5e:	39 0b       	sbc	r19, r25
  60:	c9 01       	movw	r24, r18
  62:	24 a5       	ldd	r18, Z+44	; 0x2c
  64:	35 a5       	ldd	r19, Z+45	; 0x2d
  66:	82 17       	cp	r24, r18
  68:	93 07       	cpc	r25, r19
  6a:	04 f4       	brge	.+0      	; 0x6c <_ZN3PID7ComputeEv+0x6c>
  6c:	00 c0       	rjmp	.+0      	; 0x6e <_ZN3PID7ComputeEv+0x6e>
  6e:	02 8c       	ldd	r0, Z+26	; 0x1a
  70:	f3 8d       	ldd	r31, Z+27	; 0x1b
  72:	e0 2d       	mov	r30, r0
  74:	80 80       	ld	r8, Z
  76:	91 80       	ldd	r9, Z+1	; 0x01
  78:	a2 80       	ldd	r10, Z+2	; 0x02
  7a:	b3 80       	ldd	r11, Z+3	; 0x03
  7c:	a9 85       	ldd	r26, Y+9	; 0x09
  7e:	ba 85       	ldd	r27, Y+10	; 0x0a
  80:	5e 96       	adiw	r26, 0x1e	; 30
  82:	ed 91       	ld	r30, X+
  84:	fc 91       	ld	r31, X
  86:	a5 01       	movw	r20, r10
  88:	94 01       	movw	r18, r8
  8a:	60 81       	ld	r22, Z
  8c:	71 81       	ldd	r23, Z+1	; 0x01
  8e:	82 81       	ldd	r24, Z+2	; 0x02
  90:	93 81       	ldd	r25, Z+3	; 0x03
  92:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID7ComputeEv>
  96:	2b 01       	movw	r4, r22
  98:	3c 01       	movw	r6, r24
  9a:	e9 85       	ldd	r30, Y+9	; 0x09
  9c:	fa 85       	ldd	r31, Y+10	; 0x0a
  9e:	20 89       	ldd	r18, Z+16	; 0x10
  a0:	31 89       	ldd	r19, Z+17	; 0x11
  a2:	42 89       	ldd	r20, Z+18	; 0x12
  a4:	53 89       	ldd	r21, Z+19	; 0x13
  a6:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID7ComputeEv>
  aa:	a9 85       	ldd	r26, Y+9	; 0x09
  ac:	ba 85       	ldd	r27, Y+10	; 0x0a
  ae:	94 96       	adiw	r26, 0x24	; 36
  b0:	2d 91       	ld	r18, X+
  b2:	3d 91       	ld	r19, X+
  b4:	4d 91       	ld	r20, X+
  b6:	5c 91       	ld	r21, X
  b8:	97 97       	sbiw	r26, 0x27	; 39
  ba:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID7ComputeEv>
  be:	6b 01       	movw	r12, r22
  c0:	7c 01       	movw	r14, r24
  c2:	e9 85       	ldd	r30, Y+9	; 0x09
  c4:	fa 85       	ldd	r31, Y+10	; 0x0a
  c6:	c4 a2       	std	Z+36, r12	; 0x24
  c8:	d5 a2       	std	Z+37, r13	; 0x25
  ca:	e6 a2       	std	Z+38, r14	; 0x26
  cc:	f7 a2       	std	Z+39, r15	; 0x27
  ce:	12 a9       	ldd	r17, Z+50	; 0x32
  d0:	03 a9       	ldd	r16, Z+51	; 0x33
  d2:	34 a8       	ldd	r3, Z+52	; 0x34
  d4:	25 a8       	ldd	r2, Z+53	; 0x35
  d6:	21 2f       	mov	r18, r17
  d8:	30 2f       	mov	r19, r16
  da:	43 2d       	mov	r20, r3
  dc:	52 2d       	mov	r21, r2
  de:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID7ComputeEv>
  e2:	18 16       	cp	r1, r24
  e4:	04 f0       	brlt	.+0      	; 0xe6 <_ZN3PID7ComputeEv+0xe6>
  e6:	00 c0       	rjmp	.+0      	; 0xe8 <_ZN3PID7ComputeEv+0xe8>
  e8:	81 2f       	mov	r24, r17
  ea:	90 2f       	mov	r25, r16
  ec:	a3 2d       	mov	r26, r3
  ee:	b2 2d       	mov	r27, r2
  f0:	e9 85       	ldd	r30, Y+9	; 0x09
  f2:	fa 85       	ldd	r31, Y+10	; 0x0a
  f4:	84 a3       	std	Z+36, r24	; 0x24
  f6:	95 a3       	std	Z+37, r25	; 0x25
  f8:	a6 a3       	std	Z+38, r26	; 0x26
  fa:	b7 a3       	std	Z+39, r27	; 0x27
  fc:	a9 85       	ldd	r26, Y+9	; 0x09
  fe:	ba 85       	ldd	r27, Y+10	; 0x0a
 100:	1c 96       	adiw	r26, 0x0c	; 12
 102:	2d 91       	ld	r18, X+
 104:	3d 91       	ld	r19, X+
 106:	4d 91       	ld	r20, X+
 108:	5c 91       	ld	r21, X
 10a:	1f 97       	sbiw	r26, 0x0f	; 15
 10c:	c3 01       	movw	r24, r6
 10e:	b2 01       	movw	r22, r4
 110:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID7ComputeEv>
 114:	e9 85       	ldd	r30, Y+9	; 0x09
 116:	fa 85       	ldd	r31, Y+10	; 0x0a
 118:	24 a1       	ldd	r18, Z+36	; 0x24
 11a:	35 a1       	ldd	r19, Z+37	; 0x25
 11c:	46 a1       	ldd	r20, Z+38	; 0x26
 11e:	57 a1       	ldd	r21, Z+39	; 0x27
 120:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID7ComputeEv>
 124:	6b 01       	movw	r12, r22
 126:	7c 01       	movw	r14, r24
 128:	a9 85       	ldd	r26, Y+9	; 0x09
 12a:	ba 85       	ldd	r27, Y+10	; 0x0a
 12c:	98 96       	adiw	r26, 0x28	; 40
 12e:	2d 91       	ld	r18, X+
 130:	3d 91       	ld	r19, X+
 132:	4d 91       	ld	r20, X+
 134:	5c 91       	ld	r21, X
 136:	9b 97       	sbiw	r26, 0x2b	; 43
 138:	c5 01       	movw	r24, r10
 13a:	b4 01       	movw	r22, r8
 13c:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID7ComputeEv>
 140:	e9 85       	ldd	r30, Y+9	; 0x09
 142:	fa 85       	ldd	r31, Y+10	; 0x0a
 144:	24 89       	ldd	r18, Z+20	; 0x14
 146:	35 89       	ldd	r19, Z+21	; 0x15
 148:	46 89       	ldd	r20, Z+22	; 0x16
 14a:	57 89       	ldd	r21, Z+23	; 0x17
 14c:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID7ComputeEv>
 150:	9b 01       	movw	r18, r22
 152:	ac 01       	movw	r20, r24
 154:	c7 01       	movw	r24, r14
 156:	b6 01       	movw	r22, r12
 158:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID7ComputeEv>
 15c:	6b 01       	movw	r12, r22
 15e:	7c 01       	movw	r14, r24
 160:	9b 01       	movw	r18, r22
 162:	ac 01       	movw	r20, r24
 164:	61 2f       	mov	r22, r17
 166:	70 2f       	mov	r23, r16
 168:	83 2d       	mov	r24, r3
 16a:	92 2d       	mov	r25, r2
 16c:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID7ComputeEv>
 170:	87 fd       	sbrc	r24, 7
 172:	00 c0       	rjmp	.+0      	; 0x174 <_ZN3PID7ComputeEv+0x174>
 174:	a9 85       	ldd	r26, Y+9	; 0x09
 176:	ba 85       	ldd	r27, Y+10	; 0x0a
 178:	9e 96       	adiw	r26, 0x2e	; 46
 17a:	1c 91       	ld	r17, X
 17c:	9e 97       	sbiw	r26, 0x2e	; 46
 17e:	9f 96       	adiw	r26, 0x2f	; 47
 180:	0c 91       	ld	r16, X
 182:	9f 97       	sbiw	r26, 0x2f	; 47
 184:	d0 96       	adiw	r26, 0x30	; 48
 186:	3c 90       	ld	r3, X
 188:	d0 97       	sbiw	r26, 0x30	; 48
 18a:	d1 96       	adiw	r26, 0x31	; 49
 18c:	2c 90       	ld	r2, X
 18e:	96 01       	movw	r18, r12
 190:	a7 01       	movw	r20, r14
 192:	61 2f       	mov	r22, r17
 194:	70 2f       	mov	r23, r16
 196:	83 2d       	mov	r24, r3
 198:	92 2d       	mov	r25, r2
 19a:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID7ComputeEv>
 19e:	18 16       	cp	r1, r24
 1a0:	04 f0       	brlt	.+0      	; 0x1a2 <_ZN3PID7ComputeEv+0x1a2>
 1a2:	1c 2d       	mov	r17, r12
 1a4:	0d 2d       	mov	r16, r13
 1a6:	3e 2c       	mov	r3, r14
 1a8:	2f 2c       	mov	r2, r15
 1aa:	a9 85       	ldd	r26, Y+9	; 0x09
 1ac:	ba 85       	ldd	r27, Y+10	; 0x0a
 1ae:	5c 96       	adiw	r26, 0x1c	; 28
 1b0:	ed 91       	ld	r30, X+
 1b2:	fc 91       	ld	r31, X
 1b4:	81 2f       	mov	r24, r17
 1b6:	90 2f       	mov	r25, r16
 1b8:	a3 2d       	mov	r26, r3
 1ba:	b2 2d       	mov	r27, r2
 1bc:	80 83       	st	Z, r24
 1be:	91 83       	std	Z+1, r25	; 0x01
 1c0:	a2 83       	std	Z+2, r26	; 0x02
 1c2:	b3 83       	std	Z+3, r27	; 0x03
 1c4:	e9 85       	ldd	r30, Y+9	; 0x09
 1c6:	fa 85       	ldd	r31, Y+10	; 0x0a
 1c8:	80 a6       	std	Z+40, r8	; 0x28
 1ca:	91 a6       	std	Z+41, r9	; 0x29
 1cc:	a2 a6       	std	Z+42, r10	; 0x2a
 1ce:	b3 a6       	std	Z+43, r11	; 0x2b
 1d0:	8d 81       	ldd	r24, Y+5	; 0x05
 1d2:	9e 81       	ldd	r25, Y+6	; 0x06
 1d4:	af 81       	ldd	r26, Y+7	; 0x07
 1d6:	b8 85       	ldd	r27, Y+8	; 0x08
 1d8:	80 a3       	std	Z+32, r24	; 0x20
 1da:	91 a3       	std	Z+33, r25	; 0x21
 1dc:	a2 a3       	std	Z+34, r26	; 0x22
 1de:	b3 a3       	std	Z+35, r27	; 0x23
 1e0:	2a 96       	adiw	r28, 0x0a	; 10
 1e2:	0f b6       	in	r0, 0x3f	; 63
 1e4:	f8 94       	cli
 1e6:	de bf       	out	0x3e, r29	; 62
 1e8:	0f be       	out	0x3f, r0	; 63
 1ea:	cd bf       	out	0x3d, r28	; 61
 1ec:	df 91       	pop	r29
 1ee:	cf 91       	pop	r28
 1f0:	1f 91       	pop	r17
 1f2:	0f 91       	pop	r16
 1f4:	ff 90       	pop	r15
 1f6:	ef 90       	pop	r14
 1f8:	df 90       	pop	r13
 1fa:	cf 90       	pop	r12
 1fc:	bf 90       	pop	r11
 1fe:	af 90       	pop	r10
 200:	9f 90       	pop	r9
 202:	8f 90       	pop	r8
 204:	7f 90       	pop	r7
 206:	6f 90       	pop	r6
 208:	5f 90       	pop	r5
 20a:	4f 90       	pop	r4
 20c:	3f 90       	pop	r3
 20e:	2f 90       	pop	r2
 210:	08 95       	ret
 212:	a9 85       	ldd	r26, Y+9	; 0x09
 214:	ba 85       	ldd	r27, Y+10	; 0x0a
 216:	9e 96       	adiw	r26, 0x2e	; 46
 218:	8d 91       	ld	r24, X+
 21a:	9d 91       	ld	r25, X+
 21c:	0d 90       	ld	r0, X+
 21e:	bc 91       	ld	r27, X
 220:	a0 2d       	mov	r26, r0
 222:	89 83       	std	Y+1, r24	; 0x01
 224:	9a 83       	std	Y+2, r25	; 0x02
 226:	ab 83       	std	Y+3, r26	; 0x03
 228:	bc 83       	std	Y+4, r27	; 0x04
 22a:	9c 01       	movw	r18, r24
 22c:	ad 01       	movw	r20, r26
 22e:	c7 01       	movw	r24, r14
 230:	b6 01       	movw	r22, r12
 232:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID7ComputeEv>
 236:	87 ff       	sbrs	r24, 7
 238:	00 c0       	rjmp	.+0      	; 0x23a <_ZN3PID7ComputeEv+0x23a>
 23a:	89 81       	ldd	r24, Y+1	; 0x01
 23c:	9a 81       	ldd	r25, Y+2	; 0x02
 23e:	ab 81       	ldd	r26, Y+3	; 0x03
 240:	bc 81       	ldd	r27, Y+4	; 0x04
 242:	00 c0       	rjmp	.+0      	; 0x244 <__SREG__+0x205>

Disassembly of section .text._ZN3PID10SetTuningsEddd:

00000000 <_ZN3PID10SetTuningsEddd>:
   0:	4f 92       	push	r4
   2:	5f 92       	push	r5
   4:	6f 92       	push	r6
   6:	7f 92       	push	r7
   8:	8f 92       	push	r8
   a:	9f 92       	push	r9
   c:	af 92       	push	r10
   e:	bf 92       	push	r11
  10:	cf 92       	push	r12
  12:	df 92       	push	r13
  14:	ef 92       	push	r14
  16:	ff 92       	push	r15
  18:	0f 93       	push	r16
  1a:	1f 93       	push	r17
  1c:	cf 93       	push	r28
  1e:	df 93       	push	r29
  20:	00 d0       	rcall	.+0      	; 0x22 <_ZN3PID10SetTuningsEddd+0x22>
  22:	00 d0       	rcall	.+0      	; 0x24 <_ZN3PID10SetTuningsEddd+0x24>
  24:	00 d0       	rcall	.+0      	; 0x26 <_ZN3PID10SetTuningsEddd+0x26>
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
  2a:	9e 83       	std	Y+6, r25	; 0x06
  2c:	8d 83       	std	Y+5, r24	; 0x05
  2e:	2a 01       	movw	r4, r20
  30:	3b 01       	movw	r6, r22
  32:	48 01       	movw	r8, r16
  34:	59 01       	movw	r10, r18
  36:	20 e0       	ldi	r18, 0x00	; 0
  38:	30 e0       	ldi	r19, 0x00	; 0
  3a:	a9 01       	movw	r20, r18
  3c:	cb 01       	movw	r24, r22
  3e:	b2 01       	movw	r22, r4
  40:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID10SetTuningsEddd>
  44:	87 fd       	sbrc	r24, 7
  46:	00 c0       	rjmp	.+0      	; 0x48 <_ZN3PID10SetTuningsEddd+0x48>
  48:	20 e0       	ldi	r18, 0x00	; 0
  4a:	30 e0       	ldi	r19, 0x00	; 0
  4c:	a9 01       	movw	r20, r18
  4e:	c5 01       	movw	r24, r10
  50:	b8 01       	movw	r22, r16
  52:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID10SetTuningsEddd>
  56:	87 fd       	sbrc	r24, 7
  58:	00 c0       	rjmp	.+0      	; 0x5a <_ZN3PID10SetTuningsEddd+0x5a>
  5a:	20 e0       	ldi	r18, 0x00	; 0
  5c:	30 e0       	ldi	r19, 0x00	; 0
  5e:	a9 01       	movw	r20, r18
  60:	c7 01       	movw	r24, r14
  62:	b6 01       	movw	r22, r12
  64:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID10SetTuningsEddd>
  68:	87 fd       	sbrc	r24, 7
  6a:	00 c0       	rjmp	.+0      	; 0x6c <_ZN3PID10SetTuningsEddd+0x6c>
  6c:	ed 81       	ldd	r30, Y+5	; 0x05
  6e:	fe 81       	ldd	r31, Y+6	; 0x06
  70:	40 82       	st	Z, r4
  72:	51 82       	std	Z+1, r5	; 0x01
  74:	62 82       	std	Z+2, r6	; 0x02
  76:	73 82       	std	Z+3, r7	; 0x03
  78:	84 82       	std	Z+4, r8	; 0x04
  7a:	95 82       	std	Z+5, r9	; 0x05
  7c:	a6 82       	std	Z+6, r10	; 0x06
  7e:	b7 82       	std	Z+7, r11	; 0x07
  80:	c0 86       	std	Z+8, r12	; 0x08
  82:	d1 86       	std	Z+9, r13	; 0x09
  84:	e2 86       	std	Z+10, r14	; 0x0a
  86:	f3 86       	std	Z+11, r15	; 0x0b
  88:	64 a5       	ldd	r22, Z+44	; 0x2c
  8a:	75 a5       	ldd	r23, Z+45	; 0x2d
  8c:	07 2e       	mov	r0, r23
  8e:	00 0c       	add	r0, r0
  90:	88 0b       	sbc	r24, r24
  92:	99 0b       	sbc	r25, r25
  94:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID10SetTuningsEddd>
  98:	20 e0       	ldi	r18, 0x00	; 0
  9a:	30 e0       	ldi	r19, 0x00	; 0
  9c:	4a e7       	ldi	r20, 0x7A	; 122
  9e:	54 e4       	ldi	r21, 0x44	; 68
  a0:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID10SetTuningsEddd>
  a4:	69 83       	std	Y+1, r22	; 0x01
  a6:	7a 83       	std	Y+2, r23	; 0x02
  a8:	8b 83       	std	Y+3, r24	; 0x03
  aa:	9c 83       	std	Y+4, r25	; 0x04
  ac:	ed 81       	ldd	r30, Y+5	; 0x05
  ae:	fe 81       	ldd	r31, Y+6	; 0x06
  b0:	44 86       	std	Z+12, r4	; 0x0c
  b2:	55 86       	std	Z+13, r5	; 0x0d
  b4:	66 86       	std	Z+14, r6	; 0x0e
  b6:	77 86       	std	Z+15, r7	; 0x0f
  b8:	9b 01       	movw	r18, r22
  ba:	ac 01       	movw	r20, r24
  bc:	c5 01       	movw	r24, r10
  be:	b8 01       	movw	r22, r16
  c0:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID10SetTuningsEddd>
  c4:	4b 01       	movw	r8, r22
  c6:	5c 01       	movw	r10, r24
  c8:	ed 81       	ldd	r30, Y+5	; 0x05
  ca:	fe 81       	ldd	r31, Y+6	; 0x06
  cc:	80 8a       	std	Z+16, r8	; 0x10
  ce:	91 8a       	std	Z+17, r9	; 0x11
  d0:	a2 8a       	std	Z+18, r10	; 0x12
  d2:	b3 8a       	std	Z+19, r11	; 0x13
  d4:	29 81       	ldd	r18, Y+1	; 0x01
  d6:	3a 81       	ldd	r19, Y+2	; 0x02
  d8:	4b 81       	ldd	r20, Y+3	; 0x03
  da:	5c 81       	ldd	r21, Y+4	; 0x04
  dc:	c7 01       	movw	r24, r14
  de:	b6 01       	movw	r22, r12
  e0:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID10SetTuningsEddd>
  e4:	6b 01       	movw	r12, r22
  e6:	7c 01       	movw	r14, r24
  e8:	ed 81       	ldd	r30, Y+5	; 0x05
  ea:	fe 81       	ldd	r31, Y+6	; 0x06
  ec:	c4 8a       	std	Z+20, r12	; 0x14
  ee:	d5 8a       	std	Z+21, r13	; 0x15
  f0:	e6 8a       	std	Z+22, r14	; 0x16
  f2:	f7 8a       	std	Z+23, r15	; 0x17
  f4:	80 8d       	ldd	r24, Z+24	; 0x18
  f6:	91 8d       	ldd	r25, Z+25	; 0x19
  f8:	01 97       	sbiw	r24, 0x01	; 1
  fa:	01 f4       	brne	.+0      	; 0xfc <_ZN3PID10SetTuningsEddd+0xfc>
  fc:	a3 01       	movw	r20, r6
  fe:	92 01       	movw	r18, r4
 100:	60 e0       	ldi	r22, 0x00	; 0
 102:	70 e0       	ldi	r23, 0x00	; 0
 104:	cb 01       	movw	r24, r22
 106:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID10SetTuningsEddd>
 10a:	ed 81       	ldd	r30, Y+5	; 0x05
 10c:	fe 81       	ldd	r31, Y+6	; 0x06
 10e:	64 87       	std	Z+12, r22	; 0x0c
 110:	75 87       	std	Z+13, r23	; 0x0d
 112:	86 87       	std	Z+14, r24	; 0x0e
 114:	97 87       	std	Z+15, r25	; 0x0f
 116:	a5 01       	movw	r20, r10
 118:	94 01       	movw	r18, r8
 11a:	60 e0       	ldi	r22, 0x00	; 0
 11c:	70 e0       	ldi	r23, 0x00	; 0
 11e:	cb 01       	movw	r24, r22
 120:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID10SetTuningsEddd>
 124:	ed 81       	ldd	r30, Y+5	; 0x05
 126:	fe 81       	ldd	r31, Y+6	; 0x06
 128:	60 8b       	std	Z+16, r22	; 0x10
 12a:	71 8b       	std	Z+17, r23	; 0x11
 12c:	82 8b       	std	Z+18, r24	; 0x12
 12e:	93 8b       	std	Z+19, r25	; 0x13
 130:	a7 01       	movw	r20, r14
 132:	96 01       	movw	r18, r12
 134:	60 e0       	ldi	r22, 0x00	; 0
 136:	70 e0       	ldi	r23, 0x00	; 0
 138:	cb 01       	movw	r24, r22
 13a:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID10SetTuningsEddd>
 13e:	ed 81       	ldd	r30, Y+5	; 0x05
 140:	fe 81       	ldd	r31, Y+6	; 0x06
 142:	64 8b       	std	Z+20, r22	; 0x14
 144:	75 8b       	std	Z+21, r23	; 0x15
 146:	86 8b       	std	Z+22, r24	; 0x16
 148:	97 8b       	std	Z+23, r25	; 0x17
 14a:	26 96       	adiw	r28, 0x06	; 6
 14c:	0f b6       	in	r0, 0x3f	; 63
 14e:	f8 94       	cli
 150:	de bf       	out	0x3e, r29	; 62
 152:	0f be       	out	0x3f, r0	; 63
 154:	cd bf       	out	0x3d, r28	; 61
 156:	df 91       	pop	r29
 158:	cf 91       	pop	r28
 15a:	1f 91       	pop	r17
 15c:	0f 91       	pop	r16
 15e:	ff 90       	pop	r15
 160:	ef 90       	pop	r14
 162:	df 90       	pop	r13
 164:	cf 90       	pop	r12
 166:	bf 90       	pop	r11
 168:	af 90       	pop	r10
 16a:	9f 90       	pop	r9
 16c:	8f 90       	pop	r8
 16e:	7f 90       	pop	r7
 170:	6f 90       	pop	r6
 172:	5f 90       	pop	r5
 174:	4f 90       	pop	r4
 176:	08 95       	ret

Disassembly of section .text._ZN3PID13SetSampleTimeEi:

00000000 <_ZN3PID13SetSampleTimeEi>:
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	16 16       	cp	r1, r22
  12:	17 06       	cpc	r1, r23
  14:	04 f4       	brge	.+0      	; 0x16 <_ZN3PID13SetSampleTimeEi+0x16>
  16:	8b 01       	movw	r16, r22
  18:	ec 01       	movw	r28, r24
  1a:	07 2e       	mov	r0, r23
  1c:	00 0c       	add	r0, r0
  1e:	88 0b       	sbc	r24, r24
  20:	99 0b       	sbc	r25, r25
  22:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID13SetSampleTimeEi>
  26:	6b 01       	movw	r12, r22
  28:	7c 01       	movw	r14, r24
  2a:	6c a5       	ldd	r22, Y+44	; 0x2c
  2c:	7d a5       	ldd	r23, Y+45	; 0x2d
  2e:	07 2e       	mov	r0, r23
  30:	00 0c       	add	r0, r0
  32:	88 0b       	sbc	r24, r24
  34:	99 0b       	sbc	r25, r25
  36:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID13SetSampleTimeEi>
  3a:	9b 01       	movw	r18, r22
  3c:	ac 01       	movw	r20, r24
  3e:	c7 01       	movw	r24, r14
  40:	b6 01       	movw	r22, r12
  42:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID13SetSampleTimeEi>
  46:	6b 01       	movw	r12, r22
  48:	7c 01       	movw	r14, r24
  4a:	ac 01       	movw	r20, r24
  4c:	9b 01       	movw	r18, r22
  4e:	68 89       	ldd	r22, Y+16	; 0x10
  50:	79 89       	ldd	r23, Y+17	; 0x11
  52:	8a 89       	ldd	r24, Y+18	; 0x12
  54:	9b 89       	ldd	r25, Y+19	; 0x13
  56:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID13SetSampleTimeEi>
  5a:	68 8b       	std	Y+16, r22	; 0x10
  5c:	79 8b       	std	Y+17, r23	; 0x11
  5e:	8a 8b       	std	Y+18, r24	; 0x12
  60:	9b 8b       	std	Y+19, r25	; 0x13
  62:	a7 01       	movw	r20, r14
  64:	96 01       	movw	r18, r12
  66:	6c 89       	ldd	r22, Y+20	; 0x14
  68:	7d 89       	ldd	r23, Y+21	; 0x15
  6a:	8e 89       	ldd	r24, Y+22	; 0x16
  6c:	9f 89       	ldd	r25, Y+23	; 0x17
  6e:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID13SetSampleTimeEi>
  72:	6c 8b       	std	Y+20, r22	; 0x14
  74:	7d 8b       	std	Y+21, r23	; 0x15
  76:	8e 8b       	std	Y+22, r24	; 0x16
  78:	9f 8b       	std	Y+23, r25	; 0x17
  7a:	1d a7       	std	Y+45, r17	; 0x2d
  7c:	0c a7       	std	Y+44, r16	; 0x2c
  7e:	df 91       	pop	r29
  80:	cf 91       	pop	r28
  82:	1f 91       	pop	r17
  84:	0f 91       	pop	r16
  86:	ff 90       	pop	r15
  88:	ef 90       	pop	r14
  8a:	df 90       	pop	r13
  8c:	cf 90       	pop	r12
  8e:	08 95       	ret

Disassembly of section .text._ZN3PID15SetOutputLimitsEdd:

00000000 <_ZN3PID15SetOutputLimitsEdd>:
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
   a:	7f 92       	push	r7
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  24:	ec 01       	movw	r28, r24
  26:	6a 01       	movw	r12, r20
  28:	7b 01       	movw	r14, r22
  2a:	48 01       	movw	r8, r16
  2c:	59 01       	movw	r10, r18
  2e:	a9 01       	movw	r20, r18
  30:	98 01       	movw	r18, r16
  32:	cb 01       	movw	r24, r22
  34:	b6 01       	movw	r22, r12
  36:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID15SetOutputLimitsEdd>
  3a:	87 ff       	sbrs	r24, 7
  3c:	00 c0       	rjmp	.+0      	; 0x3e <_ZN3PID15SetOutputLimitsEdd+0x3e>
  3e:	ce a6       	std	Y+46, r12	; 0x2e
  40:	df a6       	std	Y+47, r13	; 0x2f
  42:	e8 aa       	std	Y+48, r14	; 0x30
  44:	f9 aa       	std	Y+49, r15	; 0x31
  46:	8a aa       	std	Y+50, r8	; 0x32
  48:	9b aa       	std	Y+51, r9	; 0x33
  4a:	ac aa       	std	Y+52, r10	; 0x34
  4c:	bd aa       	std	Y+53, r11	; 0x35
  4e:	8e a9       	ldd	r24, Y+54	; 0x36
  50:	88 23       	and	r24, r24
  52:	01 f4       	brne	.+0      	; 0x54 <_ZN3PID15SetOutputLimitsEdd+0x54>
  54:	00 c0       	rjmp	.+0      	; 0x56 <_ZN3PID15SetOutputLimitsEdd+0x56>
  56:	2c 8c       	ldd	r2, Y+28	; 0x1c
  58:	3d 8c       	ldd	r3, Y+29	; 0x1d
  5a:	f1 01       	movw	r30, r2
  5c:	40 80       	ld	r4, Z
  5e:	51 80       	ldd	r5, Z+1	; 0x01
  60:	62 80       	ldd	r6, Z+2	; 0x02
  62:	73 80       	ldd	r7, Z+3	; 0x03
  64:	a3 01       	movw	r20, r6
  66:	92 01       	movw	r18, r4
  68:	c5 01       	movw	r24, r10
  6a:	b8 01       	movw	r22, r16
  6c:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID15SetOutputLimitsEdd>
  70:	87 ff       	sbrs	r24, 7
  72:	00 c0       	rjmp	.+0      	; 0x74 <_ZN3PID15SetOutputLimitsEdd+0x74>
  74:	f1 01       	movw	r30, r2
  76:	80 82       	st	Z, r8
  78:	91 82       	std	Z+1, r9	; 0x01
  7a:	a2 82       	std	Z+2, r10	; 0x02
  7c:	b3 82       	std	Z+3, r11	; 0x03
  7e:	8c a0       	ldd	r8, Y+36	; 0x24
  80:	9d a0       	ldd	r9, Y+37	; 0x25
  82:	ae a0       	ldd	r10, Y+38	; 0x26
  84:	bf a0       	ldd	r11, Y+39	; 0x27
  86:	ca a8       	ldd	r12, Y+50	; 0x32
  88:	db a8       	ldd	r13, Y+51	; 0x33
  8a:	ec a8       	ldd	r14, Y+52	; 0x34
  8c:	fd a8       	ldd	r15, Y+53	; 0x35
  8e:	a7 01       	movw	r20, r14
  90:	96 01       	movw	r18, r12
  92:	c5 01       	movw	r24, r10
  94:	b4 01       	movw	r22, r8
  96:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID15SetOutputLimitsEdd>
  9a:	18 16       	cp	r1, r24
  9c:	04 f4       	brge	.+0      	; 0x9e <_ZN3PID15SetOutputLimitsEdd+0x9e>
  9e:	cc a2       	std	Y+36, r12	; 0x24
  a0:	dd a2       	std	Y+37, r13	; 0x25
  a2:	ee a2       	std	Y+38, r14	; 0x26
  a4:	ff a2       	std	Y+39, r15	; 0x27
  a6:	00 c0       	rjmp	.+0      	; 0xa8 <_ZN3PID15SetOutputLimitsEdd+0xa8>
  a8:	a3 01       	movw	r20, r6
  aa:	92 01       	movw	r18, r4
  ac:	c7 01       	movw	r24, r14
  ae:	b6 01       	movw	r22, r12
  b0:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID15SetOutputLimitsEdd>
  b4:	18 16       	cp	r1, r24
  b6:	04 f4       	brge	.+0      	; 0xb8 <_ZN3PID15SetOutputLimitsEdd+0xb8>
  b8:	f1 01       	movw	r30, r2
  ba:	c0 82       	st	Z, r12
  bc:	d1 82       	std	Z+1, r13	; 0x01
  be:	e2 82       	std	Z+2, r14	; 0x02
  c0:	f3 82       	std	Z+3, r15	; 0x03
  c2:	00 c0       	rjmp	.+0      	; 0xc4 <_ZN3PID15SetOutputLimitsEdd+0xc4>
  c4:	ce a4       	ldd	r12, Y+46	; 0x2e
  c6:	df a4       	ldd	r13, Y+47	; 0x2f
  c8:	e8 a8       	ldd	r14, Y+48	; 0x30
  ca:	f9 a8       	ldd	r15, Y+49	; 0x31
  cc:	a7 01       	movw	r20, r14
  ce:	96 01       	movw	r18, r12
  d0:	c5 01       	movw	r24, r10
  d2:	b4 01       	movw	r22, r8
  d4:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID15SetOutputLimitsEdd>
  d8:	87 fd       	sbrc	r24, 7
  da:	00 c0       	rjmp	.+0      	; 0xdc <_ZN3PID15SetOutputLimitsEdd+0xdc>
  dc:	df 91       	pop	r29
  de:	cf 91       	pop	r28
  e0:	1f 91       	pop	r17
  e2:	0f 91       	pop	r16
  e4:	ff 90       	pop	r15
  e6:	ef 90       	pop	r14
  e8:	df 90       	pop	r13
  ea:	cf 90       	pop	r12
  ec:	bf 90       	pop	r11
  ee:	af 90       	pop	r10
  f0:	9f 90       	pop	r9
  f2:	8f 90       	pop	r8
  f4:	7f 90       	pop	r7
  f6:	6f 90       	pop	r6
  f8:	5f 90       	pop	r5
  fa:	4f 90       	pop	r4
  fc:	3f 90       	pop	r3
  fe:	2f 90       	pop	r2
 100:	08 95       	ret

Disassembly of section .text._ZN3PID10InitializeEv:

00000000 <_ZN3PID10InitializeEv>:
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
   6:	bf 92       	push	r11
   8:	cf 92       	push	r12
   a:	df 92       	push	r13
   c:	ef 92       	push	r14
   e:	ff 92       	push	r15
  10:	cf 93       	push	r28
  12:	df 93       	push	r29
  14:	ec 01       	movw	r28, r24
  16:	ec 8d       	ldd	r30, Y+28	; 0x1c
  18:	fd 8d       	ldd	r31, Y+29	; 0x1d
  1a:	c0 80       	ld	r12, Z
  1c:	d1 80       	ldd	r13, Z+1	; 0x01
  1e:	e2 80       	ldd	r14, Z+2	; 0x02
  20:	f3 80       	ldd	r15, Z+3	; 0x03
  22:	cc a2       	std	Y+36, r12	; 0x24
  24:	dd a2       	std	Y+37, r13	; 0x25
  26:	ee a2       	std	Y+38, r14	; 0x26
  28:	ff a2       	std	Y+39, r15	; 0x27
  2a:	ea 8d       	ldd	r30, Y+26	; 0x1a
  2c:	fb 8d       	ldd	r31, Y+27	; 0x1b
  2e:	80 81       	ld	r24, Z
  30:	91 81       	ldd	r25, Z+1	; 0x01
  32:	a2 81       	ldd	r26, Z+2	; 0x02
  34:	b3 81       	ldd	r27, Z+3	; 0x03
  36:	88 a7       	std	Y+40, r24	; 0x28
  38:	99 a7       	std	Y+41, r25	; 0x29
  3a:	aa a7       	std	Y+42, r26	; 0x2a
  3c:	bb a7       	std	Y+43, r27	; 0x2b
  3e:	8a a8       	ldd	r8, Y+50	; 0x32
  40:	9b a8       	ldd	r9, Y+51	; 0x33
  42:	ac a8       	ldd	r10, Y+52	; 0x34
  44:	bd a8       	ldd	r11, Y+53	; 0x35
  46:	a5 01       	movw	r20, r10
  48:	94 01       	movw	r18, r8
  4a:	c7 01       	movw	r24, r14
  4c:	b6 01       	movw	r22, r12
  4e:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID10InitializeEv>
  52:	18 16       	cp	r1, r24
  54:	04 f4       	brge	.+0      	; 0x56 <_ZN3PID10InitializeEv+0x56>
  56:	8c a2       	std	Y+36, r8	; 0x24
  58:	9d a2       	std	Y+37, r9	; 0x25
  5a:	ae a2       	std	Y+38, r10	; 0x26
  5c:	bf a2       	std	Y+39, r11	; 0x27
  5e:	00 c0       	rjmp	.+0      	; 0x60 <_ZN3PID10InitializeEv+0x60>
  60:	8e a4       	ldd	r8, Y+46	; 0x2e
  62:	9f a4       	ldd	r9, Y+47	; 0x2f
  64:	a8 a8       	ldd	r10, Y+48	; 0x30
  66:	b9 a8       	ldd	r11, Y+49	; 0x31
  68:	a5 01       	movw	r20, r10
  6a:	94 01       	movw	r18, r8
  6c:	c7 01       	movw	r24, r14
  6e:	b6 01       	movw	r22, r12
  70:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID10InitializeEv>
  74:	87 fd       	sbrc	r24, 7
  76:	00 c0       	rjmp	.+0      	; 0x78 <_ZN3PID10InitializeEv+0x78>
  78:	df 91       	pop	r29
  7a:	cf 91       	pop	r28
  7c:	ff 90       	pop	r15
  7e:	ef 90       	pop	r14
  80:	df 90       	pop	r13
  82:	cf 90       	pop	r12
  84:	bf 90       	pop	r11
  86:	af 90       	pop	r10
  88:	9f 90       	pop	r9
  8a:	8f 90       	pop	r8
  8c:	08 95       	ret

Disassembly of section .text._ZN3PID7SetModeEi:

00000000 <_ZN3PID7SetModeEi>:
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
   6:	ec 01       	movw	r28, r24
   8:	11 e0       	ldi	r17, 0x01	; 1
   a:	61 30       	cpi	r22, 0x01	; 1
   c:	71 05       	cpc	r23, r1
   e:	01 f0       	breq	.+0      	; 0x10 <_ZN3PID7SetModeEi+0x10>
  10:	10 e0       	ldi	r17, 0x00	; 0
  12:	8e a9       	ldd	r24, Y+54	; 0x36
  14:	91 e0       	ldi	r25, 0x01	; 1
  16:	89 27       	eor	r24, r25
  18:	81 13       	cpse	r24, r17
  1a:	00 c0       	rjmp	.+0      	; 0x1c <_ZN3PID7SetModeEi+0x1c>
  1c:	ce 01       	movw	r24, r28
  1e:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID7SetModeEi>
  22:	1e ab       	std	Y+54, r17	; 0x36
  24:	df 91       	pop	r29
  26:	cf 91       	pop	r28
  28:	1f 91       	pop	r17
  2a:	08 95       	ret

Disassembly of section .text._ZN3PID22SetControllerDirectionEi:

00000000 <_ZN3PID22SetControllerDirectionEi>:
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	ec 01       	movw	r28, r24
   a:	8b 01       	movw	r16, r22
   c:	8e a9       	ldd	r24, Y+54	; 0x36
   e:	88 23       	and	r24, r24
  10:	01 f0       	breq	.+0      	; 0x12 <_ZN3PID22SetControllerDirectionEi+0x12>
  12:	88 8d       	ldd	r24, Y+24	; 0x18
  14:	99 8d       	ldd	r25, Y+25	; 0x19
  16:	86 17       	cp	r24, r22
  18:	97 07       	cpc	r25, r23
  1a:	01 f0       	breq	.+0      	; 0x1c <_ZN3PID22SetControllerDirectionEi+0x1c>
  1c:	2c 85       	ldd	r18, Y+12	; 0x0c
  1e:	3d 85       	ldd	r19, Y+13	; 0x0d
  20:	4e 85       	ldd	r20, Y+14	; 0x0e
  22:	5f 85       	ldd	r21, Y+15	; 0x0f
  24:	60 e0       	ldi	r22, 0x00	; 0
  26:	70 e0       	ldi	r23, 0x00	; 0
  28:	cb 01       	movw	r24, r22
  2a:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID22SetControllerDirectionEi>
  2e:	6c 87       	std	Y+12, r22	; 0x0c
  30:	7d 87       	std	Y+13, r23	; 0x0d
  32:	8e 87       	std	Y+14, r24	; 0x0e
  34:	9f 87       	std	Y+15, r25	; 0x0f
  36:	28 89       	ldd	r18, Y+16	; 0x10
  38:	39 89       	ldd	r19, Y+17	; 0x11
  3a:	4a 89       	ldd	r20, Y+18	; 0x12
  3c:	5b 89       	ldd	r21, Y+19	; 0x13
  3e:	60 e0       	ldi	r22, 0x00	; 0
  40:	70 e0       	ldi	r23, 0x00	; 0
  42:	cb 01       	movw	r24, r22
  44:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID22SetControllerDirectionEi>
  48:	68 8b       	std	Y+16, r22	; 0x10
  4a:	79 8b       	std	Y+17, r23	; 0x11
  4c:	8a 8b       	std	Y+18, r24	; 0x12
  4e:	9b 8b       	std	Y+19, r25	; 0x13
  50:	2c 89       	ldd	r18, Y+20	; 0x14
  52:	3d 89       	ldd	r19, Y+21	; 0x15
  54:	4e 89       	ldd	r20, Y+22	; 0x16
  56:	5f 89       	ldd	r21, Y+23	; 0x17
  58:	60 e0       	ldi	r22, 0x00	; 0
  5a:	70 e0       	ldi	r23, 0x00	; 0
  5c:	cb 01       	movw	r24, r22
  5e:	0e 94 00 00 	call	0	; 0x0 <_ZN3PID22SetControllerDirectionEi>
  62:	6c 8b       	std	Y+20, r22	; 0x14
  64:	7d 8b       	std	Y+21, r23	; 0x15
  66:	8e 8b       	std	Y+22, r24	; 0x16
  68:	9f 8b       	std	Y+23, r25	; 0x17
  6a:	19 8f       	std	Y+25, r17	; 0x19
  6c:	08 8f       	std	Y+24, r16	; 0x18
  6e:	df 91       	pop	r29
  70:	cf 91       	pop	r28
  72:	1f 91       	pop	r17
  74:	0f 91       	pop	r16
  76:	08 95       	ret

Disassembly of section .text._ZN3PIDC2EPdS0_S0_dddi:

00000000 <_ZN3PIDC1EPdS0_S0_dddi>:
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
   a:	7f 92       	push	r7
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  24:	cd b7       	in	r28, 0x3d	; 61
  26:	de b7       	in	r29, 0x3e	; 62
  28:	28 97       	sbiw	r28, 0x08	; 8
  2a:	0f b6       	in	r0, 0x3f	; 63
  2c:	f8 94       	cli
  2e:	de bf       	out	0x3e, r29	; 62
  30:	0f be       	out	0x3f, r0	; 63
  32:	cd bf       	out	0x3d, r28	; 61
  34:	4c 01       	movw	r8, r24
  36:	7a 83       	std	Y+2, r23	; 0x02
  38:	69 83       	std	Y+1, r22	; 0x01
  3a:	1a 01       	movw	r2, r20
  3c:	3c 83       	std	Y+4, r19	; 0x04
  3e:	2b 83       	std	Y+3, r18	; 0x03
  40:	27 01       	movw	r4, r14
  42:	38 01       	movw	r6, r16
  44:	ad 82       	std	Y+5, r10	; 0x05
  46:	be 82       	std	Y+6, r11	; 0x06
  48:	cf 82       	std	Y+7, r12	; 0x07
  4a:	d8 86       	std	Y+8, r13	; 0x08
  4c:	00 e0       	ldi	r16, 0x00	; 0
  4e:	10 e0       	ldi	r17, 0x00	; 0
  50:	2f e7       	ldi	r18, 0x7F	; 127
  52:	33 e4       	ldi	r19, 0x43	; 67
  54:	40 e0       	ldi	r20, 0x00	; 0
  56:	50 e0       	ldi	r21, 0x00	; 0
  58:	ba 01       	movw	r22, r20
  5a:	0e 94 00 00 	call	0	; 0x0 <_ZN3PIDC1EPdS0_S0_dddi>
  5e:	84 e6       	ldi	r24, 0x64	; 100
  60:	90 e0       	ldi	r25, 0x00	; 0
  62:	f4 01       	movw	r30, r8
  64:	95 a7       	std	Z+45, r25	; 0x2d
  66:	84 a7       	std	Z+44, r24	; 0x2c
  68:	69 a1       	ldd	r22, Y+33	; 0x21
  6a:	7a a1       	ldd	r23, Y+34	; 0x22
  6c:	c4 01       	movw	r24, r8
  6e:	0e 94 00 00 	call	0	; 0x0 <_ZN3PIDC1EPdS0_S0_dddi>
  72:	cd 8c       	ldd	r12, Y+29	; 0x1d
  74:	de 8c       	ldd	r13, Y+30	; 0x1e
  76:	ef 8c       	ldd	r14, Y+31	; 0x1f
  78:	f8 a0       	ldd	r15, Y+32	; 0x20
  7a:	0d 81       	ldd	r16, Y+5	; 0x05
  7c:	1e 81       	ldd	r17, Y+6	; 0x06
  7e:	2f 81       	ldd	r18, Y+7	; 0x07
  80:	38 85       	ldd	r19, Y+8	; 0x08
  82:	b3 01       	movw	r22, r6
  84:	a2 01       	movw	r20, r4
  86:	c4 01       	movw	r24, r8
  88:	0e 94 00 00 	call	0	; 0x0 <_ZN3PIDC1EPdS0_S0_dddi>
  8c:	0e 94 00 00 	call	0	; 0x0 <_ZN3PIDC1EPdS0_S0_dddi>
  90:	f4 01       	movw	r30, r8
  92:	44 a4       	ldd	r4, Z+44	; 0x2c
  94:	55 a4       	ldd	r5, Z+45	; 0x2d
  96:	05 2c       	mov	r0, r5
  98:	00 0c       	add	r0, r0
  9a:	66 08       	sbc	r6, r6
  9c:	77 08       	sbc	r7, r7
  9e:	64 19       	sub	r22, r4
  a0:	75 09       	sbc	r23, r5
  a2:	86 09       	sbc	r24, r6
  a4:	97 09       	sbc	r25, r7
  a6:	60 a3       	std	Z+32, r22	; 0x20
  a8:	71 a3       	std	Z+33, r23	; 0x21
  aa:	82 a3       	std	Z+34, r24	; 0x22
  ac:	93 a3       	std	Z+35, r25	; 0x23
  ae:	16 aa       	std	Z+54, r1	; 0x36
  b0:	35 8e       	std	Z+29, r3	; 0x1d
  b2:	24 8e       	std	Z+28, r2	; 0x1c
  b4:	89 81       	ldd	r24, Y+1	; 0x01
  b6:	9a 81       	ldd	r25, Y+2	; 0x02
  b8:	93 8f       	std	Z+27, r25	; 0x1b
  ba:	82 8f       	std	Z+26, r24	; 0x1a
  bc:	8b 81       	ldd	r24, Y+3	; 0x03
  be:	9c 81       	ldd	r25, Y+4	; 0x04
  c0:	97 8f       	std	Z+31, r25	; 0x1f
  c2:	86 8f       	std	Z+30, r24	; 0x1e
  c4:	28 96       	adiw	r28, 0x08	; 8
  c6:	0f b6       	in	r0, 0x3f	; 63
  c8:	f8 94       	cli
  ca:	de bf       	out	0x3e, r29	; 62
  cc:	0f be       	out	0x3f, r0	; 63
  ce:	cd bf       	out	0x3d, r28	; 61
  d0:	df 91       	pop	r29
  d2:	cf 91       	pop	r28
  d4:	1f 91       	pop	r17
  d6:	0f 91       	pop	r16
  d8:	ff 90       	pop	r15
  da:	ef 90       	pop	r14
  dc:	df 90       	pop	r13
  de:	cf 90       	pop	r12
  e0:	bf 90       	pop	r11
  e2:	af 90       	pop	r10
  e4:	9f 90       	pop	r9
  e6:	8f 90       	pop	r8
  e8:	7f 90       	pop	r7
  ea:	6f 90       	pop	r6
  ec:	5f 90       	pop	r5
  ee:	4f 90       	pop	r4
  f0:	3f 90       	pop	r3
  f2:	2f 90       	pop	r2
  f4:	08 95       	ret

Disassembly of section .text._ZN3PID5GetKpEv:

00000000 <_ZN3PID5GetKpEv>:
   0:	fc 01       	movw	r30, r24
   2:	60 81       	ld	r22, Z
   4:	71 81       	ldd	r23, Z+1	; 0x01
   6:	82 81       	ldd	r24, Z+2	; 0x02
   8:	93 81       	ldd	r25, Z+3	; 0x03
   a:	08 95       	ret

Disassembly of section .text._ZN3PID5GetKiEv:

00000000 <_ZN3PID5GetKiEv>:
   0:	fc 01       	movw	r30, r24
   2:	64 81       	ldd	r22, Z+4	; 0x04
   4:	75 81       	ldd	r23, Z+5	; 0x05
   6:	86 81       	ldd	r24, Z+6	; 0x06
   8:	97 81       	ldd	r25, Z+7	; 0x07
   a:	08 95       	ret

Disassembly of section .text._ZN3PID5GetKdEv:

00000000 <_ZN3PID5GetKdEv>:
   0:	fc 01       	movw	r30, r24
   2:	60 85       	ldd	r22, Z+8	; 0x08
   4:	71 85       	ldd	r23, Z+9	; 0x09
   6:	82 85       	ldd	r24, Z+10	; 0x0a
   8:	93 85       	ldd	r25, Z+11	; 0x0b
   a:	08 95       	ret

Disassembly of section .text._ZN3PID7GetModeEv:

00000000 <_ZN3PID7GetModeEv>:
   0:	fc 01       	movw	r30, r24
   2:	86 a9       	ldd	r24, Z+54	; 0x36
   4:	90 e0       	ldi	r25, 0x00	; 0
   6:	08 95       	ret

Disassembly of section .text._ZN3PID12GetDirectionEv:

00000000 <_ZN3PID12GetDirectionEv>:
   0:	fc 01       	movw	r30, r24
   2:	80 8d       	ldd	r24, Z+24	; 0x18
   4:	91 8d       	ldd	r25, Z+25	; 0x19
   6:	08 95       	ret

NewSoftSerial.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .group        00000008  00000000  00000000  00000034  2**2
                  CONTENTS, READONLY, EXCLUDE, GROUP, LINK_ONCE_DISCARD
  1 .group        00000008  00000000  00000000  0000003c  2**2
                  CONTENTS, READONLY, EXCLUDE, GROUP, LINK_ONCE_DISCARD
  2 .text         00000000  00000000  00000000  00000044  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .data         00000000  00000000  00000000  00000044  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00000000  00000000  00000000  00000044  2**0
                  ALLOC
  5 .stab         00001308  00000000  00000000  00000044  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .stabstr      00001910  00000000  00000000  0000134c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .text._ZN13NewSoftSerial12tx_pin_writeEh.part.1 00000018  00000000  00000000  00002c5c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text._ZN13NewSoftSerial10tunedDelayEj 0000000e  00000000  00000000  00002c74  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text._ZN13NewSoftSerial8activateEv 00000034  00000000  00000000  00002c82  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text._ZN13NewSoftSerial4recvEv 000000b8  00000000  00000000  00002cb6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text._ZN13NewSoftSerial12tx_pin_writeEh 00000018  00000000  00000000  00002d6e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text._ZN13NewSoftSerial5writeEh 000000d2  00000000  00000000  00002d86  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text._ZN13NewSoftSerial11rx_pin_readEv 0000000e  00000000  00000000  00002e58  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .text.__vector_3 00000054  00000000  00000000  00002e66  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text.__vector_4 00000048  00000000  00000000  00002eba  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 16 .text.__vector_5 00000048  00000000  00000000  00002f02  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 17 .text._ZN13NewSoftSerial5setTXEh 0000004a  00000000  00000000  00002f4a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 18 .text._ZN13NewSoftSerial5setRXEh 00000052  00000000  00000000  00002f94  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 19 .text._ZN13NewSoftSerialC2Ehhb 00000042  00000000  00000000  00002fe6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 20 .text._ZN13NewSoftSerial5beginEl 00000114  00000000  00000000  00003028  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 21 .text._ZN13NewSoftSerial3endEv 00000056  00000000  00000000  0000313c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 22 .text._ZN13NewSoftSerialD2Ev 0000000e  00000000  00000000  00003192  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 23 .text._ZN13NewSoftSerial4readEv 0000003c  00000000  00000000  000031a0  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 24 .text._ZN13NewSoftSerial9availableEv 00000028  00000000  00000000  000031dc  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 25 .text._ZN13NewSoftSerial13enable_timer0Eb 00000018  00000000  00000000  00003204  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 26 .text._ZN13NewSoftSerial5flushEv 0000001e  00000000  00000000  0000321c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 27 .rodata._ZTV13NewSoftSerial 0000000a  00000000  00000000  0000323a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 28 .bss._ZN13NewSoftSerial20_receive_buffer_headE 00000001  00000000  00000000  00003244  2**0
                  ALLOC
 29 .bss._ZN13NewSoftSerial20_receive_buffer_tailE 00000001  00000000  00000000  00003244  2**0
                  ALLOC
 30 .bss._ZN13NewSoftSerial15_receive_bufferE 00000040  00000000  00000000  00003244  2**0
                  ALLOC
 31 .bss._ZN13NewSoftSerial13active_objectE 00000002  00000000  00000000  00003244  2**0
                  ALLOC
 32 .progmem.data._ZL5table 00000090  00000000  00000000  00003244  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 33 .comment      00000012  00000000  00000000  000032d4  2**0
                  CONTENTS, READONLY

Disassembly of section .text._ZN13NewSoftSerial12tx_pin_writeEh.part.1:

00000000 <_ZN13NewSoftSerial12tx_pin_writeEh.part.1>:
#endif
}

void NewSoftSerial::flush()
{
  if (active_object == this)
   0:	dc 01       	movw	r26, r24
   2:	17 96       	adiw	r26, 0x07	; 7
   4:	ed 91       	ld	r30, X+
   6:	fc 91       	ld	r31, X
   8:	18 97       	sbiw	r26, 0x08	; 8
   a:	90 81       	ld	r25, Z
   c:	16 96       	adiw	r26, 0x06	; 6
  {
    uint8_t oldSREG = SREG;
   e:	8c 91       	ld	r24, X
    cli();
  10:	80 95       	com	r24
    _receive_buffer_head = _receive_buffer_tail = 0;
  12:	89 23       	and	r24, r25
  14:	80 83       	st	Z, r24
  16:	08 95       	ret

Disassembly of section .text._ZN13NewSoftSerial10tunedDelayEj:

00000000 <_ZN13NewSoftSerial10tunedDelayEj>:
#endif
}

void NewSoftSerial::flush()
{
  if (active_object == this)
   0:	20 e0       	ldi	r18, 0x00	; 0
   2:	01 97       	sbiw	r24, 0x01	; 1
   4:	2f ef       	ldi	r18, 0xFF	; 255
   6:	8f 3f       	cpi	r24, 0xFF	; 255
   8:	92 07       	cpc	r25, r18
   a:	01 f4       	brne	.+0      	; 0xc <_ZN13NewSoftSerial10tunedDelayEj+0xc>
   c:	08 95       	ret

Disassembly of section .text._ZN13NewSoftSerial8activateEv:

00000000 <_ZN13NewSoftSerial8activateEv>:
   0:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   8:	28 17       	cp	r18, r24
   a:	39 07       	cpc	r19, r25
   c:	01 f0       	breq	.+0      	; 0xe <_ZN13NewSoftSerial8activateEv+0xe>
  {
    uint8_t oldSREG = SREG;
   e:	fc 01       	movw	r30, r24
    cli();
  10:	21 89       	ldd	r18, Z+17	; 0x11
    _receive_buffer_head = _receive_buffer_tail = 0;
  12:	2e 7f       	andi	r18, 0xFE	; 254
  14:	21 8b       	std	Z+17, r18	; 0x11
  16:	2f b7       	in	r18, 0x3f	; 63
  18:	f8 94       	cli
    SREG = oldSREG;
  1a:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  }
}
  1e:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  22:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
  26:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  2a:	2f bf       	out	0x3f, r18	; 63
  2c:	81 e0       	ldi	r24, 0x01	; 1
  2e:	08 95       	ret
  30:	80 e0       	ldi	r24, 0x00	; 0
  32:	08 95       	ret

Disassembly of section .text._ZN13NewSoftSerial4recvEv:

00000000 <_ZN13NewSoftSerial4recvEv>:
#endif
}

void NewSoftSerial::flush()
{
  if (active_object == this)
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	ec 01       	movw	r28, r24
  {
    uint8_t oldSREG = SREG;
   e:	ec 81       	ldd	r30, Y+4	; 0x04
    cli();
  10:	fd 81       	ldd	r31, Y+5	; 0x05
    _receive_buffer_head = _receive_buffer_tail = 0;
  12:	9b 81       	ldd	r25, Y+3	; 0x03
  14:	89 89       	ldd	r24, Y+17	; 0x11
  16:	81 ff       	sbrs	r24, 1
  18:	00 c0       	rjmp	.+0      	; 0x1a <_ZN13NewSoftSerial4recvEv+0x1a>
    SREG = oldSREG;
  1a:	80 81       	ld	r24, Z
  }
}
  1c:	89 23       	and	r24, r25
  1e:	01 f4       	brne	.+0      	; 0x20 <_ZN13NewSoftSerial4recvEv+0x20>
  20:	df 91       	pop	r29
  22:	cf 91       	pop	r28
  24:	1f 91       	pop	r17
  26:	0f 91       	pop	r16
  28:	ff 90       	pop	r15
  2a:	ef 90       	pop	r14
  2c:	08 95       	ret
  2e:	80 81       	ld	r24, Z
  30:	89 23       	and	r24, r25
  32:	01 f4       	brne	.+0      	; 0x34 <_ZN13NewSoftSerial4recvEv+0x34>
  34:	89 85       	ldd	r24, Y+9	; 0x09
  36:	9a 85       	ldd	r25, Y+10	; 0x0a
  38:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial4recvEv>
  3c:	88 e0       	ldi	r24, 0x08	; 8
  3e:	e8 2e       	mov	r14, r24
  40:	f1 2c       	mov	r15, r1
  42:	10 e0       	ldi	r17, 0x00	; 0
  44:	01 e0       	ldi	r16, 0x01	; 1
  46:	8b 85       	ldd	r24, Y+11	; 0x0b
  48:	9c 85       	ldd	r25, Y+12	; 0x0c
  4a:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial4recvEv>
  4e:	ec 81       	ldd	r30, Y+4	; 0x04
  50:	fd 81       	ldd	r31, Y+5	; 0x05
  52:	80 81       	ld	r24, Z
  54:	9b 81       	ldd	r25, Y+3	; 0x03
  56:	89 23       	and	r24, r25
  58:	01 f0       	breq	.+0      	; 0x5a <_ZN13NewSoftSerial4recvEv+0x5a>
  5a:	10 2b       	or	r17, r16
  5c:	00 0f       	add	r16, r16
  5e:	81 e0       	ldi	r24, 0x01	; 1
  60:	e8 1a       	sub	r14, r24
  62:	f1 08       	sbc	r15, r1
  64:	01 f4       	brne	.+0      	; 0x66 <_ZN13NewSoftSerial4recvEv+0x66>
  66:	8d 85       	ldd	r24, Y+13	; 0x0d
  68:	9e 85       	ldd	r25, Y+14	; 0x0e
  6a:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial4recvEv>
  6e:	89 89       	ldd	r24, Y+17	; 0x11
  70:	81 fd       	sbrc	r24, 1
  72:	10 95       	com	r17
  74:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  78:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  7c:	90 e0       	ldi	r25, 0x00	; 0
  7e:	01 96       	adiw	r24, 0x01	; 1
  80:	8f 73       	andi	r24, 0x3F	; 63
  82:	99 27       	eor	r25, r25
  84:	28 17       	cp	r18, r24
  86:	19 06       	cpc	r1, r25
  88:	01 f0       	breq	.+0      	; 0x8a <_ZN13NewSoftSerial4recvEv+0x8a>
  8a:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  8e:	f0 e0       	ldi	r31, 0x00	; 0
  90:	e0 50       	subi	r30, 0x00	; 0
  92:	f0 40       	sbci	r31, 0x00	; 0
  94:	10 83       	st	Z, r17
  96:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  9a:	90 e0       	ldi	r25, 0x00	; 0
  9c:	01 96       	adiw	r24, 0x01	; 1
  9e:	8f 73       	andi	r24, 0x3F	; 63
  a0:	99 27       	eor	r25, r25
  a2:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  a6:	00 c0       	rjmp	.+0      	; 0xa8 <_ZN13NewSoftSerial4recvEv+0xa8>
  a8:	80 2f       	mov	r24, r16
  aa:	80 95       	com	r24
  ac:	18 23       	and	r17, r24
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <_ZN13NewSoftSerial4recvEv+0xb0>
  b0:	89 89       	ldd	r24, Y+17	; 0x11
  b2:	81 60       	ori	r24, 0x01	; 1
  b4:	89 8b       	std	Y+17, r24	; 0x11
  b6:	00 c0       	rjmp	.+0      	; 0xb8 <__SREG__+0x79>

Disassembly of section .text._ZN13NewSoftSerial12tx_pin_writeEh:

00000000 <_ZN13NewSoftSerial12tx_pin_writeEh>:
#endif
}

void NewSoftSerial::flush()
{
  if (active_object == this)
   0:	fc 01       	movw	r30, r24
   2:	61 11       	cpse	r22, r1
   4:	00 c0       	rjmp	.+0      	; 0x6 <_ZN13NewSoftSerial12tx_pin_writeEh+0x6>
   6:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13NewSoftSerial12tx_pin_writeEh>
   a:	a7 81       	ldd	r26, Z+7	; 0x07
   c:	b0 85       	ldd	r27, Z+8	; 0x08
  {
    uint8_t oldSREG = SREG;
   e:	9c 91       	ld	r25, X
    cli();
  10:	86 81       	ldd	r24, Z+6	; 0x06
    _receive_buffer_head = _receive_buffer_tail = 0;
  12:	89 2b       	or	r24, r25
  14:	8c 93       	st	X, r24
  16:	08 95       	ret

Disassembly of section .text._ZN13NewSoftSerial5writeEh:

00000000 <_ZN13NewSoftSerial5writeEh>:
#endif
}

void NewSoftSerial::flush()
{
  if (active_object == this)
   0:	df 92       	push	r13
   2:	ef 92       	push	r14
   4:	ff 92       	push	r15
   6:	0f 93       	push	r16
   8:	1f 93       	push	r17
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
  {
    uint8_t oldSREG = SREG;
   e:	fc 01       	movw	r30, r24
    cli();
  10:	27 85       	ldd	r18, Z+15	; 0x0f
    _receive_buffer_head = _receive_buffer_tail = 0;
  12:	30 89       	ldd	r19, Z+16	; 0x10
  14:	23 2b       	or	r18, r19
  16:	01 f4       	brne	.+0      	; 0x18 <_ZN13NewSoftSerial5writeEh+0x18>
  18:	00 c0       	rjmp	.+0      	; 0x1a <_ZN13NewSoftSerial5writeEh+0x1a>
    SREG = oldSREG;
  1a:	16 2f       	mov	r17, r22
  }
}
  1c:	ec 01       	movw	r28, r24
  1e:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial5writeEh>
  22:	df b6       	in	r13, 0x3f	; 63
  24:	f8 94       	cli
  26:	69 89       	ldd	r22, Y+17	; 0x11
  28:	66 95       	lsr	r22
  2a:	61 70       	andi	r22, 0x01	; 1
  2c:	ce 01       	movw	r24, r28
  2e:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial5writeEh>
  32:	8f 85       	ldd	r24, Y+15	; 0x0f
  34:	98 89       	ldd	r25, Y+16	; 0x10
  36:	05 96       	adiw	r24, 0x05	; 5
  38:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial5writeEh>
  3c:	89 89       	ldd	r24, Y+17	; 0x11
  3e:	98 e0       	ldi	r25, 0x08	; 8
  40:	e9 2e       	mov	r14, r25
  42:	f1 2c       	mov	r15, r1
  44:	01 e0       	ldi	r16, 0x01	; 1
  46:	81 ff       	sbrs	r24, 1
  48:	00 c0       	rjmp	.+0      	; 0x4a <_ZN13NewSoftSerial5writeEh+0x4a>
  4a:	81 2f       	mov	r24, r17
  4c:	80 23       	and	r24, r16
  4e:	01 f0       	breq	.+0      	; 0x50 <_ZN13NewSoftSerial5writeEh+0x50>
  50:	ce 01       	movw	r24, r28
  52:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial5writeEh>
  56:	8f 85       	ldd	r24, Y+15	; 0x0f
  58:	98 89       	ldd	r25, Y+16	; 0x10
  5a:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial5writeEh>
  5e:	00 0f       	add	r16, r16
  60:	f1 e0       	ldi	r31, 0x01	; 1
  62:	ef 1a       	sub	r14, r31
  64:	f1 08       	sbc	r15, r1
  66:	01 f4       	brne	.+0      	; 0x68 <_ZN13NewSoftSerial5writeEh+0x68>
  68:	ce 01       	movw	r24, r28
  6a:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial5writeEh>
  6e:	df be       	out	0x3f, r13	; 63
  70:	8f 85       	ldd	r24, Y+15	; 0x0f
  72:	98 89       	ldd	r25, Y+16	; 0x10
  74:	df 91       	pop	r29
  76:	cf 91       	pop	r28
  78:	1f 91       	pop	r17
  7a:	0f 91       	pop	r16
  7c:	ff 90       	pop	r15
  7e:	ef 90       	pop	r14
  80:	df 90       	pop	r13
  82:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13NewSoftSerial5writeEh>
  86:	61 e0       	ldi	r22, 0x01	; 1
  88:	ce 01       	movw	r24, r28
  8a:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial5writeEh>
  8e:	00 c0       	rjmp	.+0      	; 0x90 <_ZN13NewSoftSerial5writeEh+0x90>
  90:	81 2f       	mov	r24, r17
  92:	80 23       	and	r24, r16
  94:	01 f0       	breq	.+0      	; 0x96 <_ZN13NewSoftSerial5writeEh+0x96>
  96:	61 e0       	ldi	r22, 0x01	; 1
  98:	ce 01       	movw	r24, r28
  9a:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial5writeEh>
  9e:	8f 85       	ldd	r24, Y+15	; 0x0f
  a0:	98 89       	ldd	r25, Y+16	; 0x10
  a2:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial5writeEh>
  a6:	00 0f       	add	r16, r16
  a8:	81 e0       	ldi	r24, 0x01	; 1
  aa:	e8 1a       	sub	r14, r24
  ac:	f1 08       	sbc	r15, r1
  ae:	01 f4       	brne	.+0      	; 0xb0 <_ZN13NewSoftSerial5writeEh+0xb0>
  b0:	61 e0       	ldi	r22, 0x01	; 1
  b2:	ce 01       	movw	r24, r28
  b4:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial5writeEh>
  b8:	00 c0       	rjmp	.+0      	; 0xba <_ZN13NewSoftSerial5writeEh+0xba>
  ba:	ce 01       	movw	r24, r28
  bc:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial5writeEh>
  c0:	00 c0       	rjmp	.+0      	; 0xc2 <_ZN13NewSoftSerial5writeEh+0xc2>
  c2:	df 91       	pop	r29
  c4:	cf 91       	pop	r28
  c6:	1f 91       	pop	r17
  c8:	0f 91       	pop	r16
  ca:	ff 90       	pop	r15
  cc:	ef 90       	pop	r14
  ce:	df 90       	pop	r13
  d0:	08 95       	ret

Disassembly of section .text._ZN13NewSoftSerial11rx_pin_readEv:

00000000 <_ZN13NewSoftSerial11rx_pin_readEv>:
#endif
}

void NewSoftSerial::flush()
{
  if (active_object == this)
   0:	fc 01       	movw	r30, r24
   2:	a4 81       	ldd	r26, Z+4	; 0x04
   4:	b5 81       	ldd	r27, Z+5	; 0x05
   6:	9c 91       	ld	r25, X
   8:	83 81       	ldd	r24, Z+3	; 0x03
   a:	89 23       	and	r24, r25
   c:	08 95       	ret

Disassembly of section .text.__vector_3:

00000000 <__vector_3>:
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
  {
    uint8_t oldSREG = SREG;
   e:	4f 93       	push	r20
    cli();
  10:	5f 93       	push	r21
    _receive_buffer_head = _receive_buffer_tail = 0;
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
    SREG = oldSREG;
  1a:	af 93       	push	r26
  }
}
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  26:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  2a:	00 97       	sbiw	r24, 0x00	; 0
  2c:	01 f0       	breq	.+0      	; 0x2e <__vector_3+0x2e>
  2e:	0e 94 00 00 	call	0	; 0x0 <__vector_3>
  32:	ff 91       	pop	r31
  34:	ef 91       	pop	r30
  36:	bf 91       	pop	r27
  38:	af 91       	pop	r26
  3a:	9f 91       	pop	r25
  3c:	8f 91       	pop	r24
  3e:	7f 91       	pop	r23
  40:	6f 91       	pop	r22
  42:	5f 91       	pop	r21
  44:	4f 91       	pop	r20
  46:	3f 91       	pop	r19
  48:	2f 91       	pop	r18
  4a:	0f 90       	pop	r0
  4c:	0f be       	out	0x3f, r0	; 63
  4e:	0f 90       	pop	r0
  50:	1f 90       	pop	r1
  52:	18 95       	reti

Disassembly of section .text.__vector_4:

00000000 <__vector_4>:
#endif
}

void NewSoftSerial::flush()
{
  if (active_object == this)
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
  {
    uint8_t oldSREG = SREG;
   e:	4f 93       	push	r20
    cli();
  10:	5f 93       	push	r21
    _receive_buffer_head = _receive_buffer_tail = 0;
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
    SREG = oldSREG;
  1a:	af 93       	push	r26
  }
}
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	0e 94 00 00 	call	0	; 0x0 <__vector_4>
  26:	ff 91       	pop	r31
  28:	ef 91       	pop	r30
  2a:	bf 91       	pop	r27
  2c:	af 91       	pop	r26
  2e:	9f 91       	pop	r25
  30:	8f 91       	pop	r24
  32:	7f 91       	pop	r23
  34:	6f 91       	pop	r22
  36:	5f 91       	pop	r21
  38:	4f 91       	pop	r20
  3a:	3f 91       	pop	r19
  3c:	2f 91       	pop	r18
  3e:	0f 90       	pop	r0
  40:	0f be       	out	0x3f, r0	; 63
  42:	0f 90       	pop	r0
  44:	1f 90       	pop	r1
  46:	18 95       	reti

Disassembly of section .text.__vector_5:

00000000 <__vector_5>:
#endif
}

void NewSoftSerial::flush()
{
  if (active_object == this)
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
  {
    uint8_t oldSREG = SREG;
   e:	4f 93       	push	r20
    cli();
  10:	5f 93       	push	r21
    _receive_buffer_head = _receive_buffer_tail = 0;
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
    SREG = oldSREG;
  1a:	af 93       	push	r26
  }
}
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	0e 94 00 00 	call	0	; 0x0 <__vector_5>
  26:	ff 91       	pop	r31
  28:	ef 91       	pop	r30
  2a:	bf 91       	pop	r27
  2c:	af 91       	pop	r26
  2e:	9f 91       	pop	r25
  30:	8f 91       	pop	r24
  32:	7f 91       	pop	r23
  34:	6f 91       	pop	r22
  36:	5f 91       	pop	r21
  38:	4f 91       	pop	r20
  3a:	3f 91       	pop	r19
  3c:	2f 91       	pop	r18
  3e:	0f 90       	pop	r0
  40:	0f be       	out	0x3f, r0	; 63
  42:	0f 90       	pop	r0
  44:	1f 90       	pop	r1
  46:	18 95       	reti

Disassembly of section .text._ZN13NewSoftSerial5setTXEh:

00000000 <_ZN13NewSoftSerial5setTXEh>:
#endif
}

void NewSoftSerial::flush()
{
  if (active_object == this)
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
   6:	ec 01       	movw	r28, r24
   8:	16 2f       	mov	r17, r22
   a:	61 e0       	ldi	r22, 0x01	; 1
   c:	81 2f       	mov	r24, r17
  {
    uint8_t oldSREG = SREG;
   e:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial5setTXEh>
    cli();
    _receive_buffer_head = _receive_buffer_tail = 0;
  12:	61 e0       	ldi	r22, 0x01	; 1
  14:	81 2f       	mov	r24, r17
  16:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial5setTXEh>
    SREG = oldSREG;
  1a:	81 2f       	mov	r24, r17
  }
}
  1c:	90 e0       	ldi	r25, 0x00	; 0
  1e:	fc 01       	movw	r30, r24
  20:	e0 50       	subi	r30, 0x00	; 0
  22:	f0 40       	sbci	r31, 0x00	; 0
  24:	e4 91       	lpm	r30, Z
  26:	ee 83       	std	Y+6, r30	; 0x06
  28:	fc 01       	movw	r30, r24
  2a:	e0 50       	subi	r30, 0x00	; 0
  2c:	f0 40       	sbci	r31, 0x00	; 0
  2e:	e4 91       	lpm	r30, Z
  30:	f0 e0       	ldi	r31, 0x00	; 0
  32:	ee 0f       	add	r30, r30
  34:	ff 1f       	adc	r31, r31
  36:	e0 50       	subi	r30, 0x00	; 0
  38:	f0 40       	sbci	r31, 0x00	; 0
  3a:	85 91       	lpm	r24, Z+
  3c:	94 91       	lpm	r25, Z
  3e:	98 87       	std	Y+8, r25	; 0x08
  40:	8f 83       	std	Y+7, r24	; 0x07
  42:	df 91       	pop	r29
  44:	cf 91       	pop	r28
  46:	1f 91       	pop	r17
  48:	08 95       	ret

Disassembly of section .text._ZN13NewSoftSerial5setRXEh:

00000000 <_ZN13NewSoftSerial5setRXEh>:
#endif
}

void NewSoftSerial::flush()
{
  if (active_object == this)
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
   6:	ec 01       	movw	r28, r24
   8:	16 2f       	mov	r17, r22
   a:	60 e0       	ldi	r22, 0x00	; 0
   c:	81 2f       	mov	r24, r17
  {
    uint8_t oldSREG = SREG;
   e:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial5setRXEh>
    cli();
    _receive_buffer_head = _receive_buffer_tail = 0;
  12:	89 89       	ldd	r24, Y+17	; 0x11
  14:	81 fd       	sbrc	r24, 1
  16:	00 c0       	rjmp	.+0      	; 0x18 <_ZN13NewSoftSerial5setRXEh+0x18>
  18:	61 e0       	ldi	r22, 0x01	; 1
    SREG = oldSREG;
  1a:	81 2f       	mov	r24, r17
  }
}
  1c:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial5setRXEh>
  20:	1a 83       	std	Y+2, r17	; 0x02
  22:	81 2f       	mov	r24, r17
  24:	90 e0       	ldi	r25, 0x00	; 0
  26:	fc 01       	movw	r30, r24
  28:	e0 50       	subi	r30, 0x00	; 0
  2a:	f0 40       	sbci	r31, 0x00	; 0
  2c:	e4 91       	lpm	r30, Z
  2e:	eb 83       	std	Y+3, r30	; 0x03
  30:	fc 01       	movw	r30, r24
  32:	e0 50       	subi	r30, 0x00	; 0
  34:	f0 40       	sbci	r31, 0x00	; 0
  36:	e4 91       	lpm	r30, Z
  38:	f0 e0       	ldi	r31, 0x00	; 0
  3a:	ee 0f       	add	r30, r30
  3c:	ff 1f       	adc	r31, r31
  3e:	e0 50       	subi	r30, 0x00	; 0
  40:	f0 40       	sbci	r31, 0x00	; 0
  42:	85 91       	lpm	r24, Z+
  44:	94 91       	lpm	r25, Z
  46:	9d 83       	std	Y+5, r25	; 0x05
  48:	8c 83       	std	Y+4, r24	; 0x04
  4a:	df 91       	pop	r29
  4c:	cf 91       	pop	r28
  4e:	1f 91       	pop	r17
  50:	08 95       	ret

Disassembly of section .text._ZN13NewSoftSerialC2Ehhb:

00000000 <_ZN13NewSoftSerialC1Ehhb>:
#endif
}

void NewSoftSerial::flush()
{
  if (active_object == this)
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
   6:	ec 01       	movw	r28, r24
   8:	16 2f       	mov	r17, r22
   a:	80 e0       	ldi	r24, 0x00	; 0
   c:	90 e0       	ldi	r25, 0x00	; 0
  {
    uint8_t oldSREG = SREG;
   e:	99 83       	std	Y+1, r25	; 0x01
    cli();
  10:	88 83       	st	Y, r24
    _receive_buffer_head = _receive_buffer_tail = 0;
  12:	1a 86       	std	Y+10, r1	; 0x0a
  14:	19 86       	std	Y+9, r1	; 0x09
  16:	1c 86       	std	Y+12, r1	; 0x0c
  18:	1b 86       	std	Y+11, r1	; 0x0b
    SREG = oldSREG;
  1a:	1e 86       	std	Y+14, r1	; 0x0e
  }
}
  1c:	1d 86       	std	Y+13, r1	; 0x0d
  1e:	18 8a       	std	Y+16, r1	; 0x10
  20:	1f 86       	std	Y+15, r1	; 0x0f
  22:	89 89       	ldd	r24, Y+17	; 0x11
  24:	8e 7f       	andi	r24, 0xFE	; 254
  26:	20 fb       	bst	r18, 0
  28:	81 f9       	bld	r24, 1
  2a:	89 8b       	std	Y+17, r24	; 0x11
  2c:	64 2f       	mov	r22, r20
  2e:	ce 01       	movw	r24, r28
  30:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerialC1Ehhb>
  34:	61 2f       	mov	r22, r17
  36:	ce 01       	movw	r24, r28
  38:	df 91       	pop	r29
  3a:	cf 91       	pop	r28
  3c:	1f 91       	pop	r17
  3e:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13NewSoftSerialC1Ehhb>

Disassembly of section .text._ZN13NewSoftSerial5beginEl:

00000000 <_ZN13NewSoftSerial5beginEl>:
#endif
}

void NewSoftSerial::flush()
{
  if (active_object == this)
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	ec 01       	movw	r28, r24
   a:	18 8a       	std	Y+16, r1	; 0x10
   c:	1f 86       	std	Y+15, r1	; 0x0f
  {
    uint8_t oldSREG = SREG;
   e:	1e 86       	std	Y+14, r1	; 0x0e
    cli();
  10:	1d 86       	std	Y+13, r1	; 0x0d
    _receive_buffer_head = _receive_buffer_tail = 0;
  12:	1c 86       	std	Y+12, r1	; 0x0c
  14:	1b 86       	std	Y+11, r1	; 0x0b
  16:	90 e0       	ldi	r25, 0x00	; 0
  18:	80 e0       	ldi	r24, 0x00	; 0
    SREG = oldSREG;
  1a:	fc 01       	movw	r30, r24
  }
}
  1c:	e0 50       	subi	r30, 0x00	; 0
  1e:	f0 40       	sbci	r31, 0x00	; 0
  20:	05 91       	lpm	r16, Z+
  22:	15 91       	lpm	r17, Z+
  24:	25 91       	lpm	r18, Z+
  26:	34 91       	lpm	r19, Z
  28:	04 17       	cp	r16, r20
  2a:	15 07       	cpc	r17, r21
  2c:	26 07       	cpc	r18, r22
  2e:	37 07       	cpc	r19, r23
  30:	01 f0       	breq	.+0      	; 0x32 <_ZN13NewSoftSerial5beginEl+0x32>
  32:	00 c0       	rjmp	.+0      	; 0x34 <_ZN13NewSoftSerial5beginEl+0x34>
  34:	fc 01       	movw	r30, r24
  36:	e0 50       	subi	r30, 0x00	; 0
  38:	f0 40       	sbci	r31, 0x00	; 0
  3a:	25 91       	lpm	r18, Z+
  3c:	34 91       	lpm	r19, Z
  3e:	3a 87       	std	Y+10, r19	; 0x0a
  40:	29 87       	std	Y+9, r18	; 0x09
  42:	fc 01       	movw	r30, r24
  44:	e0 50       	subi	r30, 0x00	; 0
  46:	f0 40       	sbci	r31, 0x00	; 0
  48:	25 91       	lpm	r18, Z+
  4a:	34 91       	lpm	r19, Z
  4c:	3c 87       	std	Y+12, r19	; 0x0c
  4e:	2b 87       	std	Y+11, r18	; 0x0b
  50:	fc 01       	movw	r30, r24
  52:	e0 50       	subi	r30, 0x00	; 0
  54:	f0 40       	sbci	r31, 0x00	; 0
  56:	25 91       	lpm	r18, Z+
  58:	34 91       	lpm	r19, Z
  5a:	3e 87       	std	Y+14, r19	; 0x0e
  5c:	2d 87       	std	Y+13, r18	; 0x0d
  5e:	fc 01       	movw	r30, r24
  60:	e0 50       	subi	r30, 0x00	; 0
  62:	f0 40       	sbci	r31, 0x00	; 0
  64:	85 91       	lpm	r24, Z+
  66:	94 91       	lpm	r25, Z
  68:	98 8b       	std	Y+16, r25	; 0x10
  6a:	8f 87       	std	Y+15, r24	; 0x0f
  6c:	8d 85       	ldd	r24, Y+13	; 0x0d
  6e:	9e 85       	ldd	r25, Y+14	; 0x0e
  70:	89 2b       	or	r24, r25
  72:	01 f0       	breq	.+0      	; 0x74 <_ZN13NewSoftSerial5beginEl+0x74>
  74:	8a 81       	ldd	r24, Y+2	; 0x02
  76:	86 31       	cpi	r24, 0x16	; 22
  78:	00 f4       	brcc	.+0      	; 0x7a <_ZN13NewSoftSerial5beginEl+0x7a>
  7a:	90 91 68 00 	lds	r25, 0x0068	; 0x800068 <__SREG__+0x800029>
  7e:	88 30       	cpi	r24, 0x08	; 8
  80:	00 f0       	brcs	.+0      	; 0x82 <_ZN13NewSoftSerial5beginEl+0x82>
  82:	21 e0       	ldi	r18, 0x01	; 1
  84:	8e 30       	cpi	r24, 0x0E	; 14
  86:	00 f4       	brcc	.+0      	; 0x88 <_ZN13NewSoftSerial5beginEl+0x88>
  88:	20 e0       	ldi	r18, 0x00	; 0
  8a:	81 e0       	ldi	r24, 0x01	; 1
  8c:	00 c0       	rjmp	.+0      	; 0x8e <_ZN13NewSoftSerial5beginEl+0x8e>
  8e:	88 0f       	add	r24, r24
  90:	2a 95       	dec	r18
  92:	02 f4       	brpl	.+0      	; 0x94 <_ZN13NewSoftSerial5beginEl+0x94>
  94:	89 2b       	or	r24, r25
  96:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <__SREG__+0x800029>
  9a:	9a 81       	ldd	r25, Y+2	; 0x02
  9c:	ed e6       	ldi	r30, 0x6D	; 109
  9e:	f0 e0       	ldi	r31, 0x00	; 0
  a0:	98 30       	cpi	r25, 0x08	; 8
  a2:	00 f0       	brcs	.+0      	; 0xa4 <_ZN13NewSoftSerial5beginEl+0xa4>
  a4:	eb e6       	ldi	r30, 0x6B	; 107
  a6:	f0 e0       	ldi	r31, 0x00	; 0
  a8:	9e 30       	cpi	r25, 0x0E	; 14
  aa:	00 f0       	brcs	.+0      	; 0xac <_ZN13NewSoftSerial5beginEl+0xac>
  ac:	ec e6       	ldi	r30, 0x6C	; 108
  ae:	f0 e0       	ldi	r31, 0x00	; 0
  b0:	96 31       	cpi	r25, 0x16	; 22
  b2:	00 f0       	brcs	.+0      	; 0xb4 <_ZN13NewSoftSerial5beginEl+0xb4>
  b4:	f0 e0       	ldi	r31, 0x00	; 0
  b6:	e0 e0       	ldi	r30, 0x00	; 0
  b8:	40 81       	ld	r20, Z
  ba:	29 2f       	mov	r18, r25
  bc:	30 e0       	ldi	r19, 0x00	; 0
  be:	98 30       	cpi	r25, 0x08	; 8
  c0:	00 f4       	brcc	.+0      	; 0xc2 <_ZN13NewSoftSerial5beginEl+0xc2>
  c2:	81 e0       	ldi	r24, 0x01	; 1
  c4:	00 c0       	rjmp	.+0      	; 0xc6 <_ZN13NewSoftSerial5beginEl+0xc6>
  c6:	88 0f       	add	r24, r24
  c8:	9a 95       	dec	r25
  ca:	02 f4       	brpl	.+0      	; 0xcc <_ZN13NewSoftSerial5beginEl+0xcc>
  cc:	84 2b       	or	r24, r20
  ce:	80 83       	st	Z, r24
  d0:	8f 85       	ldd	r24, Y+15	; 0x0f
  d2:	98 89       	ldd	r25, Y+16	; 0x10
  d4:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial5beginEl>
  d8:	ce 01       	movw	r24, r28
  da:	df 91       	pop	r29
  dc:	cf 91       	pop	r28
  de:	1f 91       	pop	r17
  e0:	0f 91       	pop	r16
  e2:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13NewSoftSerial5beginEl>
  e6:	0c 96       	adiw	r24, 0x0c	; 12
  e8:	80 39       	cpi	r24, 0x90	; 144
  ea:	91 05       	cpc	r25, r1
  ec:	01 f0       	breq	.+0      	; 0xee <_ZN13NewSoftSerial5beginEl+0xee>
  ee:	00 c0       	rjmp	.+0      	; 0xf0 <_ZN13NewSoftSerial5beginEl+0xf0>
  f0:	1a 86       	std	Y+10, r1	; 0x0a
  f2:	19 86       	std	Y+9, r1	; 0x09
  f4:	00 c0       	rjmp	.+0      	; 0xf6 <_ZN13NewSoftSerial5beginEl+0xf6>
  f6:	84 e0       	ldi	r24, 0x04	; 4
  f8:	00 c0       	rjmp	.+0      	; 0xfa <_ZN13NewSoftSerial5beginEl+0xfa>
  fa:	9e 30       	cpi	r25, 0x0E	; 14
  fc:	00 f4       	brcc	.+0      	; 0xfe <_ZN13NewSoftSerial5beginEl+0xfe>
  fe:	28 50       	subi	r18, 0x08	; 8
 100:	31 09       	sbc	r19, r1
 102:	81 e0       	ldi	r24, 0x01	; 1
 104:	00 c0       	rjmp	.+0      	; 0x106 <_ZN13NewSoftSerial5beginEl+0x106>
 106:	88 0f       	add	r24, r24
 108:	2a 95       	dec	r18
 10a:	02 f4       	brpl	.+0      	; 0x10c <_ZN13NewSoftSerial5beginEl+0x10c>
 10c:	00 c0       	rjmp	.+0      	; 0x10e <_ZN13NewSoftSerial5beginEl+0x10e>
 10e:	2e 50       	subi	r18, 0x0E	; 14
 110:	31 09       	sbc	r19, r1
 112:	00 c0       	rjmp	.+0      	; 0x114 <__SREG__+0xd5>

Disassembly of section .text._ZN13NewSoftSerial3endEv:

00000000 <_ZN13NewSoftSerial3endEv>:
#endif
}

void NewSoftSerial::flush()
{
  if (active_object == this)
   0:	fc 01       	movw	r30, r24
   2:	22 81       	ldd	r18, Z+2	; 0x02
   4:	26 31       	cpi	r18, 0x16	; 22
   6:	00 f4       	brcc	.+0      	; 0x8 <_ZN13NewSoftSerial3endEv+0x8>
   8:	ed e6       	ldi	r30, 0x6D	; 109
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	28 30       	cpi	r18, 0x08	; 8
  {
    uint8_t oldSREG = SREG;
   e:	00 f0       	brcs	.+0      	; 0x10 <_ZN13NewSoftSerial3endEv+0x10>
    cli();
  10:	eb e6       	ldi	r30, 0x6B	; 107
    _receive_buffer_head = _receive_buffer_tail = 0;
  12:	f0 e0       	ldi	r31, 0x00	; 0
  14:	2e 30       	cpi	r18, 0x0E	; 14
  16:	00 f0       	brcs	.+0      	; 0x18 <_ZN13NewSoftSerial3endEv+0x18>
  18:	ec e6       	ldi	r30, 0x6C	; 108
    SREG = oldSREG;
  1a:	f0 e0       	ldi	r31, 0x00	; 0
  }
}
  1c:	30 81       	ld	r19, Z
  1e:	42 2f       	mov	r20, r18
  20:	50 e0       	ldi	r21, 0x00	; 0
  22:	28 30       	cpi	r18, 0x08	; 8
  24:	00 f4       	brcc	.+0      	; 0x26 <_ZN13NewSoftSerial3endEv+0x26>
  26:	81 e0       	ldi	r24, 0x01	; 1
  28:	90 e0       	ldi	r25, 0x00	; 0
  2a:	00 c0       	rjmp	.+0      	; 0x2c <_ZN13NewSoftSerial3endEv+0x2c>
  2c:	88 0f       	add	r24, r24
  2e:	2a 95       	dec	r18
  30:	02 f4       	brpl	.+0      	; 0x32 <_ZN13NewSoftSerial3endEv+0x32>
  32:	80 95       	com	r24
  34:	83 23       	and	r24, r19
  36:	80 83       	st	Z, r24
  38:	08 95       	ret
  3a:	2e 30       	cpi	r18, 0x0E	; 14
  3c:	00 f4       	brcc	.+0      	; 0x3e <_ZN13NewSoftSerial3endEv+0x3e>
  3e:	48 50       	subi	r20, 0x08	; 8
  40:	51 09       	sbc	r21, r1
  42:	81 e0       	ldi	r24, 0x01	; 1
  44:	90 e0       	ldi	r25, 0x00	; 0
  46:	00 c0       	rjmp	.+0      	; 0x48 <_ZN13NewSoftSerial3endEv+0x48>
  48:	88 0f       	add	r24, r24
  4a:	4a 95       	dec	r20
  4c:	02 f4       	brpl	.+0      	; 0x4e <_ZN13NewSoftSerial3endEv+0x4e>
  4e:	00 c0       	rjmp	.+0      	; 0x50 <_ZN13NewSoftSerial3endEv+0x50>
  50:	4e 50       	subi	r20, 0x0E	; 14
  52:	51 09       	sbc	r21, r1
  54:	00 c0       	rjmp	.+0      	; 0x56 <__SREG__+0x17>

Disassembly of section .text._ZN13NewSoftSerialD2Ev:

00000000 <_ZN13NewSoftSerialD1Ev>:
#endif
}

void NewSoftSerial::flush()
{
  if (active_object == this)
   0:	20 e0       	ldi	r18, 0x00	; 0
   2:	30 e0       	ldi	r19, 0x00	; 0
   4:	fc 01       	movw	r30, r24
   6:	31 83       	std	Z+1, r19	; 0x01
   8:	20 83       	st	Z, r18
   a:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13NewSoftSerialD1Ev>

Disassembly of section .text._ZN13NewSoftSerial4readEv:

00000000 <_ZN13NewSoftSerial4readEv>:
   0:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial4readEv>
   4:	81 11       	cpse	r24, r1
   6:	00 c0       	rjmp	.+0      	; 0x8 <_ZN13NewSoftSerial4readEv+0x8>
   8:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   c:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  {
    uint8_t oldSREG = SREG;
    cli();
  10:	98 17       	cp	r25, r24
    _receive_buffer_head = _receive_buffer_tail = 0;
  12:	01 f0       	breq	.+0      	; 0x14 <_ZN13NewSoftSerial4readEv+0x14>
  14:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  18:	f0 e0       	ldi	r31, 0x00	; 0
    SREG = oldSREG;
  1a:	e0 50       	subi	r30, 0x00	; 0
  }
}
  1c:	f0 40       	sbci	r31, 0x00	; 0
  1e:	80 81       	ld	r24, Z
  20:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  24:	30 e0       	ldi	r19, 0x00	; 0
  26:	2f 5f       	subi	r18, 0xFF	; 255
  28:	3f 4f       	sbci	r19, 0xFF	; 255
  2a:	2f 73       	andi	r18, 0x3F	; 63
  2c:	33 27       	eor	r19, r19
  2e:	20 93 00 00 	sts	0x0000, r18	; 0x800000 <__SREG__+0x7fffc1>
  32:	90 e0       	ldi	r25, 0x00	; 0
  34:	08 95       	ret
  36:	8f ef       	ldi	r24, 0xFF	; 255
  38:	9f ef       	ldi	r25, 0xFF	; 255
  3a:	08 95       	ret

Disassembly of section .text._ZN13NewSoftSerial9availableEv:

00000000 <_ZN13NewSoftSerial9availableEv>:
#endif
}

void NewSoftSerial::flush()
{
  if (active_object == this)
   0:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial9availableEv>
   4:	81 11       	cpse	r24, r1
   6:	00 c0       	rjmp	.+0      	; 0x8 <_ZN13NewSoftSerial9availableEv+0x8>
   8:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   c:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  {
    uint8_t oldSREG = SREG;
    cli();
  10:	90 e0       	ldi	r25, 0x00	; 0
    _receive_buffer_head = _receive_buffer_tail = 0;
  12:	80 5c       	subi	r24, 0xC0	; 192
  14:	9f 4f       	sbci	r25, 0xFF	; 255
  16:	82 1b       	sub	r24, r18
  18:	91 09       	sbc	r25, r1
    SREG = oldSREG;
  1a:	60 e4       	ldi	r22, 0x40	; 64
  }
}
  1c:	70 e0       	ldi	r23, 0x00	; 0
  1e:	0e 94 00 00 	call	0	; 0x0 <_ZN13NewSoftSerial9availableEv>
  22:	08 95       	ret
  24:	80 e0       	ldi	r24, 0x00	; 0
  26:	08 95       	ret

Disassembly of section .text._ZN13NewSoftSerial13enable_timer0Eb:

00000000 <_ZN13NewSoftSerial13enable_timer0Eb>:
#endif
}

void NewSoftSerial::flush()
{
  if (active_object == this)
   0:	88 23       	and	r24, r24
   2:	01 f0       	breq	.+0      	; 0x4 <_ZN13NewSoftSerial13enable_timer0Eb+0x4>
   4:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__SREG__+0x80002f>
   8:	81 60       	ori	r24, 0x01	; 1
   a:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__SREG__+0x80002f>
  {
    uint8_t oldSREG = SREG;
   e:	08 95       	ret
    cli();
  10:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__SREG__+0x80002f>
    _receive_buffer_head = _receive_buffer_tail = 0;
  14:	8e 7f       	andi	r24, 0xFE	; 254
  16:	00 c0       	rjmp	.+0      	; 0x18 <__zero_reg__+0x17>

Disassembly of section .text._ZN13NewSoftSerial5flushEv:

00000000 <_ZN13NewSoftSerial5flushEv>:
#endif
}

void NewSoftSerial::flush()
{
  if (active_object == this)
   0:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   8:	28 17       	cp	r18, r24
   a:	39 07       	cpc	r19, r25
   c:	01 f4       	brne	.+0      	; 0xe <_ZN13NewSoftSerial5flushEv+0xe>
  {
    uint8_t oldSREG = SREG;
   e:	8f b7       	in	r24, 0x3f	; 63
    cli();
  10:	f8 94       	cli
    _receive_buffer_head = _receive_buffer_tail = 0;
  12:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  16:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
    SREG = oldSREG;
  1a:	8f bf       	out	0x3f, r24	; 63
  }
}
  1c:	08 95       	ret

LiquidCrystal.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .group        00000008  00000000  00000000  00000034  2**2
                  CONTENTS, READONLY, EXCLUDE, GROUP, LINK_ONCE_DISCARD
  1 .group        00000008  00000000  00000000  0000003c  2**2
                  CONTENTS, READONLY, EXCLUDE, GROUP, LINK_ONCE_DISCARD
  2 .group        00000008  00000000  00000000  00000044  2**2
                  CONTENTS, READONLY, EXCLUDE, GROUP, LINK_ONCE_DISCARD
  3 .text         00000000  00000000  00000000  0000004c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .data         00000000  00000000  00000000  0000004c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  5 .bss          00000000  00000000  00000000  0000004c  2**0
                  ALLOC
  6 .stab         00001440  00000000  00000000  0000004c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .stabstr      00001aa4  00000000  00000000  0000148c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .text._ZN13LiquidCrystal11pulseEnableEv 0000003a  00000000  00000000  00002f30  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text._ZN13LiquidCrystal10write4bitsEh 00000064  00000000  00000000  00002f6a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text._ZN13LiquidCrystal10write8bitsEh 00000064  00000000  00000000  00002fce  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text._ZN13LiquidCrystal4sendEhh 00000052  00000000  00000000  00003032  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text._ZN13LiquidCrystal7commandEh 00000006  00000000  00000000  00003084  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text._ZN13LiquidCrystal5clearEv 0000000e  00000000  00000000  0000308a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text._ZN13LiquidCrystal4homeEv 0000000e  00000000  00000000  00003098  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .rodata       00000008  00000000  00000000  000030a6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 16 .text._ZN13LiquidCrystal9setCursorEhh 00000060  00000000  00000000  000030ae  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 17 .text._ZN13LiquidCrystal9noDisplayEv 0000000e  00000000  00000000  0000310e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 18 .text._ZN13LiquidCrystal7displayEv 00000010  00000000  00000000  0000311c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 19 .text._ZN13LiquidCrystal5beginEhhh 000000dc  00000000  00000000  0000312c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 20 .text._ZN13LiquidCrystal4initEhhhhhhhhhhhh 0000008c  00000000  00000000  00003208  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 21 .text._ZN13LiquidCrystalC2Ehhhhhhhhhhh 00000056  00000000  00000000  00003294  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 22 .text._ZN13LiquidCrystalC2Ehhhhhhhhhh 00000054  00000000  00000000  000032ea  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 23 .text._ZN13LiquidCrystalC2Ehhhhhhh 00000044  00000000  00000000  0000333e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 24 .text._ZN13LiquidCrystalC2Ehhhhhh 00000044  00000000  00000000  00003382  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 25 .text._ZN13LiquidCrystal8noCursorEv 0000000e  00000000  00000000  000033c6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 26 .text._ZN13LiquidCrystal6cursorEv 00000010  00000000  00000000  000033d4  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 27 .text._ZN13LiquidCrystal7noBlinkEv 0000000e  00000000  00000000  000033e4  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 28 .text._ZN13LiquidCrystal5blinkEv 00000010  00000000  00000000  000033f2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 29 .text._ZN13LiquidCrystal17scrollDisplayLeftEv 00000006  00000000  00000000  00003402  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 30 .text._ZN13LiquidCrystal18scrollDisplayRightEv 00000006  00000000  00000000  00003408  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 31 .text._ZN13LiquidCrystal11leftToRightEv 00000010  00000000  00000000  0000340e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 32 .text._ZN13LiquidCrystal11rightToLeftEv 0000000e  00000000  00000000  0000341e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 33 .text._ZN13LiquidCrystal10autoscrollEv 00000010  00000000  00000000  0000342c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 34 .text._ZN13LiquidCrystal12noAutoscrollEv 0000000e  00000000  00000000  0000343c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 35 .text._ZN13LiquidCrystal10createCharEhPh 00000050  00000000  00000000  0000344a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 36 .text._ZN13LiquidCrystal5writeEh 00000006  00000000  00000000  0000349a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 37 .rodata._ZTV13LiquidCrystal 0000000a  00000000  00000000  000034a0  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 38 .comment      00000012  00000000  00000000  000034aa  2**0
                  CONTENTS, READONLY

Disassembly of section .text._ZN13LiquidCrystal11pulseEnableEv:

00000000 <_ZN13LiquidCrystal11pulseEnableEv>:
inline void LiquidCrystal::command(uint8_t value) {
  send(value, LOW);
}

inline void LiquidCrystal::write(uint8_t value) {
  send(value, HIGH);
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
   6:	60 e0       	ldi	r22, 0x00	; 0
   8:	8c 81       	ldd	r24, Y+4	; 0x04
   a:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal11pulseEnableEv>
   e:	81 e0       	ldi	r24, 0x01	; 1
  10:	90 e0       	ldi	r25, 0x00	; 0
  12:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal11pulseEnableEv>
  16:	61 e0       	ldi	r22, 0x01	; 1
  18:	8c 81       	ldd	r24, Y+4	; 0x04
  1a:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal11pulseEnableEv>
  1e:	81 e0       	ldi	r24, 0x01	; 1
  20:	90 e0       	ldi	r25, 0x00	; 0
  22:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal11pulseEnableEv>
  26:	60 e0       	ldi	r22, 0x00	; 0
  28:	8c 81       	ldd	r24, Y+4	; 0x04
  2a:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal11pulseEnableEv>
  2e:	84 e6       	ldi	r24, 0x64	; 100
  30:	90 e0       	ldi	r25, 0x00	; 0
  32:	df 91       	pop	r29
  34:	cf 91       	pop	r28
  36:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal11pulseEnableEv>

Disassembly of section .text._ZN13LiquidCrystal10write4bitsEh:

00000000 <_ZN13LiquidCrystal10write4bitsEh>:
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	6c 01       	movw	r12, r24
  12:	8c 01       	movw	r16, r24
  14:	0b 5f       	subi	r16, 0xFB	; 251
  16:	1f 4f       	sbci	r17, 0xFF	; 255
  18:	d0 e0       	ldi	r29, 0x00	; 0
  1a:	c0 e0       	ldi	r28, 0x00	; 0
  1c:	e6 2e       	mov	r14, r22
  1e:	f1 2c       	mov	r15, r1
  20:	61 e0       	ldi	r22, 0x01	; 1
  22:	f8 01       	movw	r30, r16
  24:	81 91       	ld	r24, Z+
  26:	8f 01       	movw	r16, r30
  28:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal10write4bitsEh>
  2c:	b7 01       	movw	r22, r14
  2e:	0c 2e       	mov	r0, r28
  30:	00 c0       	rjmp	.+0      	; 0x32 <_ZN13LiquidCrystal10write4bitsEh+0x32>
  32:	75 95       	asr	r23
  34:	67 95       	ror	r22
  36:	0a 94       	dec	r0
  38:	02 f4       	brpl	.+0      	; 0x3a <_ZN13LiquidCrystal10write4bitsEh+0x3a>
  3a:	61 70       	andi	r22, 0x01	; 1
  3c:	f8 01       	movw	r30, r16
  3e:	31 97       	sbiw	r30, 0x01	; 1
  40:	80 81       	ld	r24, Z
  42:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal10write4bitsEh>
  46:	21 96       	adiw	r28, 0x01	; 1
  48:	c4 30       	cpi	r28, 0x04	; 4
  4a:	d1 05       	cpc	r29, r1
  4c:	01 f4       	brne	.+0      	; 0x4e <_ZN13LiquidCrystal10write4bitsEh+0x4e>
  4e:	c6 01       	movw	r24, r12
  50:	df 91       	pop	r29
  52:	cf 91       	pop	r28
  54:	1f 91       	pop	r17
  56:	0f 91       	pop	r16
  58:	ff 90       	pop	r15
  5a:	ef 90       	pop	r14
  5c:	df 90       	pop	r13
  5e:	cf 90       	pop	r12
  60:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal10write4bitsEh>

Disassembly of section .text._ZN13LiquidCrystal10write8bitsEh:

00000000 <_ZN13LiquidCrystal10write8bitsEh>:
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	6c 01       	movw	r12, r24
  12:	8c 01       	movw	r16, r24
  14:	0b 5f       	subi	r16, 0xFB	; 251
  16:	1f 4f       	sbci	r17, 0xFF	; 255
  18:	d0 e0       	ldi	r29, 0x00	; 0
  1a:	c0 e0       	ldi	r28, 0x00	; 0
  1c:	e6 2e       	mov	r14, r22
  1e:	f1 2c       	mov	r15, r1
  20:	61 e0       	ldi	r22, 0x01	; 1
  22:	f8 01       	movw	r30, r16
  24:	81 91       	ld	r24, Z+
  26:	8f 01       	movw	r16, r30
  28:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal10write8bitsEh>
  2c:	b7 01       	movw	r22, r14
  2e:	0c 2e       	mov	r0, r28
  30:	00 c0       	rjmp	.+0      	; 0x32 <_ZN13LiquidCrystal10write8bitsEh+0x32>
  32:	75 95       	asr	r23
  34:	67 95       	ror	r22
  36:	0a 94       	dec	r0
  38:	02 f4       	brpl	.+0      	; 0x3a <_ZN13LiquidCrystal10write8bitsEh+0x3a>
  3a:	61 70       	andi	r22, 0x01	; 1
  3c:	f8 01       	movw	r30, r16
  3e:	31 97       	sbiw	r30, 0x01	; 1
  40:	80 81       	ld	r24, Z
  42:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal10write8bitsEh>
  46:	21 96       	adiw	r28, 0x01	; 1
  48:	c8 30       	cpi	r28, 0x08	; 8
  4a:	d1 05       	cpc	r29, r1
  4c:	01 f4       	brne	.+0      	; 0x4e <_ZN13LiquidCrystal10write8bitsEh+0x4e>
  4e:	c6 01       	movw	r24, r12
  50:	df 91       	pop	r29
  52:	cf 91       	pop	r28
  54:	1f 91       	pop	r17
  56:	0f 91       	pop	r16
  58:	ff 90       	pop	r15
  5a:	ef 90       	pop	r14
  5c:	df 90       	pop	r13
  5e:	cf 90       	pop	r12
  60:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal10write8bitsEh>

Disassembly of section .text._ZN13LiquidCrystal4sendEhh:

00000000 <_ZN13LiquidCrystal4sendEhh>:
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
   6:	ec 01       	movw	r28, r24
   8:	16 2f       	mov	r17, r22
   a:	64 2f       	mov	r22, r20
   c:	8a 81       	ldd	r24, Y+2	; 0x02
   e:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal4sendEhh>
  12:	8b 81       	ldd	r24, Y+3	; 0x03
  14:	8f 3f       	cpi	r24, 0xFF	; 255
  16:	01 f0       	breq	.+0      	; 0x18 <_ZN13LiquidCrystal4sendEhh+0x18>
  18:	60 e0       	ldi	r22, 0x00	; 0
  1a:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal4sendEhh>
  1e:	8d 85       	ldd	r24, Y+13	; 0x0d
  20:	61 2f       	mov	r22, r17
  22:	84 ff       	sbrs	r24, 4
  24:	00 c0       	rjmp	.+0      	; 0x26 <_ZN13LiquidCrystal4sendEhh+0x26>
  26:	ce 01       	movw	r24, r28
  28:	df 91       	pop	r29
  2a:	cf 91       	pop	r28
  2c:	1f 91       	pop	r17
  2e:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal4sendEhh>
  32:	70 e0       	ldi	r23, 0x00	; 0
  34:	84 e0       	ldi	r24, 0x04	; 4
  36:	75 95       	asr	r23
  38:	67 95       	ror	r22
  3a:	8a 95       	dec	r24
  3c:	01 f4       	brne	.+0      	; 0x3e <_ZN13LiquidCrystal4sendEhh+0x3e>
  3e:	ce 01       	movw	r24, r28
  40:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal4sendEhh>
  44:	61 2f       	mov	r22, r17
  46:	ce 01       	movw	r24, r28
  48:	df 91       	pop	r29
  4a:	cf 91       	pop	r28
  4c:	1f 91       	pop	r17
  4e:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal4sendEhh>

Disassembly of section .text._ZN13LiquidCrystal7commandEh:

00000000 <_ZN13LiquidCrystal7commandEh>:
   0:	40 e0       	ldi	r20, 0x00	; 0
   2:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal7commandEh>

Disassembly of section .text._ZN13LiquidCrystal5clearEv:

00000000 <_ZN13LiquidCrystal5clearEv>:
   0:	61 e0       	ldi	r22, 0x01	; 1
   2:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5clearEv>
   6:	80 ed       	ldi	r24, 0xD0	; 208
   8:	97 e0       	ldi	r25, 0x07	; 7
   a:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal5clearEv>

Disassembly of section .text._ZN13LiquidCrystal4homeEv:

00000000 <_ZN13LiquidCrystal4homeEv>:
   0:	62 e0       	ldi	r22, 0x02	; 2
   2:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal4homeEv>
   6:	80 ed       	ldi	r24, 0xD0	; 208
   8:	97 e0       	ldi	r25, 0x07	; 7
   a:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal4homeEv>

Disassembly of section .text._ZN13LiquidCrystal9setCursorEhh:

00000000 <_ZN13LiquidCrystal9setCursorEhh>:
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	28 97       	sbiw	r28, 0x08	; 8
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	28 e0       	ldi	r18, 0x08	; 8
  16:	e0 e0       	ldi	r30, 0x00	; 0
  18:	f0 e0       	ldi	r31, 0x00	; 0
  1a:	de 01       	movw	r26, r28
  1c:	11 96       	adiw	r26, 0x01	; 1
  1e:	01 90       	ld	r0, Z+
  20:	0d 92       	st	X+, r0
  22:	2a 95       	dec	r18
  24:	01 f4       	brne	.+0      	; 0x26 <_ZN13LiquidCrystal9setCursorEhh+0x26>
  26:	fc 01       	movw	r30, r24
  28:	21 89       	ldd	r18, Z+17	; 0x11
  2a:	24 17       	cp	r18, r20
  2c:	00 f4       	brcc	.+0      	; 0x2e <_ZN13LiquidCrystal9setCursorEhh+0x2e>
  2e:	4f ef       	ldi	r20, 0xFF	; 255
  30:	42 0f       	add	r20, r18
  32:	50 e0       	ldi	r21, 0x00	; 0
  34:	44 0f       	add	r20, r20
  36:	55 1f       	adc	r21, r21
  38:	21 e0       	ldi	r18, 0x01	; 1
  3a:	30 e0       	ldi	r19, 0x00	; 0
  3c:	2c 0f       	add	r18, r28
  3e:	3d 1f       	adc	r19, r29
  40:	42 0f       	add	r20, r18
  42:	53 1f       	adc	r21, r19
  44:	fa 01       	movw	r30, r20
  46:	20 81       	ld	r18, Z
  48:	62 0f       	add	r22, r18
  4a:	60 68       	ori	r22, 0x80	; 128
  4c:	28 96       	adiw	r28, 0x08	; 8
  4e:	0f b6       	in	r0, 0x3f	; 63
  50:	f8 94       	cli
  52:	de bf       	out	0x3e, r29	; 62
  54:	0f be       	out	0x3f, r0	; 63
  56:	cd bf       	out	0x3d, r28	; 61
  58:	df 91       	pop	r29
  5a:	cf 91       	pop	r28
  5c:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal9setCursorEhh>

Disassembly of section .text._ZN13LiquidCrystal9noDisplayEv:

00000000 <_ZN13LiquidCrystal9noDisplayEv>:
   0:	fc 01       	movw	r30, r24
   2:	66 85       	ldd	r22, Z+14	; 0x0e
   4:	6b 7f       	andi	r22, 0xFB	; 251
   6:	66 87       	std	Z+14, r22	; 0x0e
   8:	68 60       	ori	r22, 0x08	; 8
   a:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal9noDisplayEv>

Disassembly of section .text._ZN13LiquidCrystal7displayEv:

00000000 <_ZN13LiquidCrystal7displayEv>:
   0:	fc 01       	movw	r30, r24
   2:	66 85       	ldd	r22, Z+14	; 0x0e
   4:	26 2f       	mov	r18, r22
   6:	24 60       	ori	r18, 0x04	; 4
   8:	26 87       	std	Z+14, r18	; 0x0e
   a:	6c 60       	ori	r22, 0x0C	; 12
   c:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal7displayEv>

Disassembly of section .text._ZN13LiquidCrystal5beginEhhh:

00000000 <_ZN13LiquidCrystal5beginEhhh>:
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
   6:	42 30       	cpi	r20, 0x02	; 2
   8:	00 f0       	brcs	.+0      	; 0xa <_ZN13LiquidCrystal5beginEhhh+0xa>
   a:	8d 85       	ldd	r24, Y+13	; 0x0d
   c:	88 60       	ori	r24, 0x08	; 8
   e:	8d 87       	std	Y+13, r24	; 0x0d
  10:	49 8b       	std	Y+17, r20	; 0x11
  12:	1a 8a       	std	Y+18, r1	; 0x12
  14:	22 23       	and	r18, r18
  16:	01 f0       	breq	.+0      	; 0x18 <_ZN13LiquidCrystal5beginEhhh+0x18>
  18:	41 30       	cpi	r20, 0x01	; 1
  1a:	01 f4       	brne	.+0      	; 0x1c <_ZN13LiquidCrystal5beginEhhh+0x1c>
  1c:	8d 85       	ldd	r24, Y+13	; 0x0d
  1e:	84 60       	ori	r24, 0x04	; 4
  20:	8d 87       	std	Y+13, r24	; 0x0d
  22:	80 e5       	ldi	r24, 0x50	; 80
  24:	93 ec       	ldi	r25, 0xC3	; 195
  26:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  2a:	60 e0       	ldi	r22, 0x00	; 0
  2c:	8a 81       	ldd	r24, Y+2	; 0x02
  2e:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  32:	60 e0       	ldi	r22, 0x00	; 0
  34:	8c 81       	ldd	r24, Y+4	; 0x04
  36:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  3a:	8b 81       	ldd	r24, Y+3	; 0x03
  3c:	8f 3f       	cpi	r24, 0xFF	; 255
  3e:	01 f0       	breq	.+0      	; 0x40 <_ZN13LiquidCrystal5beginEhhh+0x40>
  40:	60 e0       	ldi	r22, 0x00	; 0
  42:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  46:	6d 85       	ldd	r22, Y+13	; 0x0d
  48:	64 fd       	sbrc	r22, 4
  4a:	00 c0       	rjmp	.+0      	; 0x4c <_ZN13LiquidCrystal5beginEhhh+0x4c>
  4c:	63 e0       	ldi	r22, 0x03	; 3
  4e:	ce 01       	movw	r24, r28
  50:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  54:	84 e9       	ldi	r24, 0x94	; 148
  56:	91 e1       	ldi	r25, 0x11	; 17
  58:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  5c:	63 e0       	ldi	r22, 0x03	; 3
  5e:	ce 01       	movw	r24, r28
  60:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  64:	84 e9       	ldi	r24, 0x94	; 148
  66:	91 e1       	ldi	r25, 0x11	; 17
  68:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  6c:	63 e0       	ldi	r22, 0x03	; 3
  6e:	ce 01       	movw	r24, r28
  70:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  74:	86 e9       	ldi	r24, 0x96	; 150
  76:	90 e0       	ldi	r25, 0x00	; 0
  78:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  7c:	62 e0       	ldi	r22, 0x02	; 2
  7e:	ce 01       	movw	r24, r28
  80:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  84:	6d 85       	ldd	r22, Y+13	; 0x0d
  86:	60 62       	ori	r22, 0x20	; 32
  88:	ce 01       	movw	r24, r28
  8a:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  8e:	84 e0       	ldi	r24, 0x04	; 4
  90:	8e 87       	std	Y+14, r24	; 0x0e
  92:	ce 01       	movw	r24, r28
  94:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  98:	ce 01       	movw	r24, r28
  9a:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  9e:	82 e0       	ldi	r24, 0x02	; 2
  a0:	8f 87       	std	Y+15, r24	; 0x0f
  a2:	66 e0       	ldi	r22, 0x06	; 6
  a4:	ce 01       	movw	r24, r28
  a6:	df 91       	pop	r29
  a8:	cf 91       	pop	r28
  aa:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  ae:	60 62       	ori	r22, 0x20	; 32
  b0:	ce 01       	movw	r24, r28
  b2:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  b6:	84 e9       	ldi	r24, 0x94	; 148
  b8:	91 e1       	ldi	r25, 0x11	; 17
  ba:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  be:	6d 85       	ldd	r22, Y+13	; 0x0d
  c0:	60 62       	ori	r22, 0x20	; 32
  c2:	ce 01       	movw	r24, r28
  c4:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  c8:	86 e9       	ldi	r24, 0x96	; 150
  ca:	90 e0       	ldi	r25, 0x00	; 0
  cc:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  d0:	6d 85       	ldd	r22, Y+13	; 0x0d
  d2:	60 62       	ori	r22, 0x20	; 32
  d4:	ce 01       	movw	r24, r28
  d6:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal5beginEhhh>
  da:	00 c0       	rjmp	.+0      	; 0xdc <__SREG__+0x9d>

Disassembly of section .text._ZN13LiquidCrystal4initEhhhhhhhhhhhh:

00000000 <_ZN13LiquidCrystal4initEhhhhhhhhhhhh>:
   0:	6f 92       	push	r6
   2:	7f 92       	push	r7
   4:	8f 92       	push	r8
   6:	af 92       	push	r10
   8:	cf 92       	push	r12
   a:	ef 92       	push	r14
   c:	0f 93       	push	r16
   e:	1f 93       	push	r17
  10:	cf 93       	push	r28
  12:	df 93       	push	r29
  14:	cd b7       	in	r28, 0x3d	; 61
  16:	de b7       	in	r29, 0x3e	; 62
  18:	3c 01       	movw	r6, r24
  1a:	16 2f       	mov	r17, r22
  1c:	84 2f       	mov	r24, r20
  1e:	5d 85       	ldd	r21, Y+13	; 0x0d
  20:	4e 85       	ldd	r20, Y+14	; 0x0e
  22:	3f 85       	ldd	r19, Y+15	; 0x0f
  24:	98 89       	ldd	r25, Y+16	; 0x10
  26:	f3 01       	movw	r30, r6
  28:	82 83       	std	Z+2, r24	; 0x02
  2a:	23 83       	std	Z+3, r18	; 0x03
  2c:	04 83       	std	Z+4, r16	; 0x04
  2e:	e5 82       	std	Z+5, r14	; 0x05
  30:	c6 82       	std	Z+6, r12	; 0x06
  32:	a7 82       	std	Z+7, r10	; 0x07
  34:	80 86       	std	Z+8, r8	; 0x08
  36:	51 87       	std	Z+9, r21	; 0x09
  38:	42 87       	std	Z+10, r20	; 0x0a
  3a:	33 87       	std	Z+11, r19	; 0x0b
  3c:	94 87       	std	Z+12, r25	; 0x0c
  3e:	61 e0       	ldi	r22, 0x01	; 1
  40:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal4initEhhhhhhhhhhhh>
  44:	f3 01       	movw	r30, r6
  46:	83 81       	ldd	r24, Z+3	; 0x03
  48:	8f 3f       	cpi	r24, 0xFF	; 255
  4a:	01 f0       	breq	.+0      	; 0x4c <_ZN13LiquidCrystal4initEhhhhhhhhhhhh+0x4c>
  4c:	61 e0       	ldi	r22, 0x01	; 1
  4e:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal4initEhhhhhhhhhhhh>
  52:	61 e0       	ldi	r22, 0x01	; 1
  54:	f3 01       	movw	r30, r6
  56:	84 81       	ldd	r24, Z+4	; 0x04
  58:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal4initEhhhhhhhhhhhh>
  5c:	11 23       	and	r17, r17
  5e:	01 f0       	breq	.+0      	; 0x60 <_ZN13LiquidCrystal4initEhhhhhhhhhhhh+0x60>
  60:	f3 01       	movw	r30, r6
  62:	15 86       	std	Z+13, r1	; 0x0d
  64:	20 e0       	ldi	r18, 0x00	; 0
  66:	41 e0       	ldi	r20, 0x01	; 1
  68:	60 e1       	ldi	r22, 0x10	; 16
  6a:	c3 01       	movw	r24, r6
  6c:	df 91       	pop	r29
  6e:	cf 91       	pop	r28
  70:	1f 91       	pop	r17
  72:	0f 91       	pop	r16
  74:	ef 90       	pop	r14
  76:	cf 90       	pop	r12
  78:	af 90       	pop	r10
  7a:	8f 90       	pop	r8
  7c:	7f 90       	pop	r7
  7e:	6f 90       	pop	r6
  80:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal4initEhhhhhhhhhhhh>
  84:	80 e1       	ldi	r24, 0x10	; 16
  86:	f3 01       	movw	r30, r6
  88:	85 87       	std	Z+13, r24	; 0x0d
  8a:	00 c0       	rjmp	.+0      	; 0x8c <__SREG__+0x4d>

Disassembly of section .text._ZN13LiquidCrystalC2Ehhhhhhhhhhh:

00000000 <_ZN13LiquidCrystalC1Ehhhhhhhhhhh>:
   0:	8f 92       	push	r8
   2:	af 92       	push	r10
   4:	cf 92       	push	r12
   6:	ef 92       	push	r14
   8:	0f 93       	push	r16
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	cd b7       	in	r28, 0x3d	; 61
  10:	de b7       	in	r29, 0x3e	; 62
  12:	e0 e0       	ldi	r30, 0x00	; 0
  14:	f0 e0       	ldi	r31, 0x00	; 0
  16:	dc 01       	movw	r26, r24
  18:	ed 93       	st	X+, r30
  1a:	fc 93       	st	X, r31
  1c:	3c 85       	ldd	r19, Y+12	; 0x0c
  1e:	3f 93       	push	r19
  20:	3b 85       	ldd	r19, Y+11	; 0x0b
  22:	3f 93       	push	r19
  24:	3a 85       	ldd	r19, Y+10	; 0x0a
  26:	3f 93       	push	r19
  28:	8f 92       	push	r8
  2a:	8a 2c       	mov	r8, r10
  2c:	ac 2c       	mov	r10, r12
  2e:	ce 2c       	mov	r12, r14
  30:	e0 2e       	mov	r14, r16
  32:	02 2f       	mov	r16, r18
  34:	24 2f       	mov	r18, r20
  36:	46 2f       	mov	r20, r22
  38:	60 e0       	ldi	r22, 0x00	; 0
  3a:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystalC1Ehhhhhhhhhhh>
  3e:	0f 90       	pop	r0
  40:	0f 90       	pop	r0
  42:	0f 90       	pop	r0
  44:	0f 90       	pop	r0
  46:	df 91       	pop	r29
  48:	cf 91       	pop	r28
  4a:	0f 91       	pop	r16
  4c:	ef 90       	pop	r14
  4e:	cf 90       	pop	r12
  50:	af 90       	pop	r10
  52:	8f 90       	pop	r8
  54:	08 95       	ret

Disassembly of section .text._ZN13LiquidCrystalC2Ehhhhhhhhhh:

00000000 <_ZN13LiquidCrystalC1Ehhhhhhhhhh>:
   0:	8f 92       	push	r8
   2:	af 92       	push	r10
   4:	cf 92       	push	r12
   6:	ef 92       	push	r14
   8:	0f 93       	push	r16
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	cd b7       	in	r28, 0x3d	; 61
  10:	de b7       	in	r29, 0x3e	; 62
  12:	e0 e0       	ldi	r30, 0x00	; 0
  14:	f0 e0       	ldi	r31, 0x00	; 0
  16:	dc 01       	movw	r26, r24
  18:	ed 93       	st	X+, r30
  1a:	fc 93       	st	X, r31
  1c:	3b 85       	ldd	r19, Y+11	; 0x0b
  1e:	3f 93       	push	r19
  20:	3a 85       	ldd	r19, Y+10	; 0x0a
  22:	3f 93       	push	r19
  24:	8f 92       	push	r8
  26:	af 92       	push	r10
  28:	8c 2c       	mov	r8, r12
  2a:	ae 2c       	mov	r10, r14
  2c:	c0 2e       	mov	r12, r16
  2e:	e2 2e       	mov	r14, r18
  30:	04 2f       	mov	r16, r20
  32:	2f ef       	ldi	r18, 0xFF	; 255
  34:	46 2f       	mov	r20, r22
  36:	60 e0       	ldi	r22, 0x00	; 0
  38:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystalC1Ehhhhhhhhhh>
  3c:	0f 90       	pop	r0
  3e:	0f 90       	pop	r0
  40:	0f 90       	pop	r0
  42:	0f 90       	pop	r0
  44:	df 91       	pop	r29
  46:	cf 91       	pop	r28
  48:	0f 91       	pop	r16
  4a:	ef 90       	pop	r14
  4c:	cf 90       	pop	r12
  4e:	af 90       	pop	r10
  50:	8f 90       	pop	r8
  52:	08 95       	ret

Disassembly of section .text._ZN13LiquidCrystalC2Ehhhhhhh:

00000000 <_ZN13LiquidCrystalC1Ehhhhhhh>:
   0:	8f 92       	push	r8
   2:	af 92       	push	r10
   4:	cf 92       	push	r12
   6:	ef 92       	push	r14
   8:	0f 93       	push	r16
   a:	e0 e0       	ldi	r30, 0x00	; 0
   c:	f0 e0       	ldi	r31, 0x00	; 0
   e:	dc 01       	movw	r26, r24
  10:	ed 93       	st	X+, r30
  12:	fc 93       	st	X, r31
  14:	1f 92       	push	r1
  16:	1f 92       	push	r1
  18:	1f 92       	push	r1
  1a:	1f 92       	push	r1
  1c:	8a 2c       	mov	r8, r10
  1e:	ac 2c       	mov	r10, r12
  20:	ce 2c       	mov	r12, r14
  22:	e0 2e       	mov	r14, r16
  24:	02 2f       	mov	r16, r18
  26:	24 2f       	mov	r18, r20
  28:	46 2f       	mov	r20, r22
  2a:	61 e0       	ldi	r22, 0x01	; 1
  2c:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystalC1Ehhhhhhh>
  30:	0f 90       	pop	r0
  32:	0f 90       	pop	r0
  34:	0f 90       	pop	r0
  36:	0f 90       	pop	r0
  38:	0f 91       	pop	r16
  3a:	ef 90       	pop	r14
  3c:	cf 90       	pop	r12
  3e:	af 90       	pop	r10
  40:	8f 90       	pop	r8
  42:	08 95       	ret

Disassembly of section .text._ZN13LiquidCrystalC2Ehhhhhh:

00000000 <_ZN13LiquidCrystalC1Ehhhhhh>:
   0:	8f 92       	push	r8
   2:	af 92       	push	r10
   4:	cf 92       	push	r12
   6:	ef 92       	push	r14
   8:	0f 93       	push	r16
   a:	e0 e0       	ldi	r30, 0x00	; 0
   c:	f0 e0       	ldi	r31, 0x00	; 0
   e:	dc 01       	movw	r26, r24
  10:	ed 93       	st	X+, r30
  12:	fc 93       	st	X, r31
  14:	1f 92       	push	r1
  16:	1f 92       	push	r1
  18:	1f 92       	push	r1
  1a:	1f 92       	push	r1
  1c:	8c 2c       	mov	r8, r12
  1e:	ae 2c       	mov	r10, r14
  20:	c0 2e       	mov	r12, r16
  22:	e2 2e       	mov	r14, r18
  24:	04 2f       	mov	r16, r20
  26:	2f ef       	ldi	r18, 0xFF	; 255
  28:	46 2f       	mov	r20, r22
  2a:	61 e0       	ldi	r22, 0x01	; 1
  2c:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystalC1Ehhhhhh>
  30:	0f 90       	pop	r0
  32:	0f 90       	pop	r0
  34:	0f 90       	pop	r0
  36:	0f 90       	pop	r0
  38:	0f 91       	pop	r16
  3a:	ef 90       	pop	r14
  3c:	cf 90       	pop	r12
  3e:	af 90       	pop	r10
  40:	8f 90       	pop	r8
  42:	08 95       	ret

Disassembly of section .text._ZN13LiquidCrystal8noCursorEv:

00000000 <_ZN13LiquidCrystal8noCursorEv>:
   0:	fc 01       	movw	r30, r24
   2:	66 85       	ldd	r22, Z+14	; 0x0e
   4:	6d 7f       	andi	r22, 0xFD	; 253
   6:	66 87       	std	Z+14, r22	; 0x0e
   8:	68 60       	ori	r22, 0x08	; 8
   a:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal8noCursorEv>

Disassembly of section .text._ZN13LiquidCrystal6cursorEv:

00000000 <_ZN13LiquidCrystal6cursorEv>:
   0:	fc 01       	movw	r30, r24
   2:	66 85       	ldd	r22, Z+14	; 0x0e
   4:	26 2f       	mov	r18, r22
   6:	22 60       	ori	r18, 0x02	; 2
   8:	26 87       	std	Z+14, r18	; 0x0e
   a:	6a 60       	ori	r22, 0x0A	; 10
   c:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal6cursorEv>

Disassembly of section .text._ZN13LiquidCrystal7noBlinkEv:

00000000 <_ZN13LiquidCrystal7noBlinkEv>:
   0:	fc 01       	movw	r30, r24
   2:	66 85       	ldd	r22, Z+14	; 0x0e
   4:	6e 7f       	andi	r22, 0xFE	; 254
   6:	66 87       	std	Z+14, r22	; 0x0e
   8:	68 60       	ori	r22, 0x08	; 8
   a:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal7noBlinkEv>

Disassembly of section .text._ZN13LiquidCrystal5blinkEv:

00000000 <_ZN13LiquidCrystal5blinkEv>:
   0:	fc 01       	movw	r30, r24
   2:	66 85       	ldd	r22, Z+14	; 0x0e
   4:	26 2f       	mov	r18, r22
   6:	21 60       	ori	r18, 0x01	; 1
   8:	26 87       	std	Z+14, r18	; 0x0e
   a:	69 60       	ori	r22, 0x09	; 9
   c:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal5blinkEv>

Disassembly of section .text._ZN13LiquidCrystal17scrollDisplayLeftEv:

00000000 <_ZN13LiquidCrystal17scrollDisplayLeftEv>:
   0:	68 e1       	ldi	r22, 0x18	; 24
   2:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal17scrollDisplayLeftEv>

Disassembly of section .text._ZN13LiquidCrystal18scrollDisplayRightEv:

00000000 <_ZN13LiquidCrystal18scrollDisplayRightEv>:
   0:	6c e1       	ldi	r22, 0x1C	; 28
   2:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal18scrollDisplayRightEv>

Disassembly of section .text._ZN13LiquidCrystal11leftToRightEv:

00000000 <_ZN13LiquidCrystal11leftToRightEv>:
   0:	fc 01       	movw	r30, r24
   2:	67 85       	ldd	r22, Z+15	; 0x0f
   4:	26 2f       	mov	r18, r22
   6:	22 60       	ori	r18, 0x02	; 2
   8:	27 87       	std	Z+15, r18	; 0x0f
   a:	66 60       	ori	r22, 0x06	; 6
   c:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal11leftToRightEv>

Disassembly of section .text._ZN13LiquidCrystal11rightToLeftEv:

00000000 <_ZN13LiquidCrystal11rightToLeftEv>:
   0:	fc 01       	movw	r30, r24
   2:	67 85       	ldd	r22, Z+15	; 0x0f
   4:	6d 7f       	andi	r22, 0xFD	; 253
   6:	67 87       	std	Z+15, r22	; 0x0f
   8:	64 60       	ori	r22, 0x04	; 4
   a:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal11rightToLeftEv>

Disassembly of section .text._ZN13LiquidCrystal10autoscrollEv:

00000000 <_ZN13LiquidCrystal10autoscrollEv>:
   0:	fc 01       	movw	r30, r24
   2:	67 85       	ldd	r22, Z+15	; 0x0f
   4:	26 2f       	mov	r18, r22
   6:	21 60       	ori	r18, 0x01	; 1
   8:	27 87       	std	Z+15, r18	; 0x0f
   a:	65 60       	ori	r22, 0x05	; 5
   c:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal10autoscrollEv>

Disassembly of section .text._ZN13LiquidCrystal12noAutoscrollEv:

00000000 <_ZN13LiquidCrystal12noAutoscrollEv>:
   0:	fc 01       	movw	r30, r24
   2:	67 85       	ldd	r22, Z+15	; 0x0f
   4:	6e 7f       	andi	r22, 0xFE	; 254
   6:	67 87       	std	Z+15, r22	; 0x0f
   8:	64 60       	ori	r22, 0x04	; 4
   a:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal12noAutoscrollEv>

Disassembly of section .text._ZN13LiquidCrystal10createCharEhPh:

00000000 <_ZN13LiquidCrystal10createCharEhPh>:
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	8c 01       	movw	r16, r24
   e:	7a 01       	movw	r14, r20
  10:	67 70       	andi	r22, 0x07	; 7
  12:	88 e0       	ldi	r24, 0x08	; 8
  14:	68 9f       	mul	r22, r24
  16:	b0 01       	movw	r22, r0
  18:	11 24       	eor	r1, r1
  1a:	60 64       	ori	r22, 0x40	; 64
  1c:	c8 01       	movw	r24, r16
  1e:	0e 94 00 00 	call	0	; 0x0 <_ZN13LiquidCrystal10createCharEhPh>
  22:	e7 01       	movw	r28, r14
  24:	a8 e0       	ldi	r26, 0x08	; 8
  26:	ea 0e       	add	r14, r26
  28:	f1 1c       	adc	r15, r1
  2a:	69 91       	ld	r22, Y+
  2c:	d8 01       	movw	r26, r16
  2e:	ed 91       	ld	r30, X+
  30:	fc 91       	ld	r31, X
  32:	01 90       	ld	r0, Z+
  34:	f0 81       	ld	r31, Z
  36:	e0 2d       	mov	r30, r0
  38:	c8 01       	movw	r24, r16
  3a:	09 95       	icall
  3c:	ce 15       	cp	r28, r14
  3e:	df 05       	cpc	r29, r15
  40:	01 f4       	brne	.+0      	; 0x42 <_ZN13LiquidCrystal10createCharEhPh+0x42>
  42:	df 91       	pop	r29
  44:	cf 91       	pop	r28
  46:	1f 91       	pop	r17
  48:	0f 91       	pop	r16
  4a:	ff 90       	pop	r15
  4c:	ef 90       	pop	r14
  4e:	08 95       	ret

Disassembly of section .text._ZN13LiquidCrystal5writeEh:

00000000 <_ZN13LiquidCrystal5writeEh>:
   0:	41 e0       	ldi	r20, 0x01	; 1
   2:	0c 94 00 00 	jmp	0	; 0x0 <_ZN13LiquidCrystal5writeEh>

Keypad.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000b70  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00001490  00000000  00000000  00000ba4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text._ZN6Keypad5beginEPc 00000008  00000000  00000000  00002034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text._ZN6Keypad8getStateEv 00000008  00000000  00000000  0000203c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text._ZN6Keypad15setDebounceTimeEj 00000008  00000000  00000000  00002044  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text._ZN6Keypad11setHoldTimeEj 00000008  00000000  00000000  0000204c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .text._ZN6Keypad16addEventListenerEPFvcE 00000008  00000000  00000000  00002054  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .text._ZN6Keypad12transitionToE11KeypadState 00000036  00000000  00000000  0000205c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text._ZN6Keypad6getKeyEv 000001be  00000000  00000000  00002092  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text._ZN6Keypad14initializePinsEv 00000084  00000000  00000000  00002250  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text._ZN6KeypadC2EPcPhS1_hhh 00000050  00000000  00000000  000022d4  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .comment      00000012  00000000  00000000  00002324  2**0
                  CONTENTS, READONLY

Disassembly of section .text._ZN6Keypad5beginEPc:

00000000 <_ZN6Keypad5beginEPc>:
*/

#include "Keypad.h"

// <<constructor>> Allows custom keymap. pin configuration and keypad size
Keypad::Keypad(char *userKeymap, byte *row, byte *col, byte rows, byte cols, byte allowRollKeys)
   0:	fc 01       	movw	r30, r24
   2:	71 83       	std	Z+1, r23	; 0x01
   4:	60 83       	st	Z, r22
   6:	08 95       	ret

Disassembly of section .text._ZN6Keypad8getStateEv:

00000000 <_ZN6Keypad8getStateEv>:
   0:	fc 01       	movw	r30, r24
   2:	87 81       	ldd	r24, Z+7	; 0x07
   4:	90 85       	ldd	r25, Z+8	; 0x08
   6:	08 95       	ret

Disassembly of section .text._ZN6Keypad15setDebounceTimeEj:

00000000 <_ZN6Keypad15setDebounceTimeEj>:
   0:	fc 01       	movw	r30, r24
   2:	77 87       	std	Z+15, r23	; 0x0f
   4:	66 87       	std	Z+14, r22	; 0x0e
   6:	08 95       	ret

Disassembly of section .text._ZN6Keypad11setHoldTimeEj:

00000000 <_ZN6Keypad11setHoldTimeEj>:
   0:	fc 01       	movw	r30, r24
   2:	71 8b       	std	Z+17, r23	; 0x11
   4:	60 8b       	std	Z+16, r22	; 0x10
   6:	08 95       	ret

Disassembly of section .text._ZN6Keypad16addEventListenerEPFvcE:

00000000 <_ZN6Keypad16addEventListenerEPFvcE>:
   0:	fc 01       	movw	r30, r24
   2:	73 8b       	std	Z+19, r23	; 0x13
   4:	62 8b       	std	Z+18, r22	; 0x12
   6:	08 95       	ret

Disassembly of section .text._ZN6Keypad12transitionToE11KeypadState:

00000000 <_ZN6Keypad12transitionToE11KeypadState>:
   0:	dc 01       	movw	r26, r24
   2:	54 96       	adiw	r26, 0x14	; 20
   4:	8c 91       	ld	r24, X
   6:	54 97       	sbiw	r26, 0x14	; 20
{
    rowPins = row;
   8:	81 11       	cpse	r24, r1
   a:	00 c0       	rjmp	.+0      	; 0xc <_ZN6Keypad12transitionToE11KeypadState+0xc>
    columnPins = col;
   c:	17 96       	adiw	r26, 0x07	; 7
   e:	8d 91       	ld	r24, X+
	
	size.rows = rows;
	size.columns = cols;
  10:	9c 91       	ld	r25, X
  12:	18 97       	sbiw	r26, 0x08	; 8
  14:	86 17       	cp	r24, r22
  16:	97 07       	cpc	r25, r23
  18:	01 f0       	breq	.+0      	; 0x1a <_ZN6Keypad12transitionToE11KeypadState+0x1a>
  1a:	18 96       	adiw	r26, 0x08	; 8
	initializePins();
}

// Let the user define a keymap - assume the same row- / columncount as defined in constructor
void Keypad::begin( char *userKeymap){
    keymap = userKeymap;
  1c:	7c 93       	st	X, r23
  1e:	6e 93       	st	-X, r22
	size.rows = rows;
	size.columns = cols;
	
    begin(userKeymap);
	
	lastUpdate = 0;
  20:	17 97       	sbiw	r26, 0x07	; 7
  22:	52 96       	adiw	r26, 0x12	; 18
  24:	ed 91       	ld	r30, X+
  26:	fc 91       	ld	r31, X
	debounceTime = 50;
  28:	53 97       	sbiw	r26, 0x13	; 19
  2a:	30 97       	sbiw	r30, 0x00	; 0
  2c:	01 f0       	breq	.+0      	; 0x2e <_ZN6Keypad12transitionToE11KeypadState+0x2e>
  2e:	19 96       	adiw	r26, 0x09	; 9
	holdTime = 1000;
  30:	8c 91       	ld	r24, X
  32:	09 94       	ijmp
  34:	08 95       	ret

Disassembly of section .text._ZN6Keypad6getKeyEv:

00000000 <_ZN6Keypad6getKeyEv>:
*/

#include "Keypad.h"

// <<constructor>> Allows custom keymap. pin configuration and keypad size
Keypad::Keypad(char *userKeymap, byte *row, byte *col, byte rows, byte cols, byte allowRollKeys)
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
   6:	bf 92       	push	r11
{
    rowPins = row;
   8:	ef 92       	push	r14
   a:	ff 92       	push	r15
    columnPins = col;
   c:	0f 93       	push	r16
   e:	1f 93       	push	r17
	
	size.rows = rows;
	size.columns = cols;
  10:	cf 93       	push	r28
  12:	df 93       	push	r29
  14:	ec 01       	movw	r28, r24
  16:	10 e0       	ldi	r17, 0x00	; 0
  18:	00 e0       	ldi	r16, 0x00	; 0
  1a:	8e 81       	ldd	r24, Y+6	; 0x06
	initializePins();
}

// Let the user define a keymap - assume the same row- / columncount as defined in constructor
void Keypad::begin( char *userKeymap){
    keymap = userKeymap;
  1c:	82 95       	swap	r24
  1e:	8f 70       	andi	r24, 0x0F	; 15
	size.rows = rows;
	size.columns = cols;
	
    begin(userKeymap);
	
	lastUpdate = 0;
  20:	08 17       	cp	r16, r24
  22:	00 f0       	brcs	.+0      	; 0x24 <_ZN6Keypad6getKeyEv+0x24>
  24:	80 e0       	ldi	r24, 0x00	; 0
  26:	df 91       	pop	r29
	debounceTime = 50;
  28:	cf 91       	pop	r28
  2a:	1f 91       	pop	r17
  2c:	0f 91       	pop	r16
  2e:	ff 90       	pop	r15
	holdTime = 1000;
  30:	ef 90       	pop	r14
  32:	bf 90       	pop	r11
  34:	af 90       	pop	r10
  36:	9f 90       	pop	r9
	keypadEventListener = 0;
  38:	8f 90       	pop	r8
  3a:	08 95       	ret
	currentKey = NO_KEY;
  3c:	ec 81       	ldd	r30, Y+4	; 0x04
	state = IDLE;
  3e:	fd 81       	ldd	r31, Y+5	; 0x05
  40:	e0 0f       	add	r30, r16
	allowRollingKeys = allowRollKeys; // 0 will not pass the key more than once during HOLD.
  42:	f1 1f       	adc	r31, r17
                                      // 1 will pass the key for as long as it is held.
	initializePins();
  44:	60 e0       	ldi	r22, 0x00	; 0
}
  46:	80 81       	ld	r24, Z
  48:	0e 94 00 00 	call	0	; 0x0 <_ZN6Keypad6getKeyEv>
	keypadEventListener = 0;
	currentKey = NO_KEY;
	state = IDLE;
	allowRollingKeys = allowRollKeys; // 0 will not pass the key more than once during HOLD.
                                      // 1 will pass the key for as long as it is held.
	initializePins();
  4c:	f1 2c       	mov	r15, r1
  4e:	e1 2c       	mov	r14, r1
  50:	8e 81       	ldd	r24, Y+6	; 0x06
  52:	98 2f       	mov	r25, r24
  54:	9f 70       	andi	r25, 0x0F	; 15
  56:	e9 16       	cp	r14, r25
  58:	00 f0       	brcs	.+0      	; 0x5a <_ZN6Keypad6getKeyEv+0x5a>
  5a:	00 c0       	rjmp	.+0      	; 0x5c <_ZN6Keypad6getKeyEv+0x5c>
  5c:	82 95       	swap	r24
  5e:	8f 70       	andi	r24, 0x0F	; 15
  60:	8e 9d       	mul	r24, r14
  62:	90 01       	movw	r18, r0
  64:	8f 9d       	mul	r24, r15
  66:	30 0d       	add	r19, r0
  68:	11 24       	eor	r1, r1
  6a:	e8 81       	ld	r30, Y
  6c:	f9 81       	ldd	r31, Y+1	; 0x01
  6e:	e0 0f       	add	r30, r16
  70:	f1 1f       	adc	r31, r17
  72:	e2 0f       	add	r30, r18
  74:	f3 1f       	adc	r31, r19
  76:	99 85       	ldd	r25, Y+9	; 0x09
  78:	80 81       	ld	r24, Z
  7a:	98 13       	cpse	r25, r24
  7c:	00 c0       	rjmp	.+0      	; 0x7e <_ZN6Keypad6getKeyEv+0x7e>
  7e:	0e 94 00 00 	call	0	; 0x0 <_ZN6Keypad6getKeyEv>
  82:	8a 84       	ldd	r8, Y+10	; 0x0a
  84:	9b 84       	ldd	r9, Y+11	; 0x0b
  86:	ac 84       	ldd	r10, Y+12	; 0x0c
  88:	bd 84       	ldd	r11, Y+13	; 0x0d
  8a:	ab 01       	movw	r20, r22
  8c:	bc 01       	movw	r22, r24
  8e:	48 19       	sub	r20, r8
  90:	59 09       	sbc	r21, r9
  92:	6a 09       	sbc	r22, r10
  94:	7b 09       	sbc	r23, r11
  96:	88 89       	ldd	r24, Y+16	; 0x10
  98:	99 89       	ldd	r25, Y+17	; 0x11
  9a:	b0 e0       	ldi	r27, 0x00	; 0
  9c:	a0 e0       	ldi	r26, 0x00	; 0
  9e:	48 17       	cp	r20, r24
  a0:	59 07       	cpc	r21, r25
  a2:	6a 07       	cpc	r22, r26
  a4:	7b 07       	cpc	r23, r27
  a6:	00 f0       	brcs	.+0      	; 0xa8 <_ZN6Keypad6getKeyEv+0xa8>
  a8:	ea 81       	ldd	r30, Y+2	; 0x02
  aa:	fb 81       	ldd	r31, Y+3	; 0x03
  ac:	ee 0d       	add	r30, r14
  ae:	ff 1d       	adc	r31, r15
  b0:	80 81       	ld	r24, Z
  b2:	0e 94 00 00 	call	0	; 0x0 <_ZN6Keypad6getKeyEv>
  b6:	89 2b       	or	r24, r25
  b8:	01 f4       	brne	.+0      	; 0xba <_ZN6Keypad6getKeyEv+0xba>
  ba:	63 e0       	ldi	r22, 0x03	; 3
  bc:	70 e0       	ldi	r23, 0x00	; 0
  be:	ce 01       	movw	r24, r28
  c0:	0e 94 00 00 	call	0	; 0x0 <_ZN6Keypad6getKeyEv>
  c4:	0e 94 00 00 	call	0	; 0x0 <_ZN6Keypad6getKeyEv>
  c8:	8a 84       	ldd	r8, Y+10	; 0x0a
  ca:	9b 84       	ldd	r9, Y+11	; 0x0b
  cc:	ac 84       	ldd	r10, Y+12	; 0x0c
  ce:	bd 84       	ldd	r11, Y+13	; 0x0d
  d0:	ab 01       	movw	r20, r22
  d2:	bc 01       	movw	r22, r24
  d4:	48 19       	sub	r20, r8
  d6:	59 09       	sbc	r21, r9
  d8:	6a 09       	sbc	r22, r10
  da:	7b 09       	sbc	r23, r11
  dc:	8e 85       	ldd	r24, Y+14	; 0x0e
  de:	9f 85       	ldd	r25, Y+15	; 0x0f
  e0:	b0 e0       	ldi	r27, 0x00	; 0
  e2:	a0 e0       	ldi	r26, 0x00	; 0
  e4:	48 17       	cp	r20, r24
  e6:	59 07       	cpc	r21, r25
  e8:	6a 07       	cpc	r22, r26
  ea:	7b 07       	cpc	r23, r27
  ec:	00 f0       	brcs	.+0      	; 0xee <_ZN6Keypad6getKeyEv+0xee>
  ee:	ea 81       	ldd	r30, Y+2	; 0x02
  f0:	fb 81       	ldd	r31, Y+3	; 0x03
  f2:	ee 0d       	add	r30, r14
  f4:	ff 1d       	adc	r31, r15
  f6:	80 81       	ld	r24, Z
  f8:	0e 94 00 00 	call	0	; 0x0 <_ZN6Keypad6getKeyEv>
  fc:	01 97       	sbiw	r24, 0x01	; 1
  fe:	01 f4       	brne	.+0      	; 0x100 <_ZN6Keypad6getKeyEv+0x100>
 100:	62 e0       	ldi	r22, 0x02	; 2
 102:	70 e0       	ldi	r23, 0x00	; 0
 104:	ce 01       	movw	r24, r28
 106:	0e 94 00 00 	call	0	; 0x0 <_ZN6Keypad6getKeyEv>
 10a:	19 86       	std	Y+9, r1	; 0x09
 10c:	8f ef       	ldi	r24, 0xFF	; 255
 10e:	e8 1a       	sub	r14, r24
 110:	f8 0a       	sbc	r15, r24
 112:	00 c0       	rjmp	.+0      	; 0x114 <_ZN6Keypad6getKeyEv+0x114>
 114:	0e 94 00 00 	call	0	; 0x0 <_ZN6Keypad6getKeyEv>
 118:	8a 84       	ldd	r8, Y+10	; 0x0a
 11a:	9b 84       	ldd	r9, Y+11	; 0x0b
 11c:	ac 84       	ldd	r10, Y+12	; 0x0c
 11e:	bd 84       	ldd	r11, Y+13	; 0x0d
 120:	ab 01       	movw	r20, r22
 122:	bc 01       	movw	r22, r24
 124:	48 19       	sub	r20, r8
 126:	59 09       	sbc	r21, r9
 128:	6a 09       	sbc	r22, r10
 12a:	7b 09       	sbc	r23, r11
 12c:	8e 85       	ldd	r24, Y+14	; 0x0e
 12e:	9f 85       	ldd	r25, Y+15	; 0x0f
 130:	b0 e0       	ldi	r27, 0x00	; 0
 132:	a0 e0       	ldi	r26, 0x00	; 0
 134:	48 17       	cp	r20, r24
 136:	59 07       	cpc	r21, r25
 138:	6a 07       	cpc	r22, r26
 13a:	7b 07       	cpc	r23, r27
 13c:	00 f0       	brcs	.+0      	; 0x13e <_ZN6Keypad6getKeyEv+0x13e>
 13e:	ea 81       	ldd	r30, Y+2	; 0x02
 140:	fb 81       	ldd	r31, Y+3	; 0x03
 142:	ee 0d       	add	r30, r14
 144:	ff 1d       	adc	r31, r15
 146:	80 81       	ld	r24, Z
 148:	0e 94 00 00 	call	0	; 0x0 <_ZN6Keypad6getKeyEv>
 14c:	89 2b       	or	r24, r25
 14e:	01 f4       	brne	.+0      	; 0x150 <_ZN6Keypad6getKeyEv+0x150>
 150:	ec 81       	ldd	r30, Y+4	; 0x04
 152:	fd 81       	ldd	r31, Y+5	; 0x05
 154:	e0 0f       	add	r30, r16
 156:	f1 1f       	adc	r31, r17
 158:	61 e0       	ldi	r22, 0x01	; 1
 15a:	80 81       	ld	r24, Z
 15c:	0e 94 00 00 	call	0	; 0x0 <_ZN6Keypad6getKeyEv>
 160:	8e 81       	ldd	r24, Y+6	; 0x06
 162:	82 95       	swap	r24
 164:	8f 70       	andi	r24, 0x0F	; 15
 166:	8e 9d       	mul	r24, r14
 168:	90 01       	movw	r18, r0
 16a:	8f 9d       	mul	r24, r15
 16c:	30 0d       	add	r19, r0
 16e:	11 24       	eor	r1, r1
 170:	e8 81       	ld	r30, Y
 172:	f9 81       	ldd	r31, Y+1	; 0x01
 174:	e0 0f       	add	r30, r16
 176:	f1 1f       	adc	r31, r17
 178:	e2 0f       	add	r30, r18
 17a:	f3 1f       	adc	r31, r19
 17c:	10 81       	ld	r17, Z
 17e:	0e 94 00 00 	call	0	; 0x0 <_ZN6Keypad6getKeyEv>
 182:	6a 87       	std	Y+10, r22	; 0x0a
 184:	7b 87       	std	Y+11, r23	; 0x0b
 186:	8c 87       	std	Y+12, r24	; 0x0c
 188:	9d 87       	std	Y+13, r25	; 0x0d
 18a:	11 23       	and	r17, r17
 18c:	01 f4       	brne	.+0      	; 0x18e <_ZN6Keypad6getKeyEv+0x18e>
 18e:	00 c0       	rjmp	.+0      	; 0x190 <_ZN6Keypad6getKeyEv+0x190>
 190:	89 85       	ldd	r24, Y+9	; 0x09
 192:	81 17       	cp	r24, r17
 194:	01 f4       	brne	.+0      	; 0x196 <_ZN6Keypad6getKeyEv+0x196>
 196:	00 c0       	rjmp	.+0      	; 0x198 <_ZN6Keypad6getKeyEv+0x198>
 198:	19 87       	std	Y+9, r17	; 0x09
 19a:	61 e0       	ldi	r22, 0x01	; 1
 19c:	70 e0       	ldi	r23, 0x00	; 0
 19e:	ce 01       	movw	r24, r28
 1a0:	0e 94 00 00 	call	0	; 0x0 <_ZN6Keypad6getKeyEv>
 1a4:	89 85       	ldd	r24, Y+9	; 0x09
 1a6:	00 c0       	rjmp	.+0      	; 0x1a8 <_ZN6Keypad6getKeyEv+0x1a8>
 1a8:	ec 81       	ldd	r30, Y+4	; 0x04
 1aa:	fd 81       	ldd	r31, Y+5	; 0x05
 1ac:	e0 0f       	add	r30, r16
 1ae:	f1 1f       	adc	r31, r17
 1b0:	61 e0       	ldi	r22, 0x01	; 1
 1b2:	80 81       	ld	r24, Z
 1b4:	0e 94 00 00 	call	0	; 0x0 <_ZN6Keypad6getKeyEv>
 1b8:	0f 5f       	subi	r16, 0xFF	; 255
 1ba:	1f 4f       	sbci	r17, 0xFF	; 255
 1bc:	00 c0       	rjmp	.+0      	; 0x1be <__SREG__+0x17f>

Disassembly of section .text._ZN6Keypad14initializePinsEv:

00000000 <_ZN6Keypad14initializePinsEv>:
*/

#include "Keypad.h"

// <<constructor>> Allows custom keymap. pin configuration and keypad size
Keypad::Keypad(char *userKeymap, byte *row, byte *col, byte rows, byte cols, byte allowRollKeys)
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
{
    rowPins = row;
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
    columnPins = col;
   c:	ec 01       	movw	r28, r24
   e:	10 e0       	ldi	r17, 0x00	; 0
	
	size.rows = rows;
	size.columns = cols;
  10:	00 e0       	ldi	r16, 0x00	; 0
  12:	8e 81       	ldd	r24, Y+6	; 0x06
  14:	8f 70       	andi	r24, 0x0F	; 15
  16:	08 17       	cp	r16, r24
  18:	00 f4       	brcc	.+0      	; 0x1a <_ZN6Keypad14initializePinsEv+0x1a>
  1a:	f1 2c       	mov	r15, r1
	initializePins();
}

// Let the user define a keymap - assume the same row- / columncount as defined in constructor
void Keypad::begin( char *userKeymap){
    keymap = userKeymap;
  1c:	e1 2c       	mov	r14, r1
  1e:	8e 81       	ldd	r24, Y+6	; 0x06
	size.rows = rows;
	size.columns = cols;
	
    begin(userKeymap);
	
	lastUpdate = 0;
  20:	82 95       	swap	r24
  22:	8f 70       	andi	r24, 0x0F	; 15
  24:	e8 16       	cp	r14, r24
  26:	00 f4       	brcc	.+0      	; 0x28 <_ZN6Keypad14initializePinsEv+0x28>
	debounceTime = 50;
  28:	ec 81       	ldd	r30, Y+4	; 0x04
  2a:	fd 81       	ldd	r31, Y+5	; 0x05
  2c:	ee 0d       	add	r30, r14
  2e:	ff 1d       	adc	r31, r15
	holdTime = 1000;
  30:	61 e0       	ldi	r22, 0x01	; 1
  32:	80 81       	ld	r24, Z
  34:	0e 94 00 00 	call	0	; 0x0 <_ZN6Keypad14initializePinsEv>
	keypadEventListener = 0;
  38:	ec 81       	ldd	r30, Y+4	; 0x04
  3a:	fd 81       	ldd	r31, Y+5	; 0x05
	currentKey = NO_KEY;
  3c:	ee 0d       	add	r30, r14
	state = IDLE;
  3e:	ff 1d       	adc	r31, r15
  40:	61 e0       	ldi	r22, 0x01	; 1
	allowRollingKeys = allowRollKeys; // 0 will not pass the key more than once during HOLD.
  42:	80 81       	ld	r24, Z
                                      // 1 will pass the key for as long as it is held.
	initializePins();
  44:	0e 94 00 00 	call	0	; 0x0 <_ZN6Keypad14initializePinsEv>
}
  48:	8f ef       	ldi	r24, 0xFF	; 255
  4a:	e8 1a       	sub	r14, r24
	keypadEventListener = 0;
	currentKey = NO_KEY;
	state = IDLE;
	allowRollingKeys = allowRollKeys; // 0 will not pass the key more than once during HOLD.
                                      // 1 will pass the key for as long as it is held.
	initializePins();
  4c:	f8 0a       	sbc	r15, r24
  4e:	00 c0       	rjmp	.+0      	; 0x50 <_ZN6Keypad14initializePinsEv+0x50>
  50:	ea 81       	ldd	r30, Y+2	; 0x02
  52:	fb 81       	ldd	r31, Y+3	; 0x03
  54:	e0 0f       	add	r30, r16
  56:	f1 1f       	adc	r31, r17
  58:	60 e0       	ldi	r22, 0x00	; 0
  5a:	80 81       	ld	r24, Z
  5c:	0e 94 00 00 	call	0	; 0x0 <_ZN6Keypad14initializePinsEv>
  60:	ea 81       	ldd	r30, Y+2	; 0x02
  62:	fb 81       	ldd	r31, Y+3	; 0x03
  64:	e0 0f       	add	r30, r16
  66:	f1 1f       	adc	r31, r17
  68:	61 e0       	ldi	r22, 0x01	; 1
  6a:	80 81       	ld	r24, Z
  6c:	0e 94 00 00 	call	0	; 0x0 <_ZN6Keypad14initializePinsEv>
  70:	0f 5f       	subi	r16, 0xFF	; 255
  72:	1f 4f       	sbci	r17, 0xFF	; 255
  74:	00 c0       	rjmp	.+0      	; 0x76 <_ZN6Keypad14initializePinsEv+0x76>
  76:	df 91       	pop	r29
  78:	cf 91       	pop	r28
  7a:	1f 91       	pop	r17
  7c:	0f 91       	pop	r16
  7e:	ff 90       	pop	r15
  80:	ef 90       	pop	r14
  82:	08 95       	ret

Disassembly of section .text._ZN6KeypadC2EPcPhS1_hhh:

00000000 <_ZN6KeypadC1EPcPhS1_hhh>:
*/

#include "Keypad.h"

// <<constructor>> Allows custom keymap. pin configuration and keypad size
Keypad::Keypad(char *userKeymap, byte *row, byte *col, byte rows, byte cols, byte allowRollKeys)
   0:	cf 92       	push	r12
   2:	ef 92       	push	r14
   4:	0f 93       	push	r16
   6:	fc 01       	movw	r30, r24
{
    rowPins = row;
   8:	53 83       	std	Z+3, r21	; 0x03
   a:	42 83       	std	Z+2, r20	; 0x02
    columnPins = col;
   c:	35 83       	std	Z+5, r19	; 0x05
   e:	24 83       	std	Z+4, r18	; 0x04
	
	size.rows = rows;
	size.columns = cols;
  10:	e2 94       	swap	r14
  12:	80 ef       	ldi	r24, 0xF0	; 240
  14:	e8 22       	and	r14, r24
  16:	0f 70       	andi	r16, 0x0F	; 15
  18:	0e 29       	or	r16, r14
  1a:	06 83       	std	Z+6, r16	; 0x06
	initializePins();
}

// Let the user define a keymap - assume the same row- / columncount as defined in constructor
void Keypad::begin( char *userKeymap){
    keymap = userKeymap;
  1c:	71 83       	std	Z+1, r23	; 0x01
  1e:	60 83       	st	Z, r22
	size.rows = rows;
	size.columns = cols;
	
    begin(userKeymap);
	
	lastUpdate = 0;
  20:	12 86       	std	Z+10, r1	; 0x0a
  22:	13 86       	std	Z+11, r1	; 0x0b
  24:	14 86       	std	Z+12, r1	; 0x0c
  26:	15 86       	std	Z+13, r1	; 0x0d
	debounceTime = 50;
  28:	82 e3       	ldi	r24, 0x32	; 50
  2a:	90 e0       	ldi	r25, 0x00	; 0
  2c:	97 87       	std	Z+15, r25	; 0x0f
  2e:	86 87       	std	Z+14, r24	; 0x0e
	holdTime = 1000;
  30:	88 ee       	ldi	r24, 0xE8	; 232
  32:	93 e0       	ldi	r25, 0x03	; 3
  34:	91 8b       	std	Z+17, r25	; 0x11
  36:	80 8b       	std	Z+16, r24	; 0x10
	keypadEventListener = 0;
  38:	13 8a       	std	Z+19, r1	; 0x13
  3a:	12 8a       	std	Z+18, r1	; 0x12
	currentKey = NO_KEY;
  3c:	11 86       	std	Z+9, r1	; 0x09
	state = IDLE;
  3e:	10 86       	std	Z+8, r1	; 0x08
  40:	17 82       	std	Z+7, r1	; 0x07
	allowRollingKeys = allowRollKeys; // 0 will not pass the key more than once during HOLD.
  42:	c4 8a       	std	Z+20, r12	; 0x14
                                      // 1 will pass the key for as long as it is held.
	initializePins();
  44:	cf 01       	movw	r24, r30
}
  46:	0f 91       	pop	r16
  48:	ef 90       	pop	r14
  4a:	cf 90       	pop	r12
	keypadEventListener = 0;
	currentKey = NO_KEY;
	state = IDLE;
	allowRollingKeys = allowRollKeys; // 0 will not pass the key more than once during HOLD.
                                      // 1 will pass the key for as long as it is held.
	initializePins();
  4c:	0c 94 00 00 	jmp	0	; 0x0 <_ZN6KeypadC1EPcPhS1_hhh>

event_groups.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00001020  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000021fc  00000000  00000000  00001054  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.hot.xEventGroupCreate 00000026  00000000  00000000  00003250  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.hot.xEventGroupWaitBits 000000ec  00000000  00000000  00003276  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.hot.xEventGroupClearBits 0000001e  00000000  00000000  00003362  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text.hot.xEventGroupGetBitsFromISR 00000008  00000000  00000000  00003380  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .text.hot.xEventGroupSetBits 0000009a  00000000  00000000  00003388  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.hot.xEventGroupSync 000000d8  00000000  00000000  00003422  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.hot.vEventGroupDelete 0000002c  00000000  00000000  000034fa  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text.hot.vEventGroupSetBitsCallback 00000006  00000000  00000000  00003526  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.hot.vEventGroupClearBitsCallback 00000006  00000000  00000000  0000352c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .comment      00000012  00000000  00000000  00003532  2**0
                  CONTENTS, READONLY

Disassembly of section .text.hot.xEventGroupCreate:

00000000 <xEventGroupCreate>:
        traceENTER_vEventGroupClearBitsCallback( pvEventGroup, ulBitsToClear );

        /* MISRA Ref 11.5.4 [Callback function parameter] */
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
        /* coverity[misra_c_2012_rule_11_5_violation] */
        ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	8b e0       	ldi	r24, 0x0B	; 11
   6:	90 e0       	ldi	r25, 0x00	; 0
   8:	0e 94 00 00 	call	0	; 0x0 <xEventGroupCreate>
   c:	ec 01       	movw	r28, r24
   e:	00 97       	sbiw	r24, 0x00	; 0
  10:	01 f0       	breq	.+0      	; 0x12 <xEventGroupCreate+0x12>
  12:	fc 01       	movw	r30, r24
  14:	11 92       	st	Z+, r1
  16:	11 92       	st	Z+, r1
  18:	cf 01       	movw	r24, r30
  1a:	0e 94 00 00 	call	0	; 0x0 <xEventGroupCreate>
  1e:	ce 01       	movw	r24, r28
  20:	df 91       	pop	r29
  22:	cf 91       	pop	r28
  24:	08 95       	ret

Disassembly of section .text.hot.xEventGroupWaitBits:

00000000 <xEventGroupWaitBits>:
   0:	af 92       	push	r10
   2:	bf 92       	push	r11
   4:	cf 92       	push	r12
   6:	df 92       	push	r13
   8:	ef 92       	push	r14
   a:	ff 92       	push	r15
   c:	0f 93       	push	r16
   e:	1f 93       	push	r17
  10:	cf 93       	push	r28
  12:	df 93       	push	r29
  14:	6c 01       	movw	r12, r24
  16:	7b 01       	movw	r14, r22
  18:	b4 2e       	mov	r11, r20
  1a:	a2 2e       	mov	r10, r18
  1c:	0e 94 00 00 	call	0	; 0x0 <xEventGroupWaitBits>
  20:	f6 01       	movw	r30, r12
  22:	c0 81       	ld	r28, Z
  24:	d1 81       	ldd	r29, Z+1	; 0x01
  26:	ce 01       	movw	r24, r28
  28:	8e 21       	and	r24, r14
  2a:	9f 21       	and	r25, r15
  2c:	a1 10       	cpse	r10, r1
  2e:	00 c0       	rjmp	.+0      	; 0x30 <xEventGroupWaitBits+0x30>
  30:	89 2b       	or	r24, r25
  32:	01 f0       	breq	.+0      	; 0x34 <xEventGroupWaitBits+0x34>
  34:	00 c0       	rjmp	.+0      	; 0x36 <xEventGroupWaitBits+0x36>
  36:	01 15       	cp	r16, r1
  38:	11 05       	cpc	r17, r1
  3a:	01 f0       	breq	.+0      	; 0x3c <xEventGroupWaitBits+0x3c>
  3c:	60 e0       	ldi	r22, 0x00	; 0
  3e:	71 e0       	ldi	r23, 0x01	; 1
  40:	b1 10       	cpse	r11, r1
  42:	00 c0       	rjmp	.+0      	; 0x44 <xEventGroupWaitBits+0x44>
  44:	70 e0       	ldi	r23, 0x00	; 0
  46:	60 e0       	ldi	r22, 0x00	; 0
  48:	a1 10       	cpse	r10, r1
  4a:	74 60       	ori	r23, 0x04	; 4
  4c:	6e 29       	or	r22, r14
  4e:	7f 29       	or	r23, r15
  50:	a8 01       	movw	r20, r16
  52:	c6 01       	movw	r24, r12
  54:	02 96       	adiw	r24, 0x02	; 2
  56:	0e 94 00 00 	call	0	; 0x0 <xEventGroupWaitBits>
  5a:	d0 e0       	ldi	r29, 0x00	; 0
  5c:	c0 e0       	ldi	r28, 0x00	; 0
  5e:	0e 94 00 00 	call	0	; 0x0 <xEventGroupWaitBits>
  62:	01 2b       	or	r16, r17
  64:	01 f0       	breq	.+0      	; 0x66 <xEventGroupWaitBits+0x66>
  66:	81 11       	cpse	r24, r1
  68:	00 c0       	rjmp	.+0      	; 0x6a <xEventGroupWaitBits+0x6a>
  6a:	0e 94 00 00 	call	0	; 0x0 <xEventGroupWaitBits>
  6e:	0e 94 00 00 	call	0	; 0x0 <xEventGroupWaitBits>
  72:	91 fd       	sbrc	r25, 1
  74:	00 c0       	rjmp	.+0      	; 0x76 <xEventGroupWaitBits+0x76>
  76:	0f b6       	in	r0, 0x3f	; 63
  78:	f8 94       	cli
  7a:	0f 92       	push	r0
  7c:	f6 01       	movw	r30, r12
  7e:	80 81       	ld	r24, Z
  80:	91 81       	ldd	r25, Z+1	; 0x01
  82:	97 01       	movw	r18, r14
  84:	28 23       	and	r18, r24
  86:	39 23       	and	r19, r25
  88:	a1 10       	cpse	r10, r1
  8a:	00 c0       	rjmp	.+0      	; 0x8c <xEventGroupWaitBits+0x8c>
  8c:	23 2b       	or	r18, r19
  8e:	01 f4       	brne	.+0      	; 0x90 <xEventGroupWaitBits+0x90>
  90:	0f 90       	pop	r0
  92:	0f be       	out	0x3f, r0	; 63
  94:	ec 01       	movw	r28, r24
  96:	dd 27       	eor	r29, r29
  98:	ce 01       	movw	r24, r28
  9a:	df 91       	pop	r29
  9c:	cf 91       	pop	r28
  9e:	1f 91       	pop	r17
  a0:	0f 91       	pop	r16
  a2:	ff 90       	pop	r15
  a4:	ef 90       	pop	r14
  a6:	df 90       	pop	r13
  a8:	cf 90       	pop	r12
  aa:	bf 90       	pop	r11
  ac:	af 90       	pop	r10
  ae:	08 95       	ret
  b0:	e8 16       	cp	r14, r24
  b2:	f9 06       	cpc	r15, r25
  b4:	01 f0       	breq	.+0      	; 0xb6 <xEventGroupWaitBits+0xb6>
  b6:	00 c0       	rjmp	.+0      	; 0xb8 <xEventGroupWaitBits+0xb8>
  b8:	bb 20       	and	r11, r11
  ba:	01 f0       	breq	.+0      	; 0xbc <xEventGroupWaitBits+0xbc>
  bc:	c7 01       	movw	r24, r14
  be:	80 95       	com	r24
  c0:	90 95       	com	r25
  c2:	8c 23       	and	r24, r28
  c4:	9d 23       	and	r25, r29
  c6:	f6 01       	movw	r30, r12
  c8:	91 83       	std	Z+1, r25	; 0x01
  ca:	80 83       	st	Z, r24
  cc:	10 e0       	ldi	r17, 0x00	; 0
  ce:	00 e0       	ldi	r16, 0x00	; 0
  d0:	00 c0       	rjmp	.+0      	; 0xd2 <xEventGroupWaitBits+0xd2>
  d2:	e2 16       	cp	r14, r18
  d4:	f3 06       	cpc	r15, r19
  d6:	01 f4       	brne	.+0      	; 0xd8 <xEventGroupWaitBits+0xd8>
  d8:	bb 20       	and	r11, r11
  da:	01 f0       	breq	.+0      	; 0xdc <xEventGroupWaitBits+0xdc>
  dc:	e0 94       	com	r14
  de:	f0 94       	com	r15
  e0:	e8 22       	and	r14, r24
  e2:	f9 22       	and	r15, r25
  e4:	f6 01       	movw	r30, r12
  e6:	f1 82       	std	Z+1, r15	; 0x01
  e8:	e0 82       	st	Z, r14
  ea:	00 c0       	rjmp	.+0      	; 0xec <__SREG__+0xad>

Disassembly of section .text.hot.xEventGroupClearBits:

00000000 <xEventGroupClearBits>:
   0:	fc 01       	movw	r30, r24
   2:	0f b6       	in	r0, 0x3f	; 63
   4:	f8 94       	cli
   6:	0f 92       	push	r0
   8:	80 81       	ld	r24, Z
   a:	91 81       	ldd	r25, Z+1	; 0x01
   c:	60 95       	com	r22
   e:	70 95       	com	r23
  10:	68 23       	and	r22, r24
  12:	79 23       	and	r23, r25
  14:	71 83       	std	Z+1, r23	; 0x01
  16:	60 83       	st	Z, r22
  18:	0f 90       	pop	r0
  1a:	0f be       	out	0x3f, r0	; 63
  1c:	08 95       	ret

Disassembly of section .text.hot.xEventGroupGetBitsFromISR:

00000000 <xEventGroupGetBitsFromISR>:
   0:	fc 01       	movw	r30, r24
   2:	80 81       	ld	r24, Z
   4:	91 81       	ldd	r25, Z+1	; 0x01
   6:	08 95       	ret

Disassembly of section .text.hot.xEventGroupSetBits:

00000000 <xEventGroupSetBits>:
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	ec 01       	movw	r28, r24
  12:	8b 01       	movw	r16, r22
  14:	7c 01       	movw	r14, r24
  16:	85 e0       	ldi	r24, 0x05	; 5
  18:	e8 0e       	add	r14, r24
  1a:	f1 1c       	adc	r15, r1
  1c:	0e 94 00 00 	call	0	; 0x0 <xEventGroupSetBits>
  20:	ef 81       	ldd	r30, Y+7	; 0x07
  22:	f8 85       	ldd	r31, Y+8	; 0x08
  24:	68 81       	ld	r22, Y
  26:	79 81       	ldd	r23, Y+1	; 0x01
  28:	60 2b       	or	r22, r16
  2a:	71 2b       	or	r23, r17
  2c:	79 83       	std	Y+1, r23	; 0x01
  2e:	68 83       	st	Y, r22
  30:	10 e0       	ldi	r17, 0x00	; 0
  32:	00 e0       	ldi	r16, 0x00	; 0
  34:	68 81       	ld	r22, Y
  36:	79 81       	ldd	r23, Y+1	; 0x01
  38:	ee 15       	cp	r30, r14
  3a:	ff 05       	cpc	r31, r15
  3c:	01 f4       	brne	.+0      	; 0x3e <xEventGroupSetBits+0x3e>
  3e:	00 95       	com	r16
  40:	10 95       	com	r17
  42:	06 23       	and	r16, r22
  44:	17 23       	and	r17, r23
  46:	19 83       	std	Y+1, r17	; 0x01
  48:	08 83       	st	Y, r16
  4a:	0e 94 00 00 	call	0	; 0x0 <xEventGroupSetBits>
  4e:	88 81       	ld	r24, Y
  50:	99 81       	ldd	r25, Y+1	; 0x01
  52:	df 91       	pop	r29
  54:	cf 91       	pop	r28
  56:	1f 91       	pop	r17
  58:	0f 91       	pop	r16
  5a:	ff 90       	pop	r15
  5c:	ef 90       	pop	r14
  5e:	df 90       	pop	r13
  60:	cf 90       	pop	r12
  62:	08 95       	ret
  64:	c2 80       	ldd	r12, Z+2	; 0x02
  66:	d3 80       	ldd	r13, Z+3	; 0x03
  68:	20 81       	ld	r18, Z
  6a:	31 81       	ldd	r19, Z+1	; 0x01
  6c:	c9 01       	movw	r24, r18
  6e:	99 27       	eor	r25, r25
  70:	ac 01       	movw	r20, r24
  72:	46 23       	and	r20, r22
  74:	57 23       	and	r21, r23
  76:	32 fd       	sbrc	r19, 2
  78:	00 c0       	rjmp	.+0      	; 0x7a <xEventGroupSetBits+0x7a>
  7a:	45 2b       	or	r20, r21
  7c:	01 f4       	brne	.+0      	; 0x7e <xEventGroupSetBits+0x7e>
  7e:	f6 01       	movw	r30, r12
  80:	00 c0       	rjmp	.+0      	; 0x82 <xEventGroupSetBits+0x82>
  82:	84 17       	cp	r24, r20
  84:	95 07       	cpc	r25, r21
  86:	01 f4       	brne	.+0      	; 0x88 <xEventGroupSetBits+0x88>
  88:	30 ff       	sbrs	r19, 0
  8a:	00 c0       	rjmp	.+0      	; 0x8c <xEventGroupSetBits+0x8c>
  8c:	08 2b       	or	r16, r24
  8e:	19 2b       	or	r17, r25
  90:	72 60       	ori	r23, 0x02	; 2
  92:	cf 01       	movw	r24, r30
  94:	0e 94 00 00 	call	0	; 0x0 <xEventGroupSetBits>
  98:	00 c0       	rjmp	.+0      	; 0x9a <__SREG__+0x5b>

Disassembly of section .text.hot.xEventGroupSync:

00000000 <xEventGroupSync>:
   0:	af 92       	push	r10
   2:	bf 92       	push	r11
   4:	cf 92       	push	r12
   6:	df 92       	push	r13
   8:	ef 92       	push	r14
   a:	ff 92       	push	r15
   c:	0f 93       	push	r16
   e:	1f 93       	push	r17
  10:	cf 93       	push	r28
  12:	df 93       	push	r29
  14:	7c 01       	movw	r14, r24
  16:	eb 01       	movw	r28, r22
  18:	8a 01       	movw	r16, r20
  1a:	69 01       	movw	r12, r18
  1c:	0e 94 00 00 	call	0	; 0x0 <xEventGroupSync>
  20:	f7 01       	movw	r30, r14
  22:	a0 80       	ld	r10, Z
  24:	b1 80       	ldd	r11, Z+1	; 0x01
  26:	be 01       	movw	r22, r28
  28:	c7 01       	movw	r24, r14
  2a:	0e 94 00 00 	call	0	; 0x0 <xEventGroupSync>
  2e:	ca 29       	or	r28, r10
  30:	db 29       	or	r29, r11
  32:	ce 01       	movw	r24, r28
  34:	80 23       	and	r24, r16
  36:	91 23       	and	r25, r17
  38:	80 17       	cp	r24, r16
  3a:	91 07       	cpc	r25, r17
  3c:	01 f0       	breq	.+0      	; 0x3e <xEventGroupSync+0x3e>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <xEventGroupSync+0x40>
  40:	f7 01       	movw	r30, r14
  42:	80 81       	ld	r24, Z
  44:	91 81       	ldd	r25, Z+1	; 0x01
  46:	98 01       	movw	r18, r16
  48:	20 95       	com	r18
  4a:	30 95       	com	r19
  4c:	82 23       	and	r24, r18
  4e:	93 23       	and	r25, r19
  50:	91 83       	std	Z+1, r25	; 0x01
  52:	80 83       	st	Z, r24
  54:	d1 2c       	mov	r13, r1
  56:	c1 2c       	mov	r12, r1
  58:	0e 94 00 00 	call	0	; 0x0 <xEventGroupSync>
  5c:	cd 28       	or	r12, r13
  5e:	01 f0       	breq	.+0      	; 0x60 <xEventGroupSync+0x60>
  60:	81 11       	cpse	r24, r1
  62:	00 c0       	rjmp	.+0      	; 0x64 <xEventGroupSync+0x64>
  64:	0e 94 00 00 	call	0	; 0x0 <xEventGroupSync>
  68:	0e 94 00 00 	call	0	; 0x0 <xEventGroupSync>
  6c:	91 fd       	sbrc	r25, 1
  6e:	00 c0       	rjmp	.+0      	; 0x70 <xEventGroupSync+0x70>
  70:	0f b6       	in	r0, 0x3f	; 63
  72:	f8 94       	cli
  74:	0f 92       	push	r0
  76:	f7 01       	movw	r30, r14
  78:	80 81       	ld	r24, Z
  7a:	91 81       	ldd	r25, Z+1	; 0x01
  7c:	98 01       	movw	r18, r16
  7e:	28 23       	and	r18, r24
  80:	39 23       	and	r19, r25
  82:	20 17       	cp	r18, r16
  84:	31 07       	cpc	r19, r17
  86:	01 f4       	brne	.+0      	; 0x88 <xEventGroupSync+0x88>
  88:	a8 01       	movw	r20, r16
  8a:	40 95       	com	r20
  8c:	50 95       	com	r21
  8e:	48 23       	and	r20, r24
  90:	59 23       	and	r21, r25
  92:	51 83       	std	Z+1, r21	; 0x01
  94:	40 83       	st	Z, r20
  96:	0f 90       	pop	r0
  98:	0f be       	out	0x3f, r0	; 63
  9a:	ec 01       	movw	r28, r24
  9c:	dd 27       	eor	r29, r29
  9e:	ce 01       	movw	r24, r28
  a0:	df 91       	pop	r29
  a2:	cf 91       	pop	r28
  a4:	1f 91       	pop	r17
  a6:	0f 91       	pop	r16
  a8:	ff 90       	pop	r15
  aa:	ef 90       	pop	r14
  ac:	df 90       	pop	r13
  ae:	cf 90       	pop	r12
  b0:	bf 90       	pop	r11
  b2:	af 90       	pop	r10
  b4:	08 95       	ret
  b6:	c1 14       	cp	r12, r1
  b8:	d1 04       	cpc	r13, r1
  ba:	01 f0       	breq	.+0      	; 0xbc <xEventGroupSync+0xbc>
  bc:	a6 01       	movw	r20, r12
  be:	b8 01       	movw	r22, r16
  c0:	75 60       	ori	r23, 0x05	; 5
  c2:	c7 01       	movw	r24, r14
  c4:	02 96       	adiw	r24, 0x02	; 2
  c6:	0e 94 00 00 	call	0	; 0x0 <xEventGroupSync>
  ca:	d0 e0       	ldi	r29, 0x00	; 0
  cc:	c0 e0       	ldi	r28, 0x00	; 0
  ce:	00 c0       	rjmp	.+0      	; 0xd0 <xEventGroupSync+0xd0>
  d0:	f7 01       	movw	r30, r14
  d2:	c0 81       	ld	r28, Z
  d4:	d1 81       	ldd	r29, Z+1	; 0x01
  d6:	00 c0       	rjmp	.+0      	; 0xd8 <__SREG__+0x99>

Disassembly of section .text.hot.vEventGroupDelete:

00000000 <vEventGroupDelete>:
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
   6:	0e 94 00 00 	call	0	; 0x0 <vEventGroupDelete>
   a:	8a 81       	ldd	r24, Y+2	; 0x02
   c:	81 11       	cpse	r24, r1
   e:	00 c0       	rjmp	.+0      	; 0x10 <vEventGroupDelete+0x10>
  10:	0e 94 00 00 	call	0	; 0x0 <vEventGroupDelete>
  14:	ce 01       	movw	r24, r28
  16:	df 91       	pop	r29
  18:	cf 91       	pop	r28
  1a:	0c 94 00 00 	jmp	0	; 0x0 <vEventGroupDelete>
  1e:	60 e0       	ldi	r22, 0x00	; 0
  20:	72 e0       	ldi	r23, 0x02	; 2
  22:	8f 81       	ldd	r24, Y+7	; 0x07
  24:	98 85       	ldd	r25, Y+8	; 0x08
  26:	0e 94 00 00 	call	0	; 0x0 <vEventGroupDelete>
  2a:	00 c0       	rjmp	.+0      	; 0x2c <__zero_reg__+0x2b>

Disassembly of section .text.hot.vEventGroupSetBitsCallback:

00000000 <vEventGroupSetBitsCallback>:
   0:	ba 01       	movw	r22, r20
   2:	0c 94 00 00 	jmp	0	; 0x0 <vEventGroupSetBitsCallback>

Disassembly of section .text.hot.vEventGroupClearBitsCallback:

00000000 <vEventGroupClearBitsCallback>:
   0:	ba 01       	movw	r22, r20
   2:	0c 94 00 00 	jmp	0	; 0x0 <vEventGroupClearBitsCallback>

heap_3.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000954  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00001d24  00000000  00000000  00000988  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.hot.pvPortMalloc 00000026  00000000  00000000  000026ac  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.hot.vPortFree 00000022  00000000  00000000  000026d2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.hot.vPortHeapResetState 00000002  00000000  00000000  000026f4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .comment      00000012  00000000  00000000  000026f6  2**0
                  CONTENTS, READONLY

Disassembly of section .text.hot.pvPortMalloc:

00000000 <pvPortMalloc>:
 * scheduler.
 */
void vPortHeapResetState( void )
{
    /* No state needs to be re-initialised in heap_3. */
}
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
   6:	0e 94 00 00 	call	0	; 0x0 <pvPortMalloc>
   a:	ce 01       	movw	r24, r28
   c:	0e 94 00 00 	call	0	; 0x0 <pvPortMalloc>
  10:	ec 01       	movw	r28, r24
  12:	0e 94 00 00 	call	0	; 0x0 <pvPortMalloc>
  16:	20 97       	sbiw	r28, 0x00	; 0
  18:	01 f4       	brne	.+0      	; 0x1a <pvPortMalloc+0x1a>
  1a:	0e 94 00 00 	call	0	; 0x0 <pvPortMalloc>
  1e:	ce 01       	movw	r24, r28
  20:	df 91       	pop	r29
  22:	cf 91       	pop	r28
  24:	08 95       	ret

Disassembly of section .text.hot.vPortFree:

00000000 <vPortFree>:
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	00 97       	sbiw	r24, 0x00	; 0
   6:	01 f0       	breq	.+0      	; 0x8 <vPortFree+0x8>
   8:	ec 01       	movw	r28, r24
   a:	0e 94 00 00 	call	0	; 0x0 <vPortFree>
   e:	ce 01       	movw	r24, r28
  10:	0e 94 00 00 	call	0	; 0x0 <vPortFree>
  14:	df 91       	pop	r29
  16:	cf 91       	pop	r28
  18:	0c 94 00 00 	jmp	0	; 0x0 <vPortFree>
  1c:	df 91       	pop	r29
  1e:	cf 91       	pop	r28
  20:	08 95       	ret

Disassembly of section .text.hot.vPortHeapResetState:

00000000 <vPortHeapResetState>:
   0:	08 95       	ret

list.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000b28  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00001de5  00000000  00000000  00000b5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.hot.vListInitialise 0000001c  00000000  00000000  00002941  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text.hot.vListInitialiseItem 00000008  00000000  00000000  0000295d  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text.hot.vListInsertEnd 00000040  00000000  00000000  00002965  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text.hot.vListInsert 0000006c  00000000  00000000  000029a5  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.hot.uxListRemove 00000046  00000000  00000000  00002a11  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .comment      00000012  00000000  00000000  00002a57  2**0
                  CONTENTS, READONLY

Disassembly of section .text.hot.vListInitialise:

00000000 <vListInitialise>:
    traceRETURN_vListInsert();
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
   0:	fc 01       	movw	r30, r24
   2:	03 96       	adiw	r24, 0x03	; 3
   4:	92 83       	std	Z+2, r25	; 0x02
    /* The list item knows which list it is in.  Obtain the list from the list
     * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
   6:	81 83       	std	Z+1, r24	; 0x01
   8:	2f ef       	ldi	r18, 0xFF	; 255

    traceENTER_uxListRemove( pxItemToRemove );

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   a:	3f ef       	ldi	r19, 0xFF	; 255
   c:	34 83       	std	Z+4, r19	; 0x04
   e:	23 83       	std	Z+3, r18	; 0x03
  10:	96 83       	std	Z+6, r25	; 0x06
  12:	85 83       	std	Z+5, r24	; 0x05
  14:	90 87       	std	Z+8, r25	; 0x08
  16:	87 83       	std	Z+7, r24	; 0x07
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  18:	10 82       	st	Z, r1
  1a:	08 95       	ret

Disassembly of section .text.hot.vListInitialiseItem:

00000000 <vListInitialiseItem>:
    traceRETURN_vListInsert();
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
   0:	fc 01       	movw	r30, r24
   2:	11 86       	std	Z+9, r1	; 0x09
   4:	10 86       	std	Z+8, r1	; 0x08
    /* The list item knows which list it is in.  Obtain the list from the list
     * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
   6:	08 95       	ret

Disassembly of section .text.hot.vListInsertEnd:

00000000 <vListInsertEnd>:
    traceRETURN_vListInsert();
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	9c 01       	movw	r18, r24
    /* The list item knows which list it is in.  Obtain the list from the list
     * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
   6:	fb 01       	movw	r30, r22
   8:	dc 01       	movw	r26, r24

    traceENTER_uxListRemove( pxItemToRemove );

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   a:	11 96       	adiw	r26, 0x01	; 1
   c:	cd 91       	ld	r28, X+
   e:	dc 91       	ld	r29, X
  10:	d3 83       	std	Z+3, r29	; 0x03
  12:	c2 83       	std	Z+2, r28	; 0x02
  14:	8c 81       	ldd	r24, Y+4	; 0x04
  16:	9d 81       	ldd	r25, Y+5	; 0x05
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  18:	95 83       	std	Z+5, r25	; 0x05
  1a:	84 83       	std	Z+4, r24	; 0x04
  1c:	8c 81       	ldd	r24, Y+4	; 0x04
  1e:	9d 81       	ldd	r25, Y+5	; 0x05

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
  20:	dc 01       	movw	r26, r24
  22:	13 96       	adiw	r26, 0x03	; 3
  24:	7c 93       	st	X, r23
  26:	6e 93       	st	-X, r22
  28:	12 97       	sbiw	r26, 0x02	; 2
  2a:	7d 83       	std	Y+5, r23	; 0x05
  2c:	6c 83       	std	Y+4, r22	; 0x04
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
  2e:	31 87       	std	Z+9, r19	; 0x09
  30:	20 87       	std	Z+8, r18	; 0x08
  32:	f9 01       	movw	r30, r18
  34:	80 81       	ld	r24, Z
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
  36:	8f 5f       	subi	r24, 0xFF	; 255
  38:	80 83       	st	Z, r24
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems - 1U );
  3a:	df 91       	pop	r29
  3c:	cf 91       	pop	r28
  3e:	08 95       	ret

Disassembly of section .text.hot.vListInsert:

00000000 <vListInsert>:
    traceRETURN_vListInsert();
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
    /* The list item knows which list it is in.  Obtain the list from the list
     * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
   6:	df 93       	push	r29
   8:	8c 01       	movw	r16, r24

    traceENTER_uxListRemove( pxItemToRemove );

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   a:	fb 01       	movw	r30, r22
   c:	80 81       	ld	r24, Z
   e:	91 81       	ldd	r25, Z+1	; 0x01
  10:	d8 01       	movw	r26, r16
  12:	13 96       	adiw	r26, 0x03	; 3
  14:	8f 3f       	cpi	r24, 0xFF	; 255
  16:	98 07       	cpc	r25, r24
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  18:	01 f4       	brne	.+0      	; 0x1a <vListInsert+0x1a>
  1a:	e8 01       	movw	r28, r16
  1c:	af 81       	ldd	r26, Y+7	; 0x07
  1e:	b8 85       	ldd	r27, Y+8	; 0x08

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
  20:	12 96       	adiw	r26, 0x02	; 2
  22:	8d 91       	ld	r24, X+
  24:	9c 91       	ld	r25, X
  26:	13 97       	sbiw	r26, 0x03	; 3
  28:	93 83       	std	Z+3, r25	; 0x03
  2a:	82 83       	std	Z+2, r24	; 0x02
  2c:	ec 01       	movw	r28, r24
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
  2e:	fd 83       	std	Y+5, r31	; 0x05
  30:	ec 83       	std	Y+4, r30	; 0x04
  32:	b5 83       	std	Z+5, r27	; 0x05
  34:	a4 83       	std	Z+4, r26	; 0x04
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
  36:	13 96       	adiw	r26, 0x03	; 3
  38:	fc 93       	st	X, r31
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems - 1U );
  3a:	ee 93       	st	-X, r30
  3c:	12 97       	sbiw	r26, 0x02	; 2
  3e:	11 87       	std	Z+9, r17	; 0x09

    traceRETURN_uxListRemove( pxList->uxNumberOfItems );

    return pxList->uxNumberOfItems;
}
  40:	00 87       	std	Z+8, r16	; 0x08
  42:	f8 01       	movw	r30, r16
  44:	80 81       	ld	r24, Z
  46:	8f 5f       	subi	r24, 0xFF	; 255
  48:	80 83       	st	Z, r24
  4a:	df 91       	pop	r29
  4c:	cf 91       	pop	r28
  4e:	1f 91       	pop	r17
  50:	0f 91       	pop	r16
  52:	08 95       	ret
  54:	d9 01       	movw	r26, r18
  56:	12 96       	adiw	r26, 0x02	; 2
  58:	2d 91       	ld	r18, X+
  5a:	3c 91       	ld	r19, X
  5c:	13 97       	sbiw	r26, 0x03	; 3
  5e:	e9 01       	movw	r28, r18
  60:	48 81       	ld	r20, Y
  62:	59 81       	ldd	r21, Y+1	; 0x01
  64:	84 17       	cp	r24, r20
  66:	95 07       	cpc	r25, r21
  68:	00 f4       	brcc	.+0      	; 0x6a <vListInsert+0x6a>
  6a:	00 c0       	rjmp	.+0      	; 0x6c <__SREG__+0x2d>

Disassembly of section .text.hot.uxListRemove:

00000000 <uxListRemove>:
    traceRETURN_vListInsert();
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	fc 01       	movw	r30, r24
    /* The list item knows which list it is in.  Obtain the list from the list
     * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
   6:	a0 85       	ldd	r26, Z+8	; 0x08
   8:	b1 85       	ldd	r27, Z+9	; 0x09

    traceENTER_uxListRemove( pxItemToRemove );

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   a:	82 81       	ldd	r24, Z+2	; 0x02
   c:	93 81       	ldd	r25, Z+3	; 0x03
   e:	24 81       	ldd	r18, Z+4	; 0x04
  10:	35 81       	ldd	r19, Z+5	; 0x05
  12:	ec 01       	movw	r28, r24
  14:	3d 83       	std	Y+5, r19	; 0x05
  16:	2c 83       	std	Y+4, r18	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  18:	c4 81       	ldd	r28, Z+4	; 0x04
  1a:	d5 81       	ldd	r29, Z+5	; 0x05
  1c:	9b 83       	std	Y+3, r25	; 0x03
  1e:	8a 83       	std	Y+2, r24	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
  20:	11 96       	adiw	r26, 0x01	; 1
  22:	8d 91       	ld	r24, X+
  24:	9c 91       	ld	r25, X
  26:	12 97       	sbiw	r26, 0x02	; 2
  28:	8e 17       	cp	r24, r30
  2a:	9f 07       	cpc	r25, r31
  2c:	01 f4       	brne	.+0      	; 0x2e <uxListRemove+0x2e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
  2e:	12 96       	adiw	r26, 0x02	; 2
  30:	dc 93       	st	X, r29
  32:	ce 93       	st	-X, r28
  34:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
  36:	11 86       	std	Z+9, r1	; 0x09
  38:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems - 1U );
  3a:	8c 91       	ld	r24, X
  3c:	81 50       	subi	r24, 0x01	; 1
  3e:	8c 93       	st	X, r24

    traceRETURN_uxListRemove( pxList->uxNumberOfItems );

    return pxList->uxNumberOfItems;
}
  40:	df 91       	pop	r29
  42:	cf 91       	pop	r28
  44:	08 95       	ret

port.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000cfc  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000209e  00000000  00000000  00000d30  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.hot.pxPortInitialiseStack 000000d8  00000000  00000000  00002dce  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text.hot.xPortStartScheduler 00000084  00000000  00000000  00002ea6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.hot.vPortEndScheduler 00000018  00000000  00000000  00002f2a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text.hot.vPortYield 000000b2  00000000  00000000  00002f42  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.hot.vPortDelay 00000046  00000000  00000000  00002ff4  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.hot.vPortYieldFromTick 000000e4  00000000  00000000  0000303a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.hot.__vector_6 00000006  00000000  00000000  0000311e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .comment      00000012  00000000  00000000  00003124  2**0
                  CONTENTS, READONLY

Disassembly of section .text.hot.pxPortInitialiseStack:

00000000 <pxPortInitialiseStack>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
   0:	31 e1       	ldi	r19, 0x11	; 17
   2:	fc 01       	movw	r30, r24
		__asm__ __volatile__ ( "reti" );
   4:	30 83       	st	Z, r19
	}
   6:	31 97       	sbiw	r30, 0x01	; 1
   8:	22 e2       	ldi	r18, 0x22	; 34
   a:	20 83       	st	Z, r18
   c:	31 97       	sbiw	r30, 0x01	; 1
   e:	a3 e3       	ldi	r26, 0x33	; 51
  10:	a0 83       	st	Z, r26
  12:	31 97       	sbiw	r30, 0x01	; 1
  14:	60 83       	st	Z, r22
  16:	31 97       	sbiw	r30, 0x01	; 1
  18:	70 83       	st	Z, r23
  1a:	31 97       	sbiw	r30, 0x01	; 1
  1c:	10 82       	st	Z, r1
  1e:	31 97       	sbiw	r30, 0x01	; 1
  20:	60 e8       	ldi	r22, 0x80	; 128
  22:	60 83       	st	Z, r22
  24:	31 97       	sbiw	r30, 0x01	; 1
  26:	10 82       	st	Z, r1
  28:	31 97       	sbiw	r30, 0x01	; 1
  2a:	62 e0       	ldi	r22, 0x02	; 2
  2c:	60 83       	st	Z, r22
  2e:	31 97       	sbiw	r30, 0x01	; 1
  30:	63 e0       	ldi	r22, 0x03	; 3
  32:	60 83       	st	Z, r22
  34:	31 97       	sbiw	r30, 0x01	; 1
  36:	64 e0       	ldi	r22, 0x04	; 4
  38:	60 83       	st	Z, r22
  3a:	31 97       	sbiw	r30, 0x01	; 1
  3c:	65 e0       	ldi	r22, 0x05	; 5
  3e:	60 83       	st	Z, r22
  40:	31 97       	sbiw	r30, 0x01	; 1
  42:	66 e0       	ldi	r22, 0x06	; 6
  44:	60 83       	st	Z, r22
  46:	31 97       	sbiw	r30, 0x01	; 1
  48:	67 e0       	ldi	r22, 0x07	; 7
  4a:	60 83       	st	Z, r22
  4c:	31 97       	sbiw	r30, 0x01	; 1
  4e:	68 e0       	ldi	r22, 0x08	; 8
  50:	60 83       	st	Z, r22
  52:	31 97       	sbiw	r30, 0x01	; 1
  54:	69 e0       	ldi	r22, 0x09	; 9
  56:	60 83       	st	Z, r22
  58:	31 97       	sbiw	r30, 0x01	; 1
  5a:	60 e1       	ldi	r22, 0x10	; 16
  5c:	60 83       	st	Z, r22
  5e:	31 97       	sbiw	r30, 0x01	; 1
  60:	30 83       	st	Z, r19
  62:	31 97       	sbiw	r30, 0x01	; 1
  64:	32 e1       	ldi	r19, 0x12	; 18
  66:	30 83       	st	Z, r19
  68:	31 97       	sbiw	r30, 0x01	; 1
  6a:	33 e1       	ldi	r19, 0x13	; 19
  6c:	30 83       	st	Z, r19
  6e:	31 97       	sbiw	r30, 0x01	; 1
  70:	34 e1       	ldi	r19, 0x14	; 20
  72:	30 83       	st	Z, r19
  74:	31 97       	sbiw	r30, 0x01	; 1
  76:	35 e1       	ldi	r19, 0x15	; 21
  78:	30 83       	st	Z, r19
  7a:	31 97       	sbiw	r30, 0x01	; 1
  7c:	36 e1       	ldi	r19, 0x16	; 22
  7e:	30 83       	st	Z, r19
  80:	31 97       	sbiw	r30, 0x01	; 1
  82:	37 e1       	ldi	r19, 0x17	; 23
  84:	30 83       	st	Z, r19
  86:	31 97       	sbiw	r30, 0x01	; 1
  88:	38 e1       	ldi	r19, 0x18	; 24
  8a:	30 83       	st	Z, r19
  8c:	31 97       	sbiw	r30, 0x01	; 1
  8e:	39 e1       	ldi	r19, 0x19	; 25
  90:	30 83       	st	Z, r19
  92:	31 97       	sbiw	r30, 0x01	; 1
  94:	30 e2       	ldi	r19, 0x20	; 32
  96:	30 83       	st	Z, r19
  98:	31 97       	sbiw	r30, 0x01	; 1
  9a:	31 e2       	ldi	r19, 0x21	; 33
  9c:	30 83       	st	Z, r19
  9e:	31 97       	sbiw	r30, 0x01	; 1
  a0:	20 83       	st	Z, r18
  a2:	31 97       	sbiw	r30, 0x01	; 1
  a4:	23 e2       	ldi	r18, 0x23	; 35
  a6:	20 83       	st	Z, r18
  a8:	31 97       	sbiw	r30, 0x01	; 1
  aa:	40 83       	st	Z, r20
  ac:	31 97       	sbiw	r30, 0x01	; 1
  ae:	50 83       	st	Z, r21
  b0:	31 97       	sbiw	r30, 0x01	; 1
  b2:	26 e2       	ldi	r18, 0x26	; 38
  b4:	20 83       	st	Z, r18
  b6:	31 97       	sbiw	r30, 0x01	; 1
  b8:	27 e2       	ldi	r18, 0x27	; 39
  ba:	20 83       	st	Z, r18
  bc:	31 97       	sbiw	r30, 0x01	; 1
  be:	28 e2       	ldi	r18, 0x28	; 40
  c0:	20 83       	st	Z, r18
  c2:	31 97       	sbiw	r30, 0x01	; 1
  c4:	29 e2       	ldi	r18, 0x29	; 41
  c6:	20 83       	st	Z, r18
  c8:	31 97       	sbiw	r30, 0x01	; 1
  ca:	20 e3       	ldi	r18, 0x30	; 48
  cc:	20 83       	st	Z, r18
  ce:	31 97       	sbiw	r30, 0x01	; 1
  d0:	21 e3       	ldi	r18, 0x31	; 49
  d2:	20 83       	st	Z, r18
  d4:	86 97       	sbiw	r24, 0x26	; 38
  d6:	08 95       	ret

Disassembly of section .text.hot.xPortStartScheduler:

00000000 <xPortStartScheduler>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
   0:	a8 95       	wdr
   2:	8e e3       	ldi	r24, 0x3E	; 62
		__asm__ __volatile__ ( "reti" );
   4:	90 e0       	ldi	r25, 0x00	; 0
	}
   6:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
   a:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
   e:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
  12:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  16:	88 e1       	ldi	r24, 0x18	; 24
  18:	9e e0       	ldi	r25, 0x0E	; 14
  1a:	0f b6       	in	r0, 0x3f	; 63
  1c:	f8 94       	cli
  1e:	a8 95       	wdr
  20:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__SREG__+0x800021>
  24:	0f be       	out	0x3f, r0	; 63
  26:	90 93 60 00 	sts	0x0060, r25	; 0x800060 <__SREG__+0x800021>
  2a:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  2e:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  32:	cd 91       	ld	r28, X+
  34:	cd bf       	out	0x3d, r28	; 61
  36:	dd 91       	ld	r29, X+
  38:	de bf       	out	0x3e, r29	; 62
  3a:	ff 91       	pop	r31
  3c:	ef 91       	pop	r30
  3e:	df 91       	pop	r29
  40:	cf 91       	pop	r28
  42:	bf 91       	pop	r27
  44:	af 91       	pop	r26
  46:	9f 91       	pop	r25
  48:	8f 91       	pop	r24
  4a:	7f 91       	pop	r23
  4c:	6f 91       	pop	r22
  4e:	5f 91       	pop	r21
  50:	4f 91       	pop	r20
  52:	3f 91       	pop	r19
  54:	2f 91       	pop	r18
  56:	1f 91       	pop	r17
  58:	0f 91       	pop	r16
  5a:	ff 90       	pop	r15
  5c:	ef 90       	pop	r14
  5e:	df 90       	pop	r13
  60:	cf 90       	pop	r12
  62:	bf 90       	pop	r11
  64:	af 90       	pop	r10
  66:	9f 90       	pop	r9
  68:	8f 90       	pop	r8
  6a:	7f 90       	pop	r7
  6c:	6f 90       	pop	r6
  6e:	5f 90       	pop	r5
  70:	4f 90       	pop	r4
  72:	3f 90       	pop	r3
  74:	2f 90       	pop	r2
  76:	1f 90       	pop	r1
  78:	0f 90       	pop	r0
  7a:	0f be       	out	0x3f, r0	; 63
  7c:	0f 90       	pop	r0
  7e:	08 95       	ret
  80:	81 e0       	ldi	r24, 0x01	; 1
  82:	08 95       	ret

Disassembly of section .text.hot.vPortEndScheduler:

00000000 <vPortEndScheduler>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
   0:	0f b6       	in	r0, 0x3f	; 63
   2:	f8 94       	cli
		__asm__ __volatile__ ( "reti" );
   4:	a8 95       	wdr
	}
   6:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__SREG__+0x800021>
   a:	88 61       	ori	r24, 0x18	; 24
   c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__SREG__+0x800021>
  10:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__SREG__+0x800021>
  14:	0f be       	out	0x3f, r0	; 63
  16:	08 95       	ret

Disassembly of section .text.hot.vPortYield:

00000000 <vPortYield>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
   0:	0f 92       	push	r0
   2:	0f b6       	in	r0, 0x3f	; 63
		__asm__ __volatile__ ( "reti" );
   4:	f8 94       	cli
	}
   6:	0f 92       	push	r0
   8:	1f 92       	push	r1
   a:	11 24       	eor	r1, r1
   c:	2f 92       	push	r2
   e:	3f 92       	push	r3
  10:	4f 92       	push	r4
  12:	5f 92       	push	r5
  14:	6f 92       	push	r6
  16:	7f 92       	push	r7
  18:	8f 92       	push	r8
  1a:	9f 92       	push	r9
  1c:	af 92       	push	r10
  1e:	bf 92       	push	r11
  20:	cf 92       	push	r12
  22:	df 92       	push	r13
  24:	ef 92       	push	r14
  26:	ff 92       	push	r15
  28:	0f 93       	push	r16
  2a:	1f 93       	push	r17
  2c:	2f 93       	push	r18
  2e:	3f 93       	push	r19
  30:	4f 93       	push	r20
  32:	5f 93       	push	r21
  34:	6f 93       	push	r22
  36:	7f 93       	push	r23
  38:	8f 93       	push	r24
  3a:	9f 93       	push	r25
  3c:	af 93       	push	r26
  3e:	bf 93       	push	r27
  40:	cf 93       	push	r28
  42:	df 93       	push	r29
  44:	ef 93       	push	r30
  46:	ff 93       	push	r31
  48:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  4c:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  50:	0d b6       	in	r0, 0x3d	; 61
  52:	0d 92       	st	X+, r0
  54:	0e b6       	in	r0, 0x3e	; 62
  56:	0d 92       	st	X+, r0
  58:	0e 94 00 00 	call	0	; 0x0 <vPortYield>
  5c:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  60:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  64:	cd 91       	ld	r28, X+
  66:	cd bf       	out	0x3d, r28	; 61
  68:	dd 91       	ld	r29, X+
  6a:	de bf       	out	0x3e, r29	; 62
  6c:	ff 91       	pop	r31
  6e:	ef 91       	pop	r30
  70:	df 91       	pop	r29
  72:	cf 91       	pop	r28
  74:	bf 91       	pop	r27
  76:	af 91       	pop	r26
  78:	9f 91       	pop	r25
  7a:	8f 91       	pop	r24
  7c:	7f 91       	pop	r23
  7e:	6f 91       	pop	r22
  80:	5f 91       	pop	r21
  82:	4f 91       	pop	r20
  84:	3f 91       	pop	r19
  86:	2f 91       	pop	r18
  88:	1f 91       	pop	r17
  8a:	0f 91       	pop	r16
  8c:	ff 90       	pop	r15
  8e:	ef 90       	pop	r14
  90:	df 90       	pop	r13
  92:	cf 90       	pop	r12
  94:	bf 90       	pop	r11
  96:	af 90       	pop	r10
  98:	9f 90       	pop	r9
  9a:	8f 90       	pop	r8
  9c:	7f 90       	pop	r7
  9e:	6f 90       	pop	r6
  a0:	5f 90       	pop	r5
  a2:	4f 90       	pop	r4
  a4:	3f 90       	pop	r3
  a6:	2f 90       	pop	r2
  a8:	1f 90       	pop	r1
  aa:	0f 90       	pop	r0
  ac:	0f be       	out	0x3f, r0	; 63
  ae:	0f 90       	pop	r0
  b0:	08 95       	ret

Disassembly of section .text.hot.vPortDelay:

00000000 <vPortDelay>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
		__asm__ __volatile__ ( "reti" );
   4:	ef 92       	push	r14
	}
   6:	ff 92       	push	r15
   8:	60 31       	cpi	r22, 0x10	; 16
   a:	71 05       	cpc	r23, r1
   c:	81 05       	cpc	r24, r1
   e:	91 05       	cpc	r25, r1
  10:	00 f4       	brcc	.+0      	; 0x12 <vPortDelay+0x12>
  12:	ff 90       	pop	r15
  14:	ef 90       	pop	r14
  16:	df 90       	pop	r13
  18:	cf 90       	pop	r12
  1a:	0c 94 00 00 	jmp	0	; 0x0 <vPortDelay>
  1e:	6b 01       	movw	r12, r22
  20:	7c 01       	movw	r14, r24
  22:	dc 01       	movw	r26, r24
  24:	cb 01       	movw	r24, r22
  26:	24 e0       	ldi	r18, 0x04	; 4
  28:	b6 95       	lsr	r27
  2a:	a7 95       	ror	r26
  2c:	97 95       	ror	r25
  2e:	87 95       	ror	r24
  30:	2a 95       	dec	r18
  32:	01 f4       	brne	.+0      	; 0x34 <vPortDelay+0x34>
  34:	0e 94 00 00 	call	0	; 0x0 <vPortDelay>
  38:	c7 01       	movw	r24, r14
  3a:	b6 01       	movw	r22, r12
  3c:	6f 70       	andi	r22, 0x0F	; 15
  3e:	77 27       	eor	r23, r23
  40:	88 27       	eor	r24, r24
  42:	99 27       	eor	r25, r25
  44:	00 c0       	rjmp	.+0      	; 0x46 <__SREG__+0x7>

Disassembly of section .text.hot.vPortYieldFromTick:

00000000 <vPortYieldFromTick>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
   0:	0f 92       	push	r0
   2:	0f b6       	in	r0, 0x3f	; 63
		__asm__ __volatile__ ( "reti" );
   4:	f8 94       	cli
	}
   6:	0f 92       	push	r0
   8:	1f 92       	push	r1
   a:	11 24       	eor	r1, r1
   c:	2f 92       	push	r2
   e:	3f 92       	push	r3
  10:	4f 92       	push	r4
  12:	5f 92       	push	r5
  14:	6f 92       	push	r6
  16:	7f 92       	push	r7
  18:	8f 92       	push	r8
  1a:	9f 92       	push	r9
  1c:	af 92       	push	r10
  1e:	bf 92       	push	r11
  20:	cf 92       	push	r12
  22:	df 92       	push	r13
  24:	ef 92       	push	r14
  26:	ff 92       	push	r15
  28:	0f 93       	push	r16
  2a:	1f 93       	push	r17
  2c:	2f 93       	push	r18
  2e:	3f 93       	push	r19
  30:	4f 93       	push	r20
  32:	5f 93       	push	r21
  34:	6f 93       	push	r22
  36:	7f 93       	push	r23
  38:	8f 93       	push	r24
  3a:	9f 93       	push	r25
  3c:	af 93       	push	r26
  3e:	bf 93       	push	r27
  40:	cf 93       	push	r28
  42:	df 93       	push	r29
  44:	ef 93       	push	r30
  46:	ff 93       	push	r31
  48:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  4c:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  50:	0d b6       	in	r0, 0x3d	; 61
  52:	0d 92       	st	X+, r0
  54:	0e b6       	in	r0, 0x3e	; 62
  56:	0d 92       	st	X+, r0
  58:	13 be       	out	0x33, r1	; 51
  5a:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  5e:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  62:	01 97       	sbiw	r24, 0x01	; 1
  64:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
  68:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  6c:	89 2b       	or	r24, r25
  6e:	01 f4       	brne	.+0      	; 0x70 <vPortYieldFromTick+0x70>
  70:	0e 94 00 00 	call	0	; 0x0 <vPortYieldFromTick>
  74:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  78:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  7c:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
  80:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  84:	0e 94 00 00 	call	0	; 0x0 <vPortYieldFromTick>
  88:	81 11       	cpse	r24, r1
  8a:	0e 94 00 00 	call	0	; 0x0 <vPortYieldFromTick>
  8e:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  92:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  96:	cd 91       	ld	r28, X+
  98:	cd bf       	out	0x3d, r28	; 61
  9a:	dd 91       	ld	r29, X+
  9c:	de bf       	out	0x3e, r29	; 62
  9e:	ff 91       	pop	r31
  a0:	ef 91       	pop	r30
  a2:	df 91       	pop	r29
  a4:	cf 91       	pop	r28
  a6:	bf 91       	pop	r27
  a8:	af 91       	pop	r26
  aa:	9f 91       	pop	r25
  ac:	8f 91       	pop	r24
  ae:	7f 91       	pop	r23
  b0:	6f 91       	pop	r22
  b2:	5f 91       	pop	r21
  b4:	4f 91       	pop	r20
  b6:	3f 91       	pop	r19
  b8:	2f 91       	pop	r18
  ba:	1f 91       	pop	r17
  bc:	0f 91       	pop	r16
  be:	ff 90       	pop	r15
  c0:	ef 90       	pop	r14
  c2:	df 90       	pop	r13
  c4:	cf 90       	pop	r12
  c6:	bf 90       	pop	r11
  c8:	af 90       	pop	r10
  ca:	9f 90       	pop	r9
  cc:	8f 90       	pop	r8
  ce:	7f 90       	pop	r7
  d0:	6f 90       	pop	r6
  d2:	5f 90       	pop	r5
  d4:	4f 90       	pop	r4
  d6:	3f 90       	pop	r3
  d8:	2f 90       	pop	r2
  da:	1f 90       	pop	r1
  dc:	0f 90       	pop	r0
  de:	0f be       	out	0x3f, r0	; 63
  e0:	0f 90       	pop	r0
  e2:	08 95       	ret

Disassembly of section .text.hot.__vector_6:

00000000 <__vector_6>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
   0:	0e 94 00 00 	call	0	; 0x0 <__vector_6>
		__asm__ __volatile__ ( "reti" );
   4:	18 95       	reti

queue.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000024b4  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00002ac7  00000000  00000000  000024e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.hot.prvIsQueueEmpty 00000016  00000000  00000000  00004faf  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text.hot.prvCopyDataToQueue 000000aa  00000000  00000000  00004fc5  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.hot.prvCopyDataFromQueue 00000034  00000000  00000000  0000506f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.hot.prvUnlockQueue 0000007c  00000000  00000000  000050a3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.hot.xQueueGenericReset 0000008e  00000000  00000000  0000511f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.hot.xQueueGenericCreate 00000050  00000000  00000000  000051ad  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.hot.xQueueCreateCountingSemaphore 00000026  00000000  00000000  000051fd  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text.hot.xQueueGenericSend 0000012a  00000000  00000000  00005223  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.hot.xQueueCreateMutex 00000034  00000000  00000000  0000534d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text.hot.xQueueGiveMutexRecursive 00000042  00000000  00000000  00005381  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text.hot.xQueueGenericSendFromISR 00000068  00000000  00000000  000053c3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 16 .text.hot.xQueueGiveFromISR 00000060  00000000  00000000  0000542b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 17 .text.hot.xQueueReceive 00000122  00000000  00000000  0000548b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 18 .text.hot.xQueueSemaphoreTake 00000184  00000000  00000000  000055ad  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 19 .text.hot.xQueueTakeMutexRecursive 00000048  00000000  00000000  00005731  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 20 .text.hot.xQueuePeek 00000122  00000000  00000000  00005779  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 21 .text.hot.xQueueReceiveFromISR 00000068  00000000  00000000  0000589b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 22 .text.hot.xQueuePeekFromISR 0000002e  00000000  00000000  00005903  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 23 .text.hot.uxQueueMessagesWaiting 00000010  00000000  00000000  00005931  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .text.hot.uxQueueSpacesAvailable 00000014  00000000  00000000  00005941  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .text.hot.uxQueueMessagesWaitingFromISR 00000006  00000000  00000000  00005955  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .text.hot.vQueueDelete 00000004  00000000  00000000  0000595b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 27 .text.hot.uxQueueGetQueueItemSize 00000006  00000000  00000000  0000595f  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .text.hot.uxQueueGetQueueLength 00000006  00000000  00000000  00005965  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 29 .text.hot.xQueueIsQueueEmptyFromISR 0000000c  00000000  00000000  0000596b  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 30 .text.hot.xQueueIsQueueFullFromISR 0000000e  00000000  00000000  00005977  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .text.hot.vQueueWaitForMessageRestricted 00000038  00000000  00000000  00005985  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 32 .comment      00000012  00000000  00000000  000059bd  2**0
                  CONTENTS, READONLY

Disassembly of section .text.hot.prvIsQueueEmpty:

00000000 <prvIsQueueEmpty>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	0f b6       	in	r0, 0x3f	; 63
   2:	f8 94       	cli
   4:	0f 92       	push	r0
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	fc 01       	movw	r30, r24
   8:	92 8d       	ldd	r25, Z+26	; 0x1a
   a:	0f 90       	pop	r0
   c:	0f be       	out	0x3f, r0	; 63
   e:	81 e0       	ldi	r24, 0x01	; 1
  10:	91 11       	cpse	r25, r1
  12:	80 e0       	ldi	r24, 0x00	; 0
  14:	08 95       	ret

Disassembly of section .text.hot.prvCopyDataToQueue:

00000000 <prvCopyDataToQueue>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	df 93       	push	r29
   8:	ec 01       	movw	r28, r24
   a:	04 2f       	mov	r16, r20
   c:	1a 8d       	ldd	r17, Y+26	; 0x1a
   e:	4c 8d       	ldd	r20, Y+28	; 0x1c
  10:	41 11       	cpse	r20, r1
  12:	00 c0       	rjmp	.+0      	; 0x14 <prvCopyDataToQueue+0x14>
  14:	88 81       	ld	r24, Y
  16:	99 81       	ldd	r25, Y+1	; 0x01
  18:	89 2b       	or	r24, r25
  1a:	01 f4       	brne	.+0      	; 0x1c <prvCopyDataToQueue+0x1c>
  1c:	8c 81       	ldd	r24, Y+4	; 0x04
  1e:	9d 81       	ldd	r25, Y+5	; 0x05

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  20:	0e 94 00 00 	call	0	; 0x0 <prvCopyDataToQueue>
  24:	1d 82       	std	Y+5, r1	; 0x05
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  26:	1c 82       	std	Y+4, r1	; 0x04
  28:	1f 5f       	subi	r17, 0xFF	; 255
  2a:	1a 8f       	std	Y+26, r17	; 0x1a
  2c:	df 91       	pop	r29
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  2e:	cf 91       	pop	r28

        traceRETURN_vQueueWaitForMessageRestricted();
    }
  30:	1f 91       	pop	r17
  32:	0f 91       	pop	r16
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  34:	08 95       	ret
  36:	50 e0       	ldi	r21, 0x00	; 0
  38:	01 11       	cpse	r16, r1
  3a:	00 c0       	rjmp	.+0      	; 0x3c <prvCopyDataToQueue+0x3c>
  3c:	8a 81       	ldd	r24, Y+2	; 0x02
  3e:	9b 81       	ldd	r25, Y+3	; 0x03
  40:	0e 94 00 00 	call	0	; 0x0 <prvCopyDataToQueue>
  44:	8c 8d       	ldd	r24, Y+28	; 0x1c
  46:	2a 81       	ldd	r18, Y+2	; 0x02
  48:	3b 81       	ldd	r19, Y+3	; 0x03
  4a:	82 0f       	add	r24, r18
  4c:	93 2f       	mov	r25, r19
  4e:	91 1d       	adc	r25, r1
  50:	9b 83       	std	Y+3, r25	; 0x03
  52:	8a 83       	std	Y+2, r24	; 0x02
  54:	2c 81       	ldd	r18, Y+4	; 0x04
  56:	3d 81       	ldd	r19, Y+5	; 0x05
  58:	82 17       	cp	r24, r18
  5a:	93 07       	cpc	r25, r19
  5c:	00 f0       	brcs	.+0      	; 0x5e <prvCopyDataToQueue+0x5e>
  5e:	88 81       	ld	r24, Y
  60:	99 81       	ldd	r25, Y+1	; 0x01
  62:	9b 83       	std	Y+3, r25	; 0x03
  64:	8a 83       	std	Y+2, r24	; 0x02
  66:	80 e0       	ldi	r24, 0x00	; 0
  68:	00 c0       	rjmp	.+0      	; 0x6a <prvCopyDataToQueue+0x6a>
  6a:	8e 81       	ldd	r24, Y+6	; 0x06
  6c:	9f 81       	ldd	r25, Y+7	; 0x07
  6e:	0e 94 00 00 	call	0	; 0x0 <prvCopyDataToQueue>
  72:	8c 8d       	ldd	r24, Y+28	; 0x1c
  74:	90 e0       	ldi	r25, 0x00	; 0
  76:	91 95       	neg	r25
  78:	81 95       	neg	r24
  7a:	91 09       	sbc	r25, r1
  7c:	2e 81       	ldd	r18, Y+6	; 0x06
  7e:	3f 81       	ldd	r19, Y+7	; 0x07
  80:	28 0f       	add	r18, r24
  82:	39 1f       	adc	r19, r25
  84:	3f 83       	std	Y+7, r19	; 0x07
  86:	2e 83       	std	Y+6, r18	; 0x06
  88:	48 81       	ld	r20, Y
  8a:	59 81       	ldd	r21, Y+1	; 0x01
  8c:	24 17       	cp	r18, r20
  8e:	35 07       	cpc	r19, r21
  90:	00 f4       	brcc	.+0      	; 0x92 <prvCopyDataToQueue+0x92>
  92:	2c 81       	ldd	r18, Y+4	; 0x04
  94:	3d 81       	ldd	r19, Y+5	; 0x05
  96:	82 0f       	add	r24, r18
  98:	93 1f       	adc	r25, r19
  9a:	9f 83       	std	Y+7, r25	; 0x07
  9c:	8e 83       	std	Y+6, r24	; 0x06
  9e:	02 30       	cpi	r16, 0x02	; 2
  a0:	01 f4       	brne	.+0      	; 0xa2 <prvCopyDataToQueue+0xa2>
  a2:	11 23       	and	r17, r17
  a4:	01 f0       	breq	.+0      	; 0xa6 <prvCopyDataToQueue+0xa6>
  a6:	11 50       	subi	r17, 0x01	; 1
  a8:	00 c0       	rjmp	.+0      	; 0xaa <__SREG__+0x6b>

Disassembly of section .text.hot.prvCopyDataFromQueue:

00000000 <prvCopyDataFromQueue>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	fc 01       	movw	r30, r24
   2:	cb 01       	movw	r24, r22
   4:	44 8d       	ldd	r20, Z+28	; 0x1c
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	44 23       	and	r20, r20
   8:	01 f0       	breq	.+0      	; 0xa <prvCopyDataFromQueue+0xa>
   a:	50 e0       	ldi	r21, 0x00	; 0
   c:	26 81       	ldd	r18, Z+6	; 0x06
   e:	37 81       	ldd	r19, Z+7	; 0x07
  10:	24 0f       	add	r18, r20
  12:	35 1f       	adc	r19, r21
  14:	37 83       	std	Z+7, r19	; 0x07
  16:	26 83       	std	Z+6, r18	; 0x06
  18:	64 81       	ldd	r22, Z+4	; 0x04
  1a:	75 81       	ldd	r23, Z+5	; 0x05
  1c:	26 17       	cp	r18, r22
  1e:	37 07       	cpc	r19, r23

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  20:	00 f0       	brcs	.+0      	; 0x22 <prvCopyDataFromQueue+0x22>
  22:	20 81       	ld	r18, Z
  24:	31 81       	ldd	r19, Z+1	; 0x01
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  26:	37 83       	std	Z+7, r19	; 0x07
  28:	26 83       	std	Z+6, r18	; 0x06
  2a:	66 81       	ldd	r22, Z+6	; 0x06
  2c:	77 81       	ldd	r23, Z+7	; 0x07
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  2e:	0c 94 00 00 	jmp	0	; 0x0 <prvCopyDataFromQueue>

        traceRETURN_vQueueWaitForMessageRestricted();
    }
  32:	08 95       	ret

Disassembly of section .text.hot.prvUnlockQueue:

00000000 <prvUnlockQueue>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	1f 93       	push	r17
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	cf 93       	push	r28
   8:	df 93       	push	r29
   a:	ec 01       	movw	r28, r24
   c:	0f b6       	in	r0, 0x3f	; 63
   e:	f8 94       	cli
  10:	0f 92       	push	r0
  12:	1e 8d       	ldd	r17, Y+30	; 0x1e
  14:	7c 01       	movw	r14, r24
  16:	81 e1       	ldi	r24, 0x11	; 17
  18:	e8 0e       	add	r14, r24
  1a:	f1 1c       	adc	r15, r1
  1c:	11 16       	cp	r1, r17
  1e:	04 f0       	brlt	.+0      	; 0x20 <prvUnlockQueue+0x20>

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  20:	8f ef       	ldi	r24, 0xFF	; 255
  22:	8e 8f       	std	Y+30, r24	; 0x1e
  24:	0f 90       	pop	r0
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  26:	0f be       	out	0x3f, r0	; 63
  28:	0f b6       	in	r0, 0x3f	; 63
  2a:	f8 94       	cli
  2c:	0f 92       	push	r0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  2e:	1d 8d       	ldd	r17, Y+29	; 0x1d

        traceRETURN_vQueueWaitForMessageRestricted();
    }
  30:	7e 01       	movw	r14, r28
  32:	88 e0       	ldi	r24, 0x08	; 8
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  34:	e8 0e       	add	r14, r24
  36:	f1 1c       	adc	r15, r1
  38:	11 16       	cp	r1, r17
  3a:	04 f0       	brlt	.+0      	; 0x3c <prvUnlockQueue+0x3c>
  3c:	8f ef       	ldi	r24, 0xFF	; 255
  3e:	8d 8f       	std	Y+29, r24	; 0x1d
  40:	0f 90       	pop	r0
  42:	0f be       	out	0x3f, r0	; 63
  44:	df 91       	pop	r29
  46:	cf 91       	pop	r28
  48:	1f 91       	pop	r17
  4a:	ff 90       	pop	r15
  4c:	ef 90       	pop	r14
  4e:	08 95       	ret
  50:	89 89       	ldd	r24, Y+17	; 0x11
  52:	88 23       	and	r24, r24
  54:	01 f0       	breq	.+0      	; 0x56 <prvUnlockQueue+0x56>
  56:	c7 01       	movw	r24, r14
  58:	0e 94 00 00 	call	0	; 0x0 <prvUnlockQueue>
  5c:	81 11       	cpse	r24, r1
  5e:	0e 94 00 00 	call	0	; 0x0 <prvUnlockQueue>
  62:	11 50       	subi	r17, 0x01	; 1
  64:	00 c0       	rjmp	.+0      	; 0x66 <prvUnlockQueue+0x66>
  66:	88 85       	ldd	r24, Y+8	; 0x08
  68:	88 23       	and	r24, r24
  6a:	01 f0       	breq	.+0      	; 0x6c <prvUnlockQueue+0x6c>
  6c:	c7 01       	movw	r24, r14
  6e:	0e 94 00 00 	call	0	; 0x0 <prvUnlockQueue>
  72:	81 11       	cpse	r24, r1
  74:	0e 94 00 00 	call	0	; 0x0 <prvUnlockQueue>
  78:	11 50       	subi	r17, 0x01	; 1
  7a:	00 c0       	rjmp	.+0      	; 0x7c <__SREG__+0x3d>

Disassembly of section .text.hot.xQueueGenericReset:

00000000 <xQueueGenericReset>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	00 97       	sbiw	r24, 0x00	; 0
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	01 f4       	brne	.+0      	; 0x8 <xQueueGenericReset+0x8>
   8:	00 c0       	rjmp	.+0      	; 0xa <xQueueGenericReset+0xa>
   a:	fc 01       	movw	r30, r24
   c:	23 8d       	ldd	r18, Z+27	; 0x1b
   e:	22 23       	and	r18, r18
  10:	01 f4       	brne	.+0      	; 0x12 <xQueueGenericReset+0x12>
  12:	00 c0       	rjmp	.+0      	; 0x14 <xQueueGenericReset+0x14>
  14:	ec 01       	movw	r28, r24
  16:	0f b6       	in	r0, 0x3f	; 63
  18:	f8 94       	cli
  1a:	0f 92       	push	r0
  1c:	80 81       	ld	r24, Z
  1e:	91 81       	ldd	r25, Z+1	; 0x01

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  20:	23 8d       	ldd	r18, Z+27	; 0x1b
  22:	44 8d       	ldd	r20, Z+28	; 0x1c
  24:	fc 01       	movw	r30, r24
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  26:	24 9f       	mul	r18, r20
  28:	e0 0d       	add	r30, r0
  2a:	f1 1d       	adc	r31, r1
  2c:	11 24       	eor	r1, r1
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  2e:	fd 83       	std	Y+5, r31	; 0x05

        traceRETURN_vQueueWaitForMessageRestricted();
    }
  30:	ec 83       	std	Y+4, r30	; 0x04
  32:	1a 8e       	std	Y+26, r1	; 0x1a
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  34:	9b 83       	std	Y+3, r25	; 0x03
  36:	8a 83       	std	Y+2, r24	; 0x02
  38:	21 50       	subi	r18, 0x01	; 1
  3a:	33 0b       	sbc	r19, r19
  3c:	42 9f       	mul	r20, r18
  3e:	f0 01       	movw	r30, r0
  40:	43 9f       	mul	r20, r19
  42:	f0 0d       	add	r31, r0
  44:	11 24       	eor	r1, r1
  46:	8e 0f       	add	r24, r30
  48:	9f 1f       	adc	r25, r31
  4a:	9f 83       	std	Y+7, r25	; 0x07
  4c:	8e 83       	std	Y+6, r24	; 0x06
  4e:	8f ef       	ldi	r24, 0xFF	; 255
  50:	8d 8f       	std	Y+29, r24	; 0x1d
  52:	8e 8f       	std	Y+30, r24	; 0x1e
  54:	61 11       	cpse	r22, r1
  56:	00 c0       	rjmp	.+0      	; 0x58 <xQueueGenericReset+0x58>
  58:	88 85       	ldd	r24, Y+8	; 0x08
  5a:	88 23       	and	r24, r24
  5c:	01 f0       	breq	.+0      	; 0x5e <xQueueGenericReset+0x5e>
  5e:	ce 01       	movw	r24, r28
  60:	08 96       	adiw	r24, 0x08	; 8
  62:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReset>
  66:	81 11       	cpse	r24, r1
  68:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReset>
  6c:	0f 90       	pop	r0
  6e:	0f be       	out	0x3f, r0	; 63
  70:	81 e0       	ldi	r24, 0x01	; 1
  72:	df 91       	pop	r29
  74:	cf 91       	pop	r28
  76:	08 95       	ret
  78:	ce 01       	movw	r24, r28
  7a:	08 96       	adiw	r24, 0x08	; 8
  7c:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReset>
  80:	ce 01       	movw	r24, r28
  82:	41 96       	adiw	r24, 0x11	; 17
  84:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericReset>
  88:	00 c0       	rjmp	.+0      	; 0x8a <xQueueGenericReset+0x8a>
  8a:	80 e0       	ldi	r24, 0x00	; 0
  8c:	00 c0       	rjmp	.+0      	; 0x8e <__SREG__+0x4f>

Disassembly of section .text.hot.xQueueGenericCreate:

00000000 <xQueueGenericCreate>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	df 93       	push	r29
   8:	81 11       	cpse	r24, r1
   a:	00 c0       	rjmp	.+0      	; 0xc <xQueueGenericCreate+0xc>
   c:	d0 e0       	ldi	r29, 0x00	; 0
   e:	c0 e0       	ldi	r28, 0x00	; 0
  10:	ce 01       	movw	r24, r28
  12:	df 91       	pop	r29
  14:	cf 91       	pop	r28
  16:	1f 91       	pop	r17
  18:	0f 91       	pop	r16
  1a:	08 95       	ret
  1c:	16 2f       	mov	r17, r22
  1e:	08 2f       	mov	r16, r24

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  20:	68 9f       	mul	r22, r24
  22:	c0 01       	movw	r24, r0
  24:	11 24       	eor	r1, r1
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  26:	4f 96       	adiw	r24, 0x1f	; 31
  28:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericCreate>
  2c:	ec 01       	movw	r28, r24
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  2e:	00 97       	sbiw	r24, 0x00	; 0

        traceRETURN_vQueueWaitForMessageRestricted();
    }
  30:	01 f0       	breq	.+0      	; 0x32 <xQueueGenericCreate+0x32>
  32:	11 11       	cpse	r17, r1
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  34:	00 c0       	rjmp	.+0      	; 0x36 <xQueueGenericCreate+0x36>
  36:	99 83       	std	Y+1, r25	; 0x01
  38:	88 83       	st	Y, r24
  3a:	0b 8f       	std	Y+27, r16	; 0x1b
  3c:	1c 8f       	std	Y+28, r17	; 0x1c
  3e:	61 e0       	ldi	r22, 0x01	; 1
  40:	ce 01       	movw	r24, r28
  42:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericCreate>
  46:	00 c0       	rjmp	.+0      	; 0x48 <xQueueGenericCreate+0x48>
  48:	4f 96       	adiw	r24, 0x1f	; 31
  4a:	99 83       	std	Y+1, r25	; 0x01
  4c:	88 83       	st	Y, r24
  4e:	00 c0       	rjmp	.+0      	; 0x50 <__SREG__+0x11>

Disassembly of section .text.hot.xQueueCreateCountingSemaphore:

00000000 <xQueueCreateCountingSemaphore>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	cf 93       	push	r28
   2:	88 23       	and	r24, r24
   4:	01 f0       	breq	.+0      	; 0x6 <xQueueCreateCountingSemaphore+0x6>
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	86 17       	cp	r24, r22
   8:	00 f0       	brcs	.+0      	; 0xa <xQueueCreateCountingSemaphore+0xa>
   a:	c6 2f       	mov	r28, r22
   c:	42 e0       	ldi	r20, 0x02	; 2
   e:	60 e0       	ldi	r22, 0x00	; 0
  10:	0e 94 00 00 	call	0	; 0x0 <xQueueCreateCountingSemaphore>
  14:	00 97       	sbiw	r24, 0x00	; 0
  16:	01 f0       	breq	.+0      	; 0x18 <xQueueCreateCountingSemaphore+0x18>
  18:	fc 01       	movw	r30, r24
  1a:	c2 8f       	std	Z+26, r28	; 0x1a
  1c:	cf 91       	pop	r28
  1e:	08 95       	ret

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  20:	90 e0       	ldi	r25, 0x00	; 0
  22:	80 e0       	ldi	r24, 0x00	; 0
  24:	00 c0       	rjmp	.+0      	; 0x26 <__zero_reg__+0x25>

Disassembly of section .text.hot.xQueueGenericSend:

00000000 <xQueueGenericSend>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	af 92       	push	r10
   2:	bf 92       	push	r11
   4:	cf 92       	push	r12
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	df 92       	push	r13
   8:	ff 92       	push	r15
   a:	0f 93       	push	r16
   c:	1f 93       	push	r17
   e:	cf 93       	push	r28
  10:	df 93       	push	r29
  12:	00 d0       	rcall	.+0      	; 0x14 <xQueueGenericSend+0x14>
  14:	00 d0       	rcall	.+0      	; 0x16 <xQueueGenericSend+0x16>
  16:	1f 92       	push	r1
  18:	cd b7       	in	r28, 0x3d	; 61
  1a:	de b7       	in	r29, 0x3e	; 62
  1c:	8c 01       	movw	r16, r24
  1e:	6b 01       	movw	r12, r22

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  20:	5d 83       	std	Y+5, r21	; 0x05
  22:	4c 83       	std	Y+4, r20	; 0x04
  24:	f2 2e       	mov	r15, r18
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  26:	80 e0       	ldi	r24, 0x00	; 0
  28:	58 01       	movw	r10, r16
  2a:	98 e0       	ldi	r25, 0x08	; 8
  2c:	a9 0e       	add	r10, r25
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  2e:	b1 1c       	adc	r11, r1

        traceRETURN_vQueueWaitForMessageRestricted();
    }
  30:	0f b6       	in	r0, 0x3f	; 63
  32:	f8 94       	cli
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  34:	0f 92       	push	r0
  36:	f8 01       	movw	r30, r16
  38:	22 8d       	ldd	r18, Z+26	; 0x1a
  3a:	93 8d       	ldd	r25, Z+27	; 0x1b
  3c:	29 17       	cp	r18, r25
  3e:	00 f0       	brcs	.+0      	; 0x40 <xQueueGenericSend+0x40>
  40:	f2 e0       	ldi	r31, 0x02	; 2
  42:	ff 12       	cpse	r15, r31
  44:	00 c0       	rjmp	.+0      	; 0x46 <xQueueGenericSend+0x46>
  46:	4f 2d       	mov	r20, r15
  48:	b6 01       	movw	r22, r12
  4a:	c8 01       	movw	r24, r16
  4c:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
  50:	f8 01       	movw	r30, r16
  52:	91 89       	ldd	r25, Z+17	; 0x11
  54:	99 23       	and	r25, r25
  56:	01 f0       	breq	.+0      	; 0x58 <xQueueGenericSend+0x58>
  58:	c8 01       	movw	r24, r16
  5a:	41 96       	adiw	r24, 0x11	; 17
  5c:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
  60:	81 11       	cpse	r24, r1
  62:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
  66:	0f 90       	pop	r0
  68:	0f be       	out	0x3f, r0	; 63
  6a:	81 e0       	ldi	r24, 0x01	; 1
  6c:	0f 90       	pop	r0
  6e:	0f 90       	pop	r0
  70:	0f 90       	pop	r0
  72:	0f 90       	pop	r0
  74:	0f 90       	pop	r0
  76:	df 91       	pop	r29
  78:	cf 91       	pop	r28
  7a:	1f 91       	pop	r17
  7c:	0f 91       	pop	r16
  7e:	ff 90       	pop	r15
  80:	df 90       	pop	r13
  82:	cf 90       	pop	r12
  84:	bf 90       	pop	r11
  86:	af 90       	pop	r10
  88:	08 95       	ret
  8a:	2c 81       	ldd	r18, Y+4	; 0x04
  8c:	3d 81       	ldd	r19, Y+5	; 0x05
  8e:	23 2b       	or	r18, r19
  90:	01 f4       	brne	.+0      	; 0x92 <xQueueGenericSend+0x92>
  92:	0f 90       	pop	r0
  94:	0f be       	out	0x3f, r0	; 63
  96:	80 e0       	ldi	r24, 0x00	; 0
  98:	00 c0       	rjmp	.+0      	; 0x9a <xQueueGenericSend+0x9a>
  9a:	81 11       	cpse	r24, r1
  9c:	00 c0       	rjmp	.+0      	; 0x9e <xQueueGenericSend+0x9e>
  9e:	ce 01       	movw	r24, r28
  a0:	01 96       	adiw	r24, 0x01	; 1
  a2:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
  a6:	0f 90       	pop	r0
  a8:	0f be       	out	0x3f, r0	; 63
  aa:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
  ae:	0f b6       	in	r0, 0x3f	; 63
  b0:	f8 94       	cli
  b2:	0f 92       	push	r0
  b4:	f8 01       	movw	r30, r16
  b6:	85 8d       	ldd	r24, Z+29	; 0x1d
  b8:	8f 3f       	cpi	r24, 0xFF	; 255
  ba:	01 f4       	brne	.+0      	; 0xbc <xQueueGenericSend+0xbc>
  bc:	15 8e       	std	Z+29, r1	; 0x1d
  be:	f8 01       	movw	r30, r16
  c0:	86 8d       	ldd	r24, Z+30	; 0x1e
  c2:	8f 3f       	cpi	r24, 0xFF	; 255
  c4:	01 f4       	brne	.+0      	; 0xc6 <xQueueGenericSend+0xc6>
  c6:	16 8e       	std	Z+30, r1	; 0x1e
  c8:	0f 90       	pop	r0
  ca:	0f be       	out	0x3f, r0	; 63
  cc:	be 01       	movw	r22, r28
  ce:	6c 5f       	subi	r22, 0xFC	; 252
  d0:	7f 4f       	sbci	r23, 0xFF	; 255
  d2:	ce 01       	movw	r24, r28
  d4:	01 96       	adiw	r24, 0x01	; 1
  d6:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
  da:	81 11       	cpse	r24, r1
  dc:	00 c0       	rjmp	.+0      	; 0xde <xQueueGenericSend+0xde>
  de:	0f b6       	in	r0, 0x3f	; 63
  e0:	f8 94       	cli
  e2:	0f 92       	push	r0
  e4:	f8 01       	movw	r30, r16
  e6:	92 8d       	ldd	r25, Z+26	; 0x1a
  e8:	83 8d       	ldd	r24, Z+27	; 0x1b
  ea:	0f 90       	pop	r0
  ec:	0f be       	out	0x3f, r0	; 63
  ee:	98 13       	cpse	r25, r24
  f0:	00 c0       	rjmp	.+0      	; 0xf2 <xQueueGenericSend+0xf2>
  f2:	6c 81       	ldd	r22, Y+4	; 0x04
  f4:	7d 81       	ldd	r23, Y+5	; 0x05
  f6:	c5 01       	movw	r24, r10
  f8:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
  fc:	c8 01       	movw	r24, r16
  fe:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
 102:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
 106:	81 11       	cpse	r24, r1
 108:	00 c0       	rjmp	.+0      	; 0x10a <xQueueGenericSend+0x10a>
 10a:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
 10e:	81 e0       	ldi	r24, 0x01	; 1
 110:	00 c0       	rjmp	.+0      	; 0x112 <xQueueGenericSend+0x112>
 112:	c8 01       	movw	r24, r16
 114:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
 118:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
 11c:	00 c0       	rjmp	.+0      	; 0x11e <xQueueGenericSend+0x11e>
 11e:	c8 01       	movw	r24, r16
 120:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
 124:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSend>
 128:	00 c0       	rjmp	.+0      	; 0x12a <__SREG__+0xeb>

Disassembly of section .text.hot.xQueueCreateMutex:

00000000 <xQueueCreateMutex>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	48 2f       	mov	r20, r24
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	60 e0       	ldi	r22, 0x00	; 0
   8:	81 e0       	ldi	r24, 0x01	; 1
   a:	0e 94 00 00 	call	0	; 0x0 <xQueueCreateMutex>
   e:	ec 01       	movw	r28, r24
  10:	00 97       	sbiw	r24, 0x00	; 0
  12:	01 f0       	breq	.+0      	; 0x14 <xQueueCreateMutex+0x14>
  14:	1d 82       	std	Y+5, r1	; 0x05
  16:	1c 82       	std	Y+4, r1	; 0x04
  18:	19 82       	std	Y+1, r1	; 0x01
  1a:	18 82       	st	Y, r1
  1c:	1e 82       	std	Y+6, r1	; 0x06
  1e:	20 e0       	ldi	r18, 0x00	; 0

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  20:	50 e0       	ldi	r21, 0x00	; 0
  22:	40 e0       	ldi	r20, 0x00	; 0
  24:	70 e0       	ldi	r23, 0x00	; 0
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  26:	60 e0       	ldi	r22, 0x00	; 0
  28:	0e 94 00 00 	call	0	; 0x0 <xQueueCreateMutex>
  2c:	ce 01       	movw	r24, r28
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  2e:	df 91       	pop	r29

        traceRETURN_vQueueWaitForMessageRestricted();
    }
  30:	cf 91       	pop	r28
  32:	08 95       	ret

Disassembly of section .text.hot.xQueueGiveMutexRecursive:

00000000 <xQueueGiveMutexRecursive>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	df 93       	push	r29
   8:	ec 01       	movw	r28, r24
   a:	0c 81       	ldd	r16, Y+4	; 0x04
   c:	1d 81       	ldd	r17, Y+5	; 0x05
   e:	0e 94 00 00 	call	0	; 0x0 <xQueueGiveMutexRecursive>
  12:	08 17       	cp	r16, r24
  14:	19 07       	cpc	r17, r25
  16:	01 f4       	brne	.+0      	; 0x18 <xQueueGiveMutexRecursive+0x18>
  18:	8e 81       	ldd	r24, Y+6	; 0x06
  1a:	81 50       	subi	r24, 0x01	; 1
  1c:	8e 83       	std	Y+6, r24	; 0x06
  1e:	81 11       	cpse	r24, r1

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  20:	00 c0       	rjmp	.+0      	; 0x22 <xQueueGiveMutexRecursive+0x22>
  22:	20 e0       	ldi	r18, 0x00	; 0
  24:	50 e0       	ldi	r21, 0x00	; 0
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  26:	40 e0       	ldi	r20, 0x00	; 0
  28:	70 e0       	ldi	r23, 0x00	; 0
  2a:	60 e0       	ldi	r22, 0x00	; 0
  2c:	ce 01       	movw	r24, r28
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  2e:	0e 94 00 00 	call	0	; 0x0 <xQueueGiveMutexRecursive>

        traceRETURN_vQueueWaitForMessageRestricted();
    }
  32:	81 e0       	ldi	r24, 0x01	; 1
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  34:	00 c0       	rjmp	.+0      	; 0x36 <xQueueGiveMutexRecursive+0x36>
  36:	80 e0       	ldi	r24, 0x00	; 0
  38:	df 91       	pop	r29
  3a:	cf 91       	pop	r28
  3c:	1f 91       	pop	r17
  3e:	0f 91       	pop	r16
  40:	08 95       	ret

Disassembly of section .text.hot.xQueueGenericSendFromISR:

00000000 <xQueueGenericSendFromISR>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	1f 93       	push	r17
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	cf 93       	push	r28
   8:	df 93       	push	r29
   a:	ec 01       	movw	r28, r24
   c:	9a 8d       	ldd	r25, Y+26	; 0x1a
   e:	8b 8d       	ldd	r24, Y+27	; 0x1b
  10:	98 17       	cp	r25, r24
  12:	00 f0       	brcs	.+0      	; 0x14 <xQueueGenericSendFromISR+0x14>
  14:	80 e0       	ldi	r24, 0x00	; 0
  16:	22 30       	cpi	r18, 0x02	; 2
  18:	01 f4       	brne	.+0      	; 0x1a <xQueueGenericSendFromISR+0x1a>
  1a:	7a 01       	movw	r14, r20
  1c:	1e 8d       	ldd	r17, Y+30	; 0x1e
  1e:	8a 8d       	ldd	r24, Y+26	; 0x1a

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  20:	42 2f       	mov	r20, r18
  22:	ce 01       	movw	r24, r28
  24:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSendFromISR>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  28:	1f 3f       	cpi	r17, 0xFF	; 255
  2a:	01 f4       	brne	.+0      	; 0x2c <xQueueGenericSendFromISR+0x2c>
  2c:	89 89       	ldd	r24, Y+17	; 0x11
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  2e:	81 11       	cpse	r24, r1

        traceRETURN_vQueueWaitForMessageRestricted();
    }
  30:	00 c0       	rjmp	.+0      	; 0x32 <xQueueGenericSendFromISR+0x32>
  32:	81 e0       	ldi	r24, 0x01	; 1
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  34:	00 c0       	rjmp	.+0      	; 0x36 <xQueueGenericSendFromISR+0x36>
  36:	ce 01       	movw	r24, r28
  38:	41 96       	adiw	r24, 0x11	; 17
  3a:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSendFromISR>
  3e:	88 23       	and	r24, r24
  40:	01 f0       	breq	.+0      	; 0x42 <xQueueGenericSendFromISR+0x42>
  42:	e1 14       	cp	r14, r1
  44:	f1 04       	cpc	r15, r1
  46:	01 f0       	breq	.+0      	; 0x48 <xQueueGenericSendFromISR+0x48>
  48:	81 e0       	ldi	r24, 0x01	; 1
  4a:	f7 01       	movw	r30, r14
  4c:	80 83       	st	Z, r24
  4e:	df 91       	pop	r29
  50:	cf 91       	pop	r28
  52:	1f 91       	pop	r17
  54:	ff 90       	pop	r15
  56:	ef 90       	pop	r14
  58:	08 95       	ret
  5a:	0e 94 00 00 	call	0	; 0x0 <xQueueGenericSendFromISR>
  5e:	18 17       	cp	r17, r24
  60:	00 f4       	brcc	.+0      	; 0x62 <xQueueGenericSendFromISR+0x62>
  62:	1f 5f       	subi	r17, 0xFF	; 255
  64:	1e 8f       	std	Y+30, r17	; 0x1e
  66:	00 c0       	rjmp	.+0      	; 0x68 <__SREG__+0x29>

Disassembly of section .text.hot.xQueueGiveFromISR:

00000000 <xQueueGiveFromISR>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	1f 93       	push	r17
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	cf 93       	push	r28
   8:	df 93       	push	r29
   a:	ec 01       	movw	r28, r24
   c:	8a 8d       	ldd	r24, Y+26	; 0x1a
   e:	9b 8d       	ldd	r25, Y+27	; 0x1b
  10:	89 17       	cp	r24, r25
  12:	00 f4       	brcc	.+0      	; 0x14 <xQueueGiveFromISR+0x14>
  14:	7b 01       	movw	r14, r22
  16:	1e 8d       	ldd	r17, Y+30	; 0x1e
  18:	8f 5f       	subi	r24, 0xFF	; 255
  1a:	8a 8f       	std	Y+26, r24	; 0x1a
  1c:	1f 3f       	cpi	r17, 0xFF	; 255
  1e:	01 f4       	brne	.+0      	; 0x20 <xQueueGiveFromISR+0x20>

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  20:	89 89       	ldd	r24, Y+17	; 0x11
  22:	81 11       	cpse	r24, r1
  24:	00 c0       	rjmp	.+0      	; 0x26 <xQueueGiveFromISR+0x26>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  26:	81 e0       	ldi	r24, 0x01	; 1
  28:	00 c0       	rjmp	.+0      	; 0x2a <xQueueGiveFromISR+0x2a>
  2a:	ce 01       	movw	r24, r28
  2c:	41 96       	adiw	r24, 0x11	; 17
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  2e:	0e 94 00 00 	call	0	; 0x0 <xQueueGiveFromISR>

        traceRETURN_vQueueWaitForMessageRestricted();
    }
  32:	88 23       	and	r24, r24
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  34:	01 f0       	breq	.+0      	; 0x36 <xQueueGiveFromISR+0x36>
  36:	e1 14       	cp	r14, r1
  38:	f1 04       	cpc	r15, r1
  3a:	01 f0       	breq	.+0      	; 0x3c <xQueueGiveFromISR+0x3c>
  3c:	81 e0       	ldi	r24, 0x01	; 1
  3e:	f7 01       	movw	r30, r14
  40:	80 83       	st	Z, r24
  42:	df 91       	pop	r29
  44:	cf 91       	pop	r28
  46:	1f 91       	pop	r17
  48:	ff 90       	pop	r15
  4a:	ef 90       	pop	r14
  4c:	08 95       	ret
  4e:	0e 94 00 00 	call	0	; 0x0 <xQueueGiveFromISR>
  52:	18 17       	cp	r17, r24
  54:	00 f4       	brcc	.+0      	; 0x56 <xQueueGiveFromISR+0x56>
  56:	1f 5f       	subi	r17, 0xFF	; 255
  58:	1e 8f       	std	Y+30, r17	; 0x1e
  5a:	00 c0       	rjmp	.+0      	; 0x5c <xQueueGiveFromISR+0x5c>
  5c:	80 e0       	ldi	r24, 0x00	; 0
  5e:	00 c0       	rjmp	.+0      	; 0x60 <__SREG__+0x21>

Disassembly of section .text.hot.xQueueReceive:

00000000 <xQueueReceive>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	af 92       	push	r10
   2:	bf 92       	push	r11
   4:	cf 92       	push	r12
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	df 92       	push	r13
   8:	ff 92       	push	r15
   a:	0f 93       	push	r16
   c:	1f 93       	push	r17
   e:	cf 93       	push	r28
  10:	df 93       	push	r29
  12:	00 d0       	rcall	.+0      	; 0x14 <xQueueReceive+0x14>
  14:	00 d0       	rcall	.+0      	; 0x16 <xQueueReceive+0x16>
  16:	1f 92       	push	r1
  18:	cd b7       	in	r28, 0x3d	; 61
  1a:	de b7       	in	r29, 0x3e	; 62
  1c:	8c 01       	movw	r16, r24
  1e:	6b 01       	movw	r12, r22

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  20:	5d 83       	std	Y+5, r21	; 0x05
  22:	4c 83       	std	Y+4, r20	; 0x04
  24:	80 e0       	ldi	r24, 0x00	; 0
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  26:	58 01       	movw	r10, r16
  28:	91 e1       	ldi	r25, 0x11	; 17
  2a:	a9 0e       	add	r10, r25
  2c:	b1 1c       	adc	r11, r1
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  2e:	0f b6       	in	r0, 0x3f	; 63

        traceRETURN_vQueueWaitForMessageRestricted();
    }
  30:	f8 94       	cli
  32:	0f 92       	push	r0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  34:	f8 01       	movw	r30, r16
  36:	f2 8c       	ldd	r15, Z+26	; 0x1a
  38:	ff 20       	and	r15, r15
  3a:	01 f0       	breq	.+0      	; 0x3c <xQueueReceive+0x3c>
  3c:	b6 01       	movw	r22, r12
  3e:	c8 01       	movw	r24, r16
  40:	0e 94 00 00 	call	0	; 0x0 <xQueueReceive>
  44:	fa 94       	dec	r15
  46:	f8 01       	movw	r30, r16
  48:	f2 8e       	std	Z+26, r15	; 0x1a
  4a:	80 85       	ldd	r24, Z+8	; 0x08
  4c:	88 23       	and	r24, r24
  4e:	01 f0       	breq	.+0      	; 0x50 <xQueueReceive+0x50>
  50:	c8 01       	movw	r24, r16
  52:	08 96       	adiw	r24, 0x08	; 8
  54:	0e 94 00 00 	call	0	; 0x0 <xQueueReceive>
  58:	81 11       	cpse	r24, r1
  5a:	0e 94 00 00 	call	0	; 0x0 <xQueueReceive>
  5e:	0f 90       	pop	r0
  60:	0f be       	out	0x3f, r0	; 63
  62:	81 e0       	ldi	r24, 0x01	; 1
  64:	0f 90       	pop	r0
  66:	0f 90       	pop	r0
  68:	0f 90       	pop	r0
  6a:	0f 90       	pop	r0
  6c:	0f 90       	pop	r0
  6e:	df 91       	pop	r29
  70:	cf 91       	pop	r28
  72:	1f 91       	pop	r17
  74:	0f 91       	pop	r16
  76:	ff 90       	pop	r15
  78:	df 90       	pop	r13
  7a:	cf 90       	pop	r12
  7c:	bf 90       	pop	r11
  7e:	af 90       	pop	r10
  80:	08 95       	ret
  82:	2c 81       	ldd	r18, Y+4	; 0x04
  84:	3d 81       	ldd	r19, Y+5	; 0x05
  86:	23 2b       	or	r18, r19
  88:	01 f4       	brne	.+0      	; 0x8a <xQueueReceive+0x8a>
  8a:	0f 90       	pop	r0
  8c:	0f be       	out	0x3f, r0	; 63
  8e:	80 e0       	ldi	r24, 0x00	; 0
  90:	00 c0       	rjmp	.+0      	; 0x92 <xQueueReceive+0x92>
  92:	81 11       	cpse	r24, r1
  94:	00 c0       	rjmp	.+0      	; 0x96 <xQueueReceive+0x96>
  96:	ce 01       	movw	r24, r28
  98:	01 96       	adiw	r24, 0x01	; 1
  9a:	0e 94 00 00 	call	0	; 0x0 <xQueueReceive>
  9e:	0f 90       	pop	r0
  a0:	0f be       	out	0x3f, r0	; 63
  a2:	0e 94 00 00 	call	0	; 0x0 <xQueueReceive>
  a6:	0f b6       	in	r0, 0x3f	; 63
  a8:	f8 94       	cli
  aa:	0f 92       	push	r0
  ac:	f8 01       	movw	r30, r16
  ae:	85 8d       	ldd	r24, Z+29	; 0x1d
  b0:	8f 3f       	cpi	r24, 0xFF	; 255
  b2:	01 f4       	brne	.+0      	; 0xb4 <xQueueReceive+0xb4>
  b4:	15 8e       	std	Z+29, r1	; 0x1d
  b6:	f8 01       	movw	r30, r16
  b8:	86 8d       	ldd	r24, Z+30	; 0x1e
  ba:	8f 3f       	cpi	r24, 0xFF	; 255
  bc:	01 f4       	brne	.+0      	; 0xbe <xQueueReceive+0xbe>
  be:	16 8e       	std	Z+30, r1	; 0x1e
  c0:	0f 90       	pop	r0
  c2:	0f be       	out	0x3f, r0	; 63
  c4:	be 01       	movw	r22, r28
  c6:	6c 5f       	subi	r22, 0xFC	; 252
  c8:	7f 4f       	sbci	r23, 0xFF	; 255
  ca:	ce 01       	movw	r24, r28
  cc:	01 96       	adiw	r24, 0x01	; 1
  ce:	0e 94 00 00 	call	0	; 0x0 <xQueueReceive>
  d2:	81 11       	cpse	r24, r1
  d4:	00 c0       	rjmp	.+0      	; 0xd6 <xQueueReceive+0xd6>
  d6:	c8 01       	movw	r24, r16
  d8:	0e 94 00 00 	call	0	; 0x0 <xQueueReceive>
  dc:	88 23       	and	r24, r24
  de:	01 f0       	breq	.+0      	; 0xe0 <xQueueReceive+0xe0>
  e0:	6c 81       	ldd	r22, Y+4	; 0x04
  e2:	7d 81       	ldd	r23, Y+5	; 0x05
  e4:	c5 01       	movw	r24, r10
  e6:	0e 94 00 00 	call	0	; 0x0 <xQueueReceive>
  ea:	c8 01       	movw	r24, r16
  ec:	0e 94 00 00 	call	0	; 0x0 <xQueueReceive>
  f0:	0e 94 00 00 	call	0	; 0x0 <xQueueReceive>
  f4:	81 11       	cpse	r24, r1
  f6:	00 c0       	rjmp	.+0      	; 0xf8 <xQueueReceive+0xf8>
  f8:	0e 94 00 00 	call	0	; 0x0 <xQueueReceive>
  fc:	81 e0       	ldi	r24, 0x01	; 1
  fe:	00 c0       	rjmp	.+0      	; 0x100 <xQueueReceive+0x100>
 100:	c8 01       	movw	r24, r16
 102:	0e 94 00 00 	call	0	; 0x0 <xQueueReceive>
 106:	0e 94 00 00 	call	0	; 0x0 <xQueueReceive>
 10a:	00 c0       	rjmp	.+0      	; 0x10c <xQueueReceive+0x10c>
 10c:	c8 01       	movw	r24, r16
 10e:	0e 94 00 00 	call	0	; 0x0 <xQueueReceive>
 112:	0e 94 00 00 	call	0	; 0x0 <xQueueReceive>
 116:	c8 01       	movw	r24, r16
 118:	0e 94 00 00 	call	0	; 0x0 <xQueueReceive>
 11c:	88 23       	and	r24, r24
 11e:	01 f0       	breq	.+0      	; 0x120 <xQueueReceive+0x120>
 120:	00 c0       	rjmp	.+0      	; 0x122 <__SREG__+0xe3>

Disassembly of section .text.hot.xQueueSemaphoreTake:

00000000 <xQueueSemaphoreTake>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ff 92       	push	r15
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	0f 93       	push	r16
   8:	1f 93       	push	r17
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	00 d0       	rcall	.+0      	; 0x10 <xQueueSemaphoreTake+0x10>
  10:	00 d0       	rcall	.+0      	; 0x12 <xQueueSemaphoreTake+0x12>
  12:	1f 92       	push	r1
  14:	cd b7       	in	r28, 0x3d	; 61
  16:	de b7       	in	r29, 0x3e	; 62
  18:	8c 01       	movw	r16, r24
  1a:	7d 83       	std	Y+5, r23	; 0x05
  1c:	6c 83       	std	Y+4, r22	; 0x04
  1e:	f1 2c       	mov	r15, r1

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  20:	90 e0       	ldi	r25, 0x00	; 0
  22:	68 01       	movw	r12, r16
  24:	81 e1       	ldi	r24, 0x11	; 17
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  26:	c8 0e       	add	r12, r24
  28:	d1 1c       	adc	r13, r1
  2a:	0f b6       	in	r0, 0x3f	; 63
  2c:	f8 94       	cli
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  2e:	0f 92       	push	r0

        traceRETURN_vQueueWaitForMessageRestricted();
    }
  30:	d8 01       	movw	r26, r16
  32:	5a 96       	adiw	r26, 0x1a	; 26
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  34:	8c 91       	ld	r24, X
  36:	5a 97       	sbiw	r26, 0x1a	; 26
  38:	88 23       	and	r24, r24
  3a:	01 f0       	breq	.+0      	; 0x3c <xQueueSemaphoreTake+0x3c>
  3c:	81 50       	subi	r24, 0x01	; 1
  3e:	5a 96       	adiw	r26, 0x1a	; 26
  40:	8c 93       	st	X, r24
  42:	5a 97       	sbiw	r26, 0x1a	; 26
  44:	8d 91       	ld	r24, X+
  46:	9c 91       	ld	r25, X
  48:	89 2b       	or	r24, r25
  4a:	01 f4       	brne	.+0      	; 0x4c <xQueueSemaphoreTake+0x4c>
  4c:	0e 94 00 00 	call	0	; 0x0 <xQueueSemaphoreTake>
  50:	f8 01       	movw	r30, r16
  52:	95 83       	std	Z+5, r25	; 0x05
  54:	84 83       	std	Z+4, r24	; 0x04
  56:	d8 01       	movw	r26, r16
  58:	18 96       	adiw	r26, 0x08	; 8
  5a:	8c 91       	ld	r24, X
  5c:	88 23       	and	r24, r24
  5e:	01 f0       	breq	.+0      	; 0x60 <xQueueSemaphoreTake+0x60>
  60:	c8 01       	movw	r24, r16
  62:	08 96       	adiw	r24, 0x08	; 8
  64:	0e 94 00 00 	call	0	; 0x0 <xQueueSemaphoreTake>
  68:	81 11       	cpse	r24, r1
  6a:	0e 94 00 00 	call	0	; 0x0 <xQueueSemaphoreTake>
  6e:	0f 90       	pop	r0
  70:	0f be       	out	0x3f, r0	; 63
  72:	ff 24       	eor	r15, r15
  74:	f3 94       	inc	r15
  76:	8f 2d       	mov	r24, r15
  78:	0f 90       	pop	r0
  7a:	0f 90       	pop	r0
  7c:	0f 90       	pop	r0
  7e:	0f 90       	pop	r0
  80:	0f 90       	pop	r0
  82:	df 91       	pop	r29
  84:	cf 91       	pop	r28
  86:	1f 91       	pop	r17
  88:	0f 91       	pop	r16
  8a:	ff 90       	pop	r15
  8c:	df 90       	pop	r13
  8e:	cf 90       	pop	r12
  90:	08 95       	ret
  92:	2c 81       	ldd	r18, Y+4	; 0x04
  94:	3d 81       	ldd	r19, Y+5	; 0x05
  96:	23 2b       	or	r18, r19
  98:	01 f4       	brne	.+0      	; 0x9a <xQueueSemaphoreTake+0x9a>
  9a:	0f 90       	pop	r0
  9c:	0f be       	out	0x3f, r0	; 63
  9e:	f1 2c       	mov	r15, r1
  a0:	00 c0       	rjmp	.+0      	; 0xa2 <xQueueSemaphoreTake+0xa2>
  a2:	91 11       	cpse	r25, r1
  a4:	00 c0       	rjmp	.+0      	; 0xa6 <xQueueSemaphoreTake+0xa6>
  a6:	ce 01       	movw	r24, r28
  a8:	01 96       	adiw	r24, 0x01	; 1
  aa:	0e 94 00 00 	call	0	; 0x0 <xQueueSemaphoreTake>
  ae:	0f 90       	pop	r0
  b0:	0f be       	out	0x3f, r0	; 63
  b2:	0e 94 00 00 	call	0	; 0x0 <xQueueSemaphoreTake>
  b6:	0f b6       	in	r0, 0x3f	; 63
  b8:	f8 94       	cli
  ba:	0f 92       	push	r0
  bc:	f8 01       	movw	r30, r16
  be:	85 8d       	ldd	r24, Z+29	; 0x1d
  c0:	8f 3f       	cpi	r24, 0xFF	; 255
  c2:	01 f4       	brne	.+0      	; 0xc4 <xQueueSemaphoreTake+0xc4>
  c4:	15 8e       	std	Z+29, r1	; 0x1d
  c6:	d8 01       	movw	r26, r16
  c8:	5e 96       	adiw	r26, 0x1e	; 30
  ca:	8c 91       	ld	r24, X
  cc:	5e 97       	sbiw	r26, 0x1e	; 30
  ce:	8f 3f       	cpi	r24, 0xFF	; 255
  d0:	01 f4       	brne	.+0      	; 0xd2 <xQueueSemaphoreTake+0xd2>
  d2:	5e 96       	adiw	r26, 0x1e	; 30
  d4:	1c 92       	st	X, r1
  d6:	0f 90       	pop	r0
  d8:	0f be       	out	0x3f, r0	; 63
  da:	be 01       	movw	r22, r28
  dc:	6c 5f       	subi	r22, 0xFC	; 252
  de:	7f 4f       	sbci	r23, 0xFF	; 255
  e0:	ce 01       	movw	r24, r28
  e2:	01 96       	adiw	r24, 0x01	; 1
  e4:	0e 94 00 00 	call	0	; 0x0 <xQueueSemaphoreTake>
  e8:	81 11       	cpse	r24, r1
  ea:	00 c0       	rjmp	.+0      	; 0xec <xQueueSemaphoreTake+0xec>
  ec:	c8 01       	movw	r24, r16
  ee:	0e 94 00 00 	call	0	; 0x0 <xQueueSemaphoreTake>
  f2:	88 23       	and	r24, r24
  f4:	01 f0       	breq	.+0      	; 0xf6 <xQueueSemaphoreTake+0xf6>
  f6:	f8 01       	movw	r30, r16
  f8:	80 81       	ld	r24, Z
  fa:	91 81       	ldd	r25, Z+1	; 0x01
  fc:	89 2b       	or	r24, r25
  fe:	01 f4       	brne	.+0      	; 0x100 <xQueueSemaphoreTake+0x100>
 100:	0f b6       	in	r0, 0x3f	; 63
 102:	f8 94       	cli
 104:	0f 92       	push	r0
 106:	84 81       	ldd	r24, Z+4	; 0x04
 108:	95 81       	ldd	r25, Z+5	; 0x05
 10a:	0e 94 00 00 	call	0	; 0x0 <xQueueSemaphoreTake>
 10e:	f8 2e       	mov	r15, r24
 110:	0f 90       	pop	r0
 112:	0f be       	out	0x3f, r0	; 63
 114:	6c 81       	ldd	r22, Y+4	; 0x04
 116:	7d 81       	ldd	r23, Y+5	; 0x05
 118:	c6 01       	movw	r24, r12
 11a:	0e 94 00 00 	call	0	; 0x0 <xQueueSemaphoreTake>
 11e:	c8 01       	movw	r24, r16
 120:	0e 94 00 00 	call	0	; 0x0 <xQueueSemaphoreTake>
 124:	0e 94 00 00 	call	0	; 0x0 <xQueueSemaphoreTake>
 128:	81 11       	cpse	r24, r1
 12a:	00 c0       	rjmp	.+0      	; 0x12c <xQueueSemaphoreTake+0x12c>
 12c:	0e 94 00 00 	call	0	; 0x0 <xQueueSemaphoreTake>
 130:	91 e0       	ldi	r25, 0x01	; 1
 132:	00 c0       	rjmp	.+0      	; 0x134 <xQueueSemaphoreTake+0x134>
 134:	c8 01       	movw	r24, r16
 136:	0e 94 00 00 	call	0	; 0x0 <xQueueSemaphoreTake>
 13a:	0e 94 00 00 	call	0	; 0x0 <xQueueSemaphoreTake>
 13e:	00 c0       	rjmp	.+0      	; 0x140 <xQueueSemaphoreTake+0x140>
 140:	c8 01       	movw	r24, r16
 142:	0e 94 00 00 	call	0	; 0x0 <xQueueSemaphoreTake>
 146:	0e 94 00 00 	call	0	; 0x0 <xQueueSemaphoreTake>
 14a:	c8 01       	movw	r24, r16
 14c:	0e 94 00 00 	call	0	; 0x0 <xQueueSemaphoreTake>
 150:	88 23       	and	r24, r24
 152:	01 f0       	breq	.+0      	; 0x154 <xQueueSemaphoreTake+0x154>
 154:	ff 20       	and	r15, r15
 156:	01 f4       	brne	.+0      	; 0x158 <xQueueSemaphoreTake+0x158>
 158:	00 c0       	rjmp	.+0      	; 0x15a <xQueueSemaphoreTake+0x15a>
 15a:	0f b6       	in	r0, 0x3f	; 63
 15c:	f8 94       	cli
 15e:	0f 92       	push	r0
 160:	f8 01       	movw	r30, r16
 162:	81 89       	ldd	r24, Z+17	; 0x11
 164:	60 e0       	ldi	r22, 0x00	; 0
 166:	88 23       	and	r24, r24
 168:	01 f0       	breq	.+0      	; 0x16a <xQueueSemaphoreTake+0x16a>
 16a:	06 88       	ldd	r0, Z+22	; 0x16
 16c:	f7 89       	ldd	r31, Z+23	; 0x17
 16e:	e0 2d       	mov	r30, r0
 170:	80 81       	ld	r24, Z
 172:	64 e0       	ldi	r22, 0x04	; 4
 174:	68 1b       	sub	r22, r24
 176:	d8 01       	movw	r26, r16
 178:	14 96       	adiw	r26, 0x04	; 4
 17a:	8d 91       	ld	r24, X+
 17c:	9c 91       	ld	r25, X
 17e:	0e 94 00 00 	call	0	; 0x0 <xQueueSemaphoreTake>
 182:	00 c0       	rjmp	.+0      	; 0x184 <__SREG__+0x145>

Disassembly of section .text.hot.xQueueTakeMutexRecursive:

00000000 <xQueueTakeMutexRecursive>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	1f 93       	push	r17
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	ec 01       	movw	r28, r24
   e:	8b 01       	movw	r16, r22
  10:	ec 80       	ldd	r14, Y+4	; 0x04
  12:	fd 80       	ldd	r15, Y+5	; 0x05
  14:	0e 94 00 00 	call	0	; 0x0 <xQueueTakeMutexRecursive>
  18:	e8 16       	cp	r14, r24
  1a:	f9 06       	cpc	r15, r25
  1c:	01 f4       	brne	.+0      	; 0x1e <xQueueTakeMutexRecursive+0x1e>
  1e:	8e 81       	ldd	r24, Y+6	; 0x06

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  20:	8f 5f       	subi	r24, 0xFF	; 255
  22:	8e 83       	std	Y+6, r24	; 0x06
  24:	81 e0       	ldi	r24, 0x01	; 1
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  26:	df 91       	pop	r29
  28:	cf 91       	pop	r28
  2a:	1f 91       	pop	r17
  2c:	0f 91       	pop	r16
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  2e:	ff 90       	pop	r15

        traceRETURN_vQueueWaitForMessageRestricted();
    }
  30:	ef 90       	pop	r14
  32:	08 95       	ret
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  34:	b8 01       	movw	r22, r16
  36:	ce 01       	movw	r24, r28
  38:	0e 94 00 00 	call	0	; 0x0 <xQueueTakeMutexRecursive>
  3c:	88 23       	and	r24, r24
  3e:	01 f0       	breq	.+0      	; 0x40 <xQueueTakeMutexRecursive+0x40>
  40:	9e 81       	ldd	r25, Y+6	; 0x06
  42:	9f 5f       	subi	r25, 0xFF	; 255
  44:	9e 83       	std	Y+6, r25	; 0x06
  46:	00 c0       	rjmp	.+0      	; 0x48 <__SREG__+0x9>

Disassembly of section .text.hot.xQueuePeek:

00000000 <xQueuePeek>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	00 d0       	rcall	.+0      	; 0x12 <xQueuePeek+0x12>
  12:	00 d0       	rcall	.+0      	; 0x14 <xQueuePeek+0x14>
  14:	1f 92       	push	r1
  16:	cd b7       	in	r28, 0x3d	; 61
  18:	de b7       	in	r29, 0x3e	; 62
  1a:	8c 01       	movw	r16, r24
  1c:	7b 01       	movw	r14, r22
  1e:	5d 83       	std	Y+5, r21	; 0x05

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  20:	4c 83       	std	Y+4, r20	; 0x04
  22:	80 e0       	ldi	r24, 0x00	; 0
  24:	68 01       	movw	r12, r16
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  26:	91 e1       	ldi	r25, 0x11	; 17
  28:	c9 0e       	add	r12, r25
  2a:	d1 1c       	adc	r13, r1
  2c:	0f b6       	in	r0, 0x3f	; 63
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  2e:	f8 94       	cli

        traceRETURN_vQueueWaitForMessageRestricted();
    }
  30:	0f 92       	push	r0
  32:	f8 01       	movw	r30, r16
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  34:	92 8d       	ldd	r25, Z+26	; 0x1a
  36:	99 23       	and	r25, r25
  38:	01 f0       	breq	.+0      	; 0x3a <xQueuePeek+0x3a>
  3a:	c6 80       	ldd	r12, Z+6	; 0x06
  3c:	d7 80       	ldd	r13, Z+7	; 0x07
  3e:	b7 01       	movw	r22, r14
  40:	c8 01       	movw	r24, r16
  42:	0e 94 00 00 	call	0	; 0x0 <xQueuePeek>
  46:	f8 01       	movw	r30, r16
  48:	d7 82       	std	Z+7, r13	; 0x07
  4a:	c6 82       	std	Z+6, r12	; 0x06
  4c:	81 89       	ldd	r24, Z+17	; 0x11
  4e:	88 23       	and	r24, r24
  50:	01 f0       	breq	.+0      	; 0x52 <xQueuePeek+0x52>
  52:	c8 01       	movw	r24, r16
  54:	41 96       	adiw	r24, 0x11	; 17
  56:	0e 94 00 00 	call	0	; 0x0 <xQueuePeek>
  5a:	81 11       	cpse	r24, r1
  5c:	0e 94 00 00 	call	0	; 0x0 <xQueuePeek>
  60:	0f 90       	pop	r0
  62:	0f be       	out	0x3f, r0	; 63
  64:	81 e0       	ldi	r24, 0x01	; 1
  66:	0f 90       	pop	r0
  68:	0f 90       	pop	r0
  6a:	0f 90       	pop	r0
  6c:	0f 90       	pop	r0
  6e:	0f 90       	pop	r0
  70:	df 91       	pop	r29
  72:	cf 91       	pop	r28
  74:	1f 91       	pop	r17
  76:	0f 91       	pop	r16
  78:	ff 90       	pop	r15
  7a:	ef 90       	pop	r14
  7c:	df 90       	pop	r13
  7e:	cf 90       	pop	r12
  80:	08 95       	ret
  82:	2c 81       	ldd	r18, Y+4	; 0x04
  84:	3d 81       	ldd	r19, Y+5	; 0x05
  86:	23 2b       	or	r18, r19
  88:	01 f4       	brne	.+0      	; 0x8a <xQueuePeek+0x8a>
  8a:	0f 90       	pop	r0
  8c:	0f be       	out	0x3f, r0	; 63
  8e:	80 e0       	ldi	r24, 0x00	; 0
  90:	00 c0       	rjmp	.+0      	; 0x92 <xQueuePeek+0x92>
  92:	81 11       	cpse	r24, r1
  94:	00 c0       	rjmp	.+0      	; 0x96 <xQueuePeek+0x96>
  96:	ce 01       	movw	r24, r28
  98:	01 96       	adiw	r24, 0x01	; 1
  9a:	0e 94 00 00 	call	0	; 0x0 <xQueuePeek>
  9e:	0f 90       	pop	r0
  a0:	0f be       	out	0x3f, r0	; 63
  a2:	0e 94 00 00 	call	0	; 0x0 <xQueuePeek>
  a6:	0f b6       	in	r0, 0x3f	; 63
  a8:	f8 94       	cli
  aa:	0f 92       	push	r0
  ac:	f8 01       	movw	r30, r16
  ae:	85 8d       	ldd	r24, Z+29	; 0x1d
  b0:	8f 3f       	cpi	r24, 0xFF	; 255
  b2:	01 f4       	brne	.+0      	; 0xb4 <xQueuePeek+0xb4>
  b4:	15 8e       	std	Z+29, r1	; 0x1d
  b6:	f8 01       	movw	r30, r16
  b8:	86 8d       	ldd	r24, Z+30	; 0x1e
  ba:	8f 3f       	cpi	r24, 0xFF	; 255
  bc:	01 f4       	brne	.+0      	; 0xbe <xQueuePeek+0xbe>
  be:	16 8e       	std	Z+30, r1	; 0x1e
  c0:	0f 90       	pop	r0
  c2:	0f be       	out	0x3f, r0	; 63
  c4:	be 01       	movw	r22, r28
  c6:	6c 5f       	subi	r22, 0xFC	; 252
  c8:	7f 4f       	sbci	r23, 0xFF	; 255
  ca:	ce 01       	movw	r24, r28
  cc:	01 96       	adiw	r24, 0x01	; 1
  ce:	0e 94 00 00 	call	0	; 0x0 <xQueuePeek>
  d2:	81 11       	cpse	r24, r1
  d4:	00 c0       	rjmp	.+0      	; 0xd6 <xQueuePeek+0xd6>
  d6:	c8 01       	movw	r24, r16
  d8:	0e 94 00 00 	call	0	; 0x0 <xQueuePeek>
  dc:	88 23       	and	r24, r24
  de:	01 f0       	breq	.+0      	; 0xe0 <xQueuePeek+0xe0>
  e0:	6c 81       	ldd	r22, Y+4	; 0x04
  e2:	7d 81       	ldd	r23, Y+5	; 0x05
  e4:	c6 01       	movw	r24, r12
  e6:	0e 94 00 00 	call	0	; 0x0 <xQueuePeek>
  ea:	c8 01       	movw	r24, r16
  ec:	0e 94 00 00 	call	0	; 0x0 <xQueuePeek>
  f0:	0e 94 00 00 	call	0	; 0x0 <xQueuePeek>
  f4:	81 11       	cpse	r24, r1
  f6:	00 c0       	rjmp	.+0      	; 0xf8 <xQueuePeek+0xf8>
  f8:	0e 94 00 00 	call	0	; 0x0 <xQueuePeek>
  fc:	81 e0       	ldi	r24, 0x01	; 1
  fe:	00 c0       	rjmp	.+0      	; 0x100 <xQueuePeek+0x100>
 100:	c8 01       	movw	r24, r16
 102:	0e 94 00 00 	call	0	; 0x0 <xQueuePeek>
 106:	0e 94 00 00 	call	0	; 0x0 <xQueuePeek>
 10a:	00 c0       	rjmp	.+0      	; 0x10c <xQueuePeek+0x10c>
 10c:	c8 01       	movw	r24, r16
 10e:	0e 94 00 00 	call	0	; 0x0 <xQueuePeek>
 112:	0e 94 00 00 	call	0	; 0x0 <xQueuePeek>
 116:	c8 01       	movw	r24, r16
 118:	0e 94 00 00 	call	0	; 0x0 <xQueuePeek>
 11c:	88 23       	and	r24, r24
 11e:	01 f0       	breq	.+0      	; 0x120 <xQueuePeek+0x120>
 120:	00 c0       	rjmp	.+0      	; 0x122 <__SREG__+0xe3>

Disassembly of section .text.hot.xQueueReceiveFromISR:

00000000 <xQueueReceiveFromISR>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	1f 93       	push	r17
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	fc 01       	movw	r30, r24
   e:	02 8d       	ldd	r16, Z+26	; 0x1a
  10:	00 23       	and	r16, r16
  12:	01 f0       	breq	.+0      	; 0x14 <xQueueReceiveFromISR+0x14>
  14:	7a 01       	movw	r14, r20
  16:	ec 01       	movw	r28, r24
  18:	15 8d       	ldd	r17, Z+29	; 0x1d
  1a:	0e 94 00 00 	call	0	; 0x0 <xQueueReceiveFromISR>
  1e:	01 50       	subi	r16, 0x01	; 1

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  20:	0a 8f       	std	Y+26, r16	; 0x1a
  22:	1f 3f       	cpi	r17, 0xFF	; 255
  24:	01 f4       	brne	.+0      	; 0x26 <xQueueReceiveFromISR+0x26>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  26:	88 85       	ldd	r24, Y+8	; 0x08
  28:	81 11       	cpse	r24, r1
  2a:	00 c0       	rjmp	.+0      	; 0x2c <xQueueReceiveFromISR+0x2c>
  2c:	81 e0       	ldi	r24, 0x01	; 1
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  2e:	00 c0       	rjmp	.+0      	; 0x30 <xQueueReceiveFromISR+0x30>

        traceRETURN_vQueueWaitForMessageRestricted();
    }
  30:	ce 01       	movw	r24, r28
  32:	08 96       	adiw	r24, 0x08	; 8
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  34:	0e 94 00 00 	call	0	; 0x0 <xQueueReceiveFromISR>
  38:	88 23       	and	r24, r24
  3a:	01 f0       	breq	.+0      	; 0x3c <xQueueReceiveFromISR+0x3c>
  3c:	e1 14       	cp	r14, r1
  3e:	f1 04       	cpc	r15, r1
  40:	01 f0       	breq	.+0      	; 0x42 <xQueueReceiveFromISR+0x42>
  42:	81 e0       	ldi	r24, 0x01	; 1
  44:	f7 01       	movw	r30, r14
  46:	80 83       	st	Z, r24
  48:	df 91       	pop	r29
  4a:	cf 91       	pop	r28
  4c:	1f 91       	pop	r17
  4e:	0f 91       	pop	r16
  50:	ff 90       	pop	r15
  52:	ef 90       	pop	r14
  54:	08 95       	ret
  56:	0e 94 00 00 	call	0	; 0x0 <xQueueReceiveFromISR>
  5a:	18 17       	cp	r17, r24
  5c:	00 f4       	brcc	.+0      	; 0x5e <xQueueReceiveFromISR+0x5e>
  5e:	1f 5f       	subi	r17, 0xFF	; 255
  60:	1d 8f       	std	Y+29, r17	; 0x1d
  62:	00 c0       	rjmp	.+0      	; 0x64 <xQueueReceiveFromISR+0x64>
  64:	80 e0       	ldi	r24, 0x00	; 0
  66:	00 c0       	rjmp	.+0      	; 0x68 <__SREG__+0x29>

Disassembly of section .text.hot.xQueuePeekFromISR:

00000000 <xQueuePeekFromISR>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	df 93       	push	r29
   8:	fc 01       	movw	r30, r24
   a:	22 8d       	ldd	r18, Z+26	; 0x1a
   c:	22 23       	and	r18, r18
   e:	01 f0       	breq	.+0      	; 0x10 <xQueuePeekFromISR+0x10>
  10:	ec 01       	movw	r28, r24
  12:	06 81       	ldd	r16, Z+6	; 0x06
  14:	17 81       	ldd	r17, Z+7	; 0x07
  16:	0e 94 00 00 	call	0	; 0x0 <xQueuePeekFromISR>
  1a:	1f 83       	std	Y+7, r17	; 0x07
  1c:	0e 83       	std	Y+6, r16	; 0x06
  1e:	81 e0       	ldi	r24, 0x01	; 1

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  20:	df 91       	pop	r29
  22:	cf 91       	pop	r28
  24:	1f 91       	pop	r17
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  26:	0f 91       	pop	r16
  28:	08 95       	ret
  2a:	80 e0       	ldi	r24, 0x00	; 0
  2c:	00 c0       	rjmp	.+0      	; 0x2e <__zero_reg__+0x2d>

Disassembly of section .text.hot.uxQueueMessagesWaiting:

00000000 <uxQueueMessagesWaiting>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	0f b6       	in	r0, 0x3f	; 63
   2:	f8 94       	cli
   4:	0f 92       	push	r0
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	fc 01       	movw	r30, r24
   8:	82 8d       	ldd	r24, Z+26	; 0x1a
   a:	0f 90       	pop	r0
   c:	0f be       	out	0x3f, r0	; 63
   e:	08 95       	ret

Disassembly of section .text.hot.uxQueueSpacesAvailable:

00000000 <uxQueueSpacesAvailable>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	0f b6       	in	r0, 0x3f	; 63
   2:	f8 94       	cli
   4:	0f 92       	push	r0
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	fc 01       	movw	r30, r24
   8:	22 8d       	ldd	r18, Z+26	; 0x1a
   a:	83 8d       	ldd	r24, Z+27	; 0x1b
   c:	82 1b       	sub	r24, r18
   e:	0f 90       	pop	r0
  10:	0f be       	out	0x3f, r0	; 63
  12:	08 95       	ret

Disassembly of section .text.hot.uxQueueMessagesWaitingFromISR:

00000000 <uxQueueMessagesWaitingFromISR>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	fc 01       	movw	r30, r24
   2:	82 8d       	ldd	r24, Z+26	; 0x1a
   4:	08 95       	ret

Disassembly of section .text.hot.vQueueDelete:

00000000 <vQueueDelete>:
   0:	0c 94 00 00 	jmp	0	; 0x0 <vQueueDelete>

Disassembly of section .text.hot.uxQueueGetQueueItemSize:

00000000 <uxQueueGetQueueItemSize>:
   0:	fc 01       	movw	r30, r24
   2:	84 8d       	ldd	r24, Z+28	; 0x1c
   4:	08 95       	ret

Disassembly of section .text.hot.uxQueueGetQueueLength:

00000000 <uxQueueGetQueueLength>:
   0:	fc 01       	movw	r30, r24
   2:	83 8d       	ldd	r24, Z+27	; 0x1b
   4:	08 95       	ret

Disassembly of section .text.hot.xQueueIsQueueEmptyFromISR:

00000000 <xQueueIsQueueEmptyFromISR>:
   0:	fc 01       	movw	r30, r24
   2:	92 8d       	ldd	r25, Z+26	; 0x1a
   4:	81 e0       	ldi	r24, 0x01	; 1
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	91 11       	cpse	r25, r1
   8:	80 e0       	ldi	r24, 0x00	; 0
   a:	08 95       	ret

Disassembly of section .text.hot.xQueueIsQueueFullFromISR:

00000000 <xQueueIsQueueFullFromISR>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	fc 01       	movw	r30, r24
   2:	92 8d       	ldd	r25, Z+26	; 0x1a
   4:	81 e0       	ldi	r24, 0x01	; 1
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	23 8d       	ldd	r18, Z+27	; 0x1b
   8:	29 13       	cpse	r18, r25
   a:	80 e0       	ldi	r24, 0x00	; 0
   c:	08 95       	ret

Disassembly of section .text.hot.vQueueWaitForMessageRestricted:

00000000 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
   6:	0f b6       	in	r0, 0x3f	; 63
   8:	f8 94       	cli
   a:	0f 92       	push	r0
   c:	8d 8d       	ldd	r24, Y+29	; 0x1d
   e:	8f 3f       	cpi	r24, 0xFF	; 255
  10:	01 f4       	brne	.+0      	; 0x12 <vQueueWaitForMessageRestricted+0x12>
  12:	1d 8e       	std	Y+29, r1	; 0x1d
  14:	8e 8d       	ldd	r24, Y+30	; 0x1e
  16:	8f 3f       	cpi	r24, 0xFF	; 255
  18:	01 f4       	brne	.+0      	; 0x1a <vQueueWaitForMessageRestricted+0x1a>
  1a:	1e 8e       	std	Y+30, r1	; 0x1e
  1c:	0f 90       	pop	r0
  1e:	0f be       	out	0x3f, r0	; 63

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
  20:	8a 8d       	ldd	r24, Y+26	; 0x1a
  22:	81 11       	cpse	r24, r1
  24:	00 c0       	rjmp	.+0      	; 0x26 <vQueueWaitForMessageRestricted+0x26>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
  26:	ce 01       	movw	r24, r28
  28:	41 96       	adiw	r24, 0x11	; 17
  2a:	0e 94 00 00 	call	0	; 0x0 <vQueueWaitForMessageRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  2e:	ce 01       	movw	r24, r28

        traceRETURN_vQueueWaitForMessageRestricted();
    }
  30:	df 91       	pop	r29
  32:	cf 91       	pop	r28
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
  34:	0c 94 00 00 	jmp	0	; 0x0 <vQueueWaitForMessageRestricted>

stream_buffer.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00001a40  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000287d  00000000  00000000  00001a74  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.hot.prvBytesInBuffer 00000026  00000000  00000000  000042f1  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.hot.prvWriteBytesToBuffer 00000088  00000000  00000000  00004317  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.hot.prvWriteMessageToBuffer 0000008c  00000000  00000000  0000439f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.hot.prvReadBytesFromBuffer 00000088  00000000  00000000  0000442b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.hot.prvReadMessageFromBuffer 00000090  00000000  00000000  000044b3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.hot.xStreamBufferGenericCreate 00000070  00000000  00000000  00004543  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.hot.vStreamBufferDelete 00000014  00000000  00000000  000045b3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text.hot.xStreamBufferReset 00000040  00000000  00000000  000045c7  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.hot.xStreamBufferResetFromISR 00000036  00000000  00000000  00004607  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text.hot.xStreamBufferSetTriggerLevel 00000022  00000000  00000000  0000463d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text.hot.xStreamBufferSpacesAvailable 00000034  00000000  00000000  0000465f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 16 .text.hot.xStreamBufferBytesAvailable 00000004  00000000  00000000  00004693  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 17 .text.hot.xStreamBufferSend 00000176  00000000  00000000  00004697  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 18 .text.hot.xStreamBufferSendFromISR 0000008c  00000000  00000000  0000480d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 19 .text.hot.xStreamBufferReceive 00000100  00000000  00000000  00004899  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 20 .text.hot.xStreamBufferNextMessageLengthBytes 0000004e  00000000  00000000  00004999  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 21 .text.hot.xStreamBufferReceiveFromISR 0000008a  00000000  00000000  000049e7  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 22 .text.hot.xStreamBufferIsEmpty 00000016  00000000  00000000  00004a71  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 23 .text.hot.xStreamBufferIsFull 0000002a  00000000  00000000  00004a87  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 24 .text.hot.xStreamBufferSendCompletedFromISR 00000052  00000000  00000000  00004ab1  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 25 .text.hot.xStreamBufferReceiveCompletedFromISR 00000052  00000000  00000000  00004b03  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 26 .text.hot.uxStreamBufferGetStreamBufferNotificationIndex 00000006  00000000  00000000  00004b55  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 27 .text.hot.vStreamBufferSetStreamBufferNotificationIndex 00000006  00000000  00000000  00004b5b  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 28 .comment      00000012  00000000  00000000  00004b61  2**0
                  CONTENTS, READONLY

Disassembly of section .text.hot.prvBytesInBuffer:

00000000 <prvBytesInBuffer>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	fc 01       	movw	r30, r24
   2:	44 81       	ldd	r20, Z+4	; 0x04

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	55 81       	ldd	r21, Z+5	; 0x05
   6:	22 81       	ldd	r18, Z+2	; 0x02
   8:	33 81       	ldd	r19, Z+3	; 0x03
   a:	24 0f       	add	r18, r20
   c:	35 1f       	adc	r19, r21
   e:	80 81       	ld	r24, Z
  10:	91 81       	ldd	r25, Z+1	; 0x01
  12:	b9 01       	movw	r22, r18
  14:	68 1b       	sub	r22, r24
  16:	79 0b       	sbc	r23, r25
  18:	cb 01       	movw	r24, r22
  1a:	64 17       	cp	r22, r20
  1c:	75 07       	cpc	r23, r21
  1e:	00 f0       	brcs	.+0      	; 0x20 <prvBytesInBuffer+0x20>
  20:	84 1b       	sub	r24, r20
  22:	95 0b       	sbc	r25, r21
  24:	08 95       	ret

Disassembly of section .text.hot.prvWriteBytesToBuffer:

00000000 <prvWriteBytesToBuffer>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	af 92       	push	r10
   2:	bf 92       	push	r11

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	cf 92       	push	r12
   6:	df 92       	push	r13
   8:	ef 92       	push	r14
   a:	ff 92       	push	r15
   c:	0f 93       	push	r16
   e:	1f 93       	push	r17
  10:	cf 93       	push	r28
  12:	df 93       	push	r29
  14:	6c 01       	movw	r12, r24
  16:	5b 01       	movw	r10, r22
  18:	7a 01       	movw	r14, r20
  1a:	e9 01       	movw	r28, r18
  1c:	fc 01       	movw	r30, r24
  1e:	04 81       	ldd	r16, Z+4	; 0x04
  20:	15 81       	ldd	r17, Z+5	; 0x05
  22:	02 1b       	sub	r16, r18
  24:	13 0b       	sbc	r17, r19
  26:	40 17       	cp	r20, r16
  28:	51 07       	cpc	r21, r17
  2a:	00 f4       	brcc	.+0      	; 0x2c <prvWriteBytesToBuffer+0x2c>
  2c:	8a 01       	movw	r16, r20
  2e:	f6 01       	movw	r30, r12
  30:	84 85       	ldd	r24, Z+12	; 0x0c
  32:	95 85       	ldd	r25, Z+13	; 0x0d
  34:	a8 01       	movw	r20, r16
  36:	b5 01       	movw	r22, r10
  38:	8c 0f       	add	r24, r28
  3a:	9d 1f       	adc	r25, r29
  3c:	0e 94 00 00 	call	0	; 0x0 <prvWriteBytesToBuffer>
  40:	0e 15       	cp	r16, r14
  42:	1f 05       	cpc	r17, r15
  44:	00 f4       	brcc	.+0      	; 0x46 <prvWriteBytesToBuffer+0x46>
  46:	a7 01       	movw	r20, r14
  48:	40 1b       	sub	r20, r16
  4a:	51 0b       	sbc	r21, r17
  4c:	b5 01       	movw	r22, r10
  4e:	60 0f       	add	r22, r16
  50:	71 1f       	adc	r23, r17
  52:	f6 01       	movw	r30, r12
  54:	84 85       	ldd	r24, Z+12	; 0x0c
  56:	95 85       	ldd	r25, Z+13	; 0x0d
  58:	0e 94 00 00 	call	0	; 0x0 <prvWriteBytesToBuffer>
  5c:	ce 01       	movw	r24, r28
  5e:	8e 0d       	add	r24, r14
  60:	9f 1d       	adc	r25, r15
  62:	f6 01       	movw	r30, r12
  64:	24 81       	ldd	r18, Z+4	; 0x04
  66:	35 81       	ldd	r19, Z+5	; 0x05
  68:	82 17       	cp	r24, r18
  6a:	93 07       	cpc	r25, r19
  6c:	00 f0       	brcs	.+0      	; 0x6e <prvWriteBytesToBuffer+0x6e>
  6e:	82 1b       	sub	r24, r18
  70:	93 0b       	sbc	r25, r19
  72:	df 91       	pop	r29
  74:	cf 91       	pop	r28
  76:	1f 91       	pop	r17
  78:	0f 91       	pop	r16
  7a:	ff 90       	pop	r15
  7c:	ef 90       	pop	r14
  7e:	df 90       	pop	r13
  80:	cf 90       	pop	r12
  82:	bf 90       	pop	r11
  84:	af 90       	pop	r10
  86:	08 95       	ret

Disassembly of section .text.hot.prvWriteMessageToBuffer:

00000000 <prvWriteMessageToBuffer>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	af 92       	push	r10
   2:	bf 92       	push	r11

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	cf 92       	push	r12
   6:	df 92       	push	r13
   8:	ef 92       	push	r14
   a:	ff 92       	push	r15
   c:	0f 93       	push	r16
   e:	1f 93       	push	r17
  10:	cf 93       	push	r28
  12:	df 93       	push	r29
  14:	00 d0       	rcall	.+0      	; 0x16 <prvWriteMessageToBuffer+0x16>
  16:	cd b7       	in	r28, 0x3d	; 61
  18:	de b7       	in	r29, 0x3e	; 62
  1a:	6c 01       	movw	r12, r24
  1c:	5b 01       	movw	r10, r22
  1e:	7a 01       	movw	r14, r20
  20:	fc 01       	movw	r30, r24
  22:	82 81       	ldd	r24, Z+2	; 0x02
  24:	93 81       	ldd	r25, Z+3	; 0x03
  26:	46 85       	ldd	r20, Z+14	; 0x0e
  28:	40 ff       	sbrs	r20, 0
  2a:	00 c0       	rjmp	.+0      	; 0x2c <prvWriteMessageToBuffer+0x2c>
  2c:	fa 82       	std	Y+2, r15	; 0x02
  2e:	e9 82       	std	Y+1, r14	; 0x01
  30:	20 17       	cp	r18, r16
  32:	31 07       	cpc	r19, r17
  34:	00 f0       	brcs	.+0      	; 0x36 <prvWriteMessageToBuffer+0x36>
  36:	9c 01       	movw	r18, r24
  38:	42 e0       	ldi	r20, 0x02	; 2
  3a:	50 e0       	ldi	r21, 0x00	; 0
  3c:	be 01       	movw	r22, r28
  3e:	6f 5f       	subi	r22, 0xFF	; 255
  40:	7f 4f       	sbci	r23, 0xFF	; 255
  42:	c6 01       	movw	r24, r12
  44:	0e 94 00 00 	call	0	; 0x0 <prvWriteMessageToBuffer>
  48:	e1 14       	cp	r14, r1
  4a:	f1 04       	cpc	r15, r1
  4c:	01 f0       	breq	.+0      	; 0x4e <prvWriteMessageToBuffer+0x4e>
  4e:	9c 01       	movw	r18, r24
  50:	a7 01       	movw	r20, r14
  52:	b5 01       	movw	r22, r10
  54:	c6 01       	movw	r24, r12
  56:	0e 94 00 00 	call	0	; 0x0 <prvWriteMessageToBuffer>
  5a:	f6 01       	movw	r30, r12
  5c:	93 83       	std	Z+3, r25	; 0x03
  5e:	82 83       	std	Z+2, r24	; 0x02
  60:	c7 01       	movw	r24, r14
  62:	0f 90       	pop	r0
  64:	0f 90       	pop	r0
  66:	df 91       	pop	r29
  68:	cf 91       	pop	r28
  6a:	1f 91       	pop	r17
  6c:	0f 91       	pop	r16
  6e:	ff 90       	pop	r15
  70:	ef 90       	pop	r14
  72:	df 90       	pop	r13
  74:	cf 90       	pop	r12
  76:	bf 90       	pop	r11
  78:	af 90       	pop	r10
  7a:	08 95       	ret
  7c:	2e 15       	cp	r18, r14
  7e:	3f 05       	cpc	r19, r15
  80:	00 f4       	brcc	.+0      	; 0x82 <prvWriteMessageToBuffer+0x82>
  82:	79 01       	movw	r14, r18
  84:	00 c0       	rjmp	.+0      	; 0x86 <prvWriteMessageToBuffer+0x86>
  86:	f1 2c       	mov	r15, r1
  88:	e1 2c       	mov	r14, r1
  8a:	00 c0       	rjmp	.+0      	; 0x8c <__SREG__+0x4d>

Disassembly of section .text.hot.prvReadBytesFromBuffer:

00000000 <prvReadBytesFromBuffer>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	af 92       	push	r10
   2:	bf 92       	push	r11

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	cf 92       	push	r12
   6:	df 92       	push	r13
   8:	ef 92       	push	r14
   a:	ff 92       	push	r15
   c:	0f 93       	push	r16
   e:	1f 93       	push	r17
  10:	cf 93       	push	r28
  12:	df 93       	push	r29
  14:	6c 01       	movw	r12, r24
  16:	5b 01       	movw	r10, r22
  18:	7a 01       	movw	r14, r20
  1a:	e9 01       	movw	r28, r18
  1c:	fc 01       	movw	r30, r24
  1e:	04 81       	ldd	r16, Z+4	; 0x04
  20:	15 81       	ldd	r17, Z+5	; 0x05
  22:	02 1b       	sub	r16, r18
  24:	13 0b       	sbc	r17, r19
  26:	40 17       	cp	r20, r16
  28:	51 07       	cpc	r21, r17
  2a:	00 f4       	brcc	.+0      	; 0x2c <prvReadBytesFromBuffer+0x2c>
  2c:	8a 01       	movw	r16, r20
  2e:	f6 01       	movw	r30, r12
  30:	64 85       	ldd	r22, Z+12	; 0x0c
  32:	75 85       	ldd	r23, Z+13	; 0x0d
  34:	6c 0f       	add	r22, r28
  36:	7d 1f       	adc	r23, r29
  38:	a8 01       	movw	r20, r16
  3a:	c5 01       	movw	r24, r10
  3c:	0e 94 00 00 	call	0	; 0x0 <prvReadBytesFromBuffer>
  40:	0e 15       	cp	r16, r14
  42:	1f 05       	cpc	r17, r15
  44:	00 f4       	brcc	.+0      	; 0x46 <prvReadBytesFromBuffer+0x46>
  46:	a7 01       	movw	r20, r14
  48:	40 1b       	sub	r20, r16
  4a:	51 0b       	sbc	r21, r17
  4c:	f6 01       	movw	r30, r12
  4e:	64 85       	ldd	r22, Z+12	; 0x0c
  50:	75 85       	ldd	r23, Z+13	; 0x0d
  52:	c5 01       	movw	r24, r10
  54:	80 0f       	add	r24, r16
  56:	91 1f       	adc	r25, r17
  58:	0e 94 00 00 	call	0	; 0x0 <prvReadBytesFromBuffer>
  5c:	ce 01       	movw	r24, r28
  5e:	8e 0d       	add	r24, r14
  60:	9f 1d       	adc	r25, r15
  62:	f6 01       	movw	r30, r12
  64:	24 81       	ldd	r18, Z+4	; 0x04
  66:	35 81       	ldd	r19, Z+5	; 0x05
  68:	82 17       	cp	r24, r18
  6a:	93 07       	cpc	r25, r19
  6c:	00 f0       	brcs	.+0      	; 0x6e <prvReadBytesFromBuffer+0x6e>
  6e:	82 1b       	sub	r24, r18
  70:	93 0b       	sbc	r25, r19
  72:	df 91       	pop	r29
  74:	cf 91       	pop	r28
  76:	1f 91       	pop	r17
  78:	0f 91       	pop	r16
  7a:	ff 90       	pop	r15
  7c:	ef 90       	pop	r14
  7e:	df 90       	pop	r13
  80:	cf 90       	pop	r12
  82:	bf 90       	pop	r11
  84:	af 90       	pop	r10
  86:	08 95       	ret

Disassembly of section .text.hot.prvReadMessageFromBuffer:

00000000 <prvReadMessageFromBuffer>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	af 92       	push	r10
   2:	bf 92       	push	r11

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	cf 92       	push	r12
   6:	df 92       	push	r13
   8:	ef 92       	push	r14
   a:	ff 92       	push	r15
   c:	0f 93       	push	r16
   e:	1f 93       	push	r17
  10:	cf 93       	push	r28
  12:	df 93       	push	r29
  14:	00 d0       	rcall	.+0      	; 0x16 <prvReadMessageFromBuffer+0x16>
  16:	cd b7       	in	r28, 0x3d	; 61
  18:	de b7       	in	r29, 0x3e	; 62
  1a:	7c 01       	movw	r14, r24
  1c:	5b 01       	movw	r10, r22
  1e:	6a 01       	movw	r12, r20
  20:	89 01       	movw	r16, r18
  22:	fc 01       	movw	r30, r24
  24:	20 81       	ld	r18, Z
  26:	31 81       	ldd	r19, Z+1	; 0x01
  28:	86 85       	ldd	r24, Z+14	; 0x0e
  2a:	80 ff       	sbrs	r24, 0
  2c:	00 c0       	rjmp	.+0      	; 0x2e <prvReadMessageFromBuffer+0x2e>
  2e:	42 e0       	ldi	r20, 0x02	; 2
  30:	50 e0       	ldi	r21, 0x00	; 0
  32:	be 01       	movw	r22, r28
  34:	6f 5f       	subi	r22, 0xFF	; 255
  36:	7f 4f       	sbci	r23, 0xFF	; 255
  38:	c7 01       	movw	r24, r14
  3a:	0e 94 00 00 	call	0	; 0x0 <prvReadMessageFromBuffer>
  3e:	9c 01       	movw	r18, r24
  40:	89 81       	ldd	r24, Y+1	; 0x01
  42:	9a 81       	ldd	r25, Y+2	; 0x02
  44:	02 50       	subi	r16, 0x02	; 2
  46:	11 09       	sbc	r17, r1
  48:	c8 16       	cp	r12, r24
  4a:	d9 06       	cpc	r13, r25
  4c:	00 f4       	brcc	.+0      	; 0x4e <prvReadMessageFromBuffer+0x4e>
  4e:	d1 2c       	mov	r13, r1
  50:	c1 2c       	mov	r12, r1
  52:	c0 16       	cp	r12, r16
  54:	d1 06       	cpc	r13, r17
  56:	00 f4       	brcc	.+0      	; 0x58 <prvReadMessageFromBuffer+0x58>
  58:	86 01       	movw	r16, r12
  5a:	01 15       	cp	r16, r1
  5c:	11 05       	cpc	r17, r1
  5e:	01 f0       	breq	.+0      	; 0x60 <prvReadMessageFromBuffer+0x60>
  60:	a8 01       	movw	r20, r16
  62:	b5 01       	movw	r22, r10
  64:	c7 01       	movw	r24, r14
  66:	0e 94 00 00 	call	0	; 0x0 <prvReadMessageFromBuffer>
  6a:	f7 01       	movw	r30, r14
  6c:	91 83       	std	Z+1, r25	; 0x01
  6e:	80 83       	st	Z, r24
  70:	c8 01       	movw	r24, r16
  72:	0f 90       	pop	r0
  74:	0f 90       	pop	r0
  76:	df 91       	pop	r29
  78:	cf 91       	pop	r28
  7a:	1f 91       	pop	r17
  7c:	0f 91       	pop	r16
  7e:	ff 90       	pop	r15
  80:	ef 90       	pop	r14
  82:	df 90       	pop	r13
  84:	cf 90       	pop	r12
  86:	bf 90       	pop	r11
  88:	af 90       	pop	r10
  8a:	08 95       	ret
  8c:	6c 01       	movw	r12, r24
  8e:	00 c0       	rjmp	.+0      	; 0x90 <__SREG__+0x51>

Disassembly of section .text.hot.xStreamBufferGenericCreate:

00000000 <xStreamBufferGenericCreate>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	1f 93       	push	r17
   6:	cf 93       	push	r28
   8:	df 93       	push	r29
   a:	ec 01       	movw	r28, r24
   c:	7b 01       	movw	r14, r22
   e:	11 e0       	ldi	r17, 0x01	; 1
  10:	41 30       	cpi	r20, 0x01	; 1
  12:	01 f0       	breq	.+0      	; 0x14 <xStreamBufferGenericCreate+0x14>
  14:	10 e0       	ldi	r17, 0x00	; 0
  16:	42 30       	cpi	r20, 0x02	; 2
  18:	01 f4       	brne	.+0      	; 0x1a <xStreamBufferGenericCreate+0x1a>
  1a:	14 e0       	ldi	r17, 0x04	; 4
  1c:	e1 14       	cp	r14, r1
  1e:	f1 04       	cpc	r15, r1
  20:	01 f4       	brne	.+0      	; 0x22 <xStreamBufferGenericCreate+0x22>
  22:	ee 24       	eor	r14, r14
  24:	e3 94       	inc	r14
  26:	f1 2c       	mov	r15, r1
  28:	f0 e0       	ldi	r31, 0x00	; 0
  2a:	e0 e0       	ldi	r30, 0x00	; 0
  2c:	cf 3e       	cpi	r28, 0xEF	; 239
  2e:	8f ef       	ldi	r24, 0xFF	; 255
  30:	d8 07       	cpc	r29, r24
  32:	00 f4       	brcc	.+0      	; 0x34 <xStreamBufferGenericCreate+0x34>
  34:	ce 01       	movw	r24, r28
  36:	41 96       	adiw	r24, 0x11	; 17
  38:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferGenericCreate>
  3c:	fc 01       	movw	r30, r24
  3e:	89 2b       	or	r24, r25
  40:	01 f0       	breq	.+0      	; 0x42 <xStreamBufferGenericCreate+0x42>
  42:	8c e0       	ldi	r24, 0x0C	; 12
  44:	df 01       	movw	r26, r30
  46:	1d 92       	st	X+, r1
  48:	8a 95       	dec	r24
  4a:	01 f4       	brne	.+0      	; 0x4c <xStreamBufferGenericCreate+0x4c>
  4c:	cf 01       	movw	r24, r30
  4e:	40 96       	adiw	r24, 0x10	; 16
  50:	95 87       	std	Z+13, r25	; 0x0d
  52:	84 87       	std	Z+12, r24	; 0x0c
  54:	21 96       	adiw	r28, 0x01	; 1
  56:	d5 83       	std	Z+5, r29	; 0x05
  58:	c4 83       	std	Z+4, r28	; 0x04
  5a:	f7 82       	std	Z+7, r15	; 0x07
  5c:	e6 82       	std	Z+6, r14	; 0x06
  5e:	16 87       	std	Z+14, r17	; 0x0e
  60:	17 86       	std	Z+15, r1	; 0x0f
  62:	cf 01       	movw	r24, r30
  64:	df 91       	pop	r29
  66:	cf 91       	pop	r28
  68:	1f 91       	pop	r17
  6a:	ff 90       	pop	r15
  6c:	ef 90       	pop	r14
  6e:	08 95       	ret

Disassembly of section .text.hot.vStreamBufferDelete:

00000000 <vStreamBufferDelete>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	fc 01       	movw	r30, r24
   2:	26 85       	ldd	r18, Z+14	; 0x0e

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	21 ff       	sbrs	r18, 1
   6:	0c 94 00 00 	jmp	0	; 0x0 <vStreamBufferDelete>
   a:	20 e1       	ldi	r18, 0x10	; 16
   c:	11 92       	st	Z+, r1
   e:	2a 95       	dec	r18
  10:	01 f4       	brne	.+0      	; 0x12 <vStreamBufferDelete+0x12>
  12:	08 95       	ret

Disassembly of section .text.hot.xStreamBufferReset:

00000000 <xStreamBufferReset>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	fc 01       	movw	r30, r24
   2:	0f b6       	in	r0, 0x3f	; 63

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	f8 94       	cli
   6:	0f 92       	push	r0
   8:	80 85       	ldd	r24, Z+8	; 0x08
   a:	91 85       	ldd	r25, Z+9	; 0x09
   c:	89 2b       	or	r24, r25
   e:	01 f4       	brne	.+0      	; 0x10 <xStreamBufferReset+0x10>
  10:	82 85       	ldd	r24, Z+10	; 0x0a
  12:	93 85       	ldd	r25, Z+11	; 0x0b
  14:	89 2b       	or	r24, r25
  16:	01 f4       	brne	.+0      	; 0x18 <xStreamBufferReset+0x18>
  18:	86 81       	ldd	r24, Z+6	; 0x06
  1a:	97 81       	ldd	r25, Z+7	; 0x07
  1c:	24 81       	ldd	r18, Z+4	; 0x04
  1e:	35 81       	ldd	r19, Z+5	; 0x05
  20:	4c e0       	ldi	r20, 0x0C	; 12
  22:	df 01       	movw	r26, r30
  24:	1d 92       	st	X+, r1
  26:	4a 95       	dec	r20
  28:	01 f4       	brne	.+0      	; 0x2a <xStreamBufferReset+0x2a>
  2a:	35 83       	std	Z+5, r19	; 0x05
  2c:	24 83       	std	Z+4, r18	; 0x04
  2e:	97 83       	std	Z+7, r25	; 0x07
  30:	86 83       	std	Z+6, r24	; 0x06
  32:	17 86       	std	Z+15, r1	; 0x0f
  34:	81 e0       	ldi	r24, 0x01	; 1
  36:	0f 90       	pop	r0
  38:	0f be       	out	0x3f, r0	; 63
  3a:	08 95       	ret
  3c:	80 e0       	ldi	r24, 0x00	; 0
  3e:	00 c0       	rjmp	.+0      	; 0x40 <__SREG__+0x1>

Disassembly of section .text.hot.xStreamBufferResetFromISR:

00000000 <xStreamBufferResetFromISR>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	fc 01       	movw	r30, r24
   2:	80 85       	ldd	r24, Z+8	; 0x08

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	91 85       	ldd	r25, Z+9	; 0x09
   6:	89 2b       	or	r24, r25
   8:	01 f4       	brne	.+0      	; 0xa <xStreamBufferResetFromISR+0xa>
   a:	82 85       	ldd	r24, Z+10	; 0x0a
   c:	93 85       	ldd	r25, Z+11	; 0x0b
   e:	89 2b       	or	r24, r25
  10:	01 f4       	brne	.+0      	; 0x12 <xStreamBufferResetFromISR+0x12>
  12:	86 81       	ldd	r24, Z+6	; 0x06
  14:	97 81       	ldd	r25, Z+7	; 0x07
  16:	24 81       	ldd	r18, Z+4	; 0x04
  18:	35 81       	ldd	r19, Z+5	; 0x05
  1a:	4c e0       	ldi	r20, 0x0C	; 12
  1c:	df 01       	movw	r26, r30
  1e:	1d 92       	st	X+, r1
  20:	4a 95       	dec	r20
  22:	01 f4       	brne	.+0      	; 0x24 <xStreamBufferResetFromISR+0x24>
  24:	35 83       	std	Z+5, r19	; 0x05
  26:	24 83       	std	Z+4, r18	; 0x04
  28:	97 83       	std	Z+7, r25	; 0x07
  2a:	86 83       	std	Z+6, r24	; 0x06
  2c:	17 86       	std	Z+15, r1	; 0x0f
  2e:	81 e0       	ldi	r24, 0x01	; 1
  30:	08 95       	ret
  32:	80 e0       	ldi	r24, 0x00	; 0
  34:	08 95       	ret

Disassembly of section .text.hot.xStreamBufferSetTriggerLevel:

00000000 <xStreamBufferSetTriggerLevel>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	61 15       	cp	r22, r1
   2:	71 05       	cpc	r23, r1

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	01 f4       	brne	.+0      	; 0x6 <xStreamBufferSetTriggerLevel+0x6>
   6:	61 e0       	ldi	r22, 0x01	; 1
   8:	70 e0       	ldi	r23, 0x00	; 0
   a:	fc 01       	movw	r30, r24
   c:	24 81       	ldd	r18, Z+4	; 0x04
   e:	35 81       	ldd	r19, Z+5	; 0x05
  10:	62 17       	cp	r22, r18
  12:	73 07       	cpc	r23, r19
  14:	00 f4       	brcc	.+0      	; 0x16 <xStreamBufferSetTriggerLevel+0x16>
  16:	77 83       	std	Z+7, r23	; 0x07
  18:	66 83       	std	Z+6, r22	; 0x06
  1a:	81 e0       	ldi	r24, 0x01	; 1
  1c:	08 95       	ret
  1e:	80 e0       	ldi	r24, 0x00	; 0
  20:	08 95       	ret

Disassembly of section .text.hot.xStreamBufferSpacesAvailable:

00000000 <xStreamBufferSpacesAvailable>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	fc 01       	movw	r30, r24
   2:	24 81       	ldd	r18, Z+4	; 0x04

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	35 81       	ldd	r19, Z+5	; 0x05
   6:	80 81       	ld	r24, Z
   8:	91 81       	ldd	r25, Z+1	; 0x01
   a:	60 81       	ld	r22, Z
   c:	71 81       	ldd	r23, Z+1	; 0x01
   e:	42 81       	ldd	r20, Z+2	; 0x02
  10:	53 81       	ldd	r21, Z+3	; 0x03
  12:	a0 81       	ld	r26, Z
  14:	b1 81       	ldd	r27, Z+1	; 0x01
  16:	a8 17       	cp	r26, r24
  18:	b9 07       	cpc	r27, r25
  1a:	01 f4       	brne	.+0      	; 0x1c <xStreamBufferSpacesAvailable+0x1c>
  1c:	c9 01       	movw	r24, r18
  1e:	01 97       	sbiw	r24, 0x01	; 1
  20:	86 0f       	add	r24, r22
  22:	97 1f       	adc	r25, r23
  24:	84 1b       	sub	r24, r20
  26:	95 0b       	sbc	r25, r21
  28:	82 17       	cp	r24, r18
  2a:	93 07       	cpc	r25, r19
  2c:	00 f0       	brcs	.+0      	; 0x2e <xStreamBufferSpacesAvailable+0x2e>
  2e:	82 1b       	sub	r24, r18
  30:	93 0b       	sbc	r25, r19
  32:	08 95       	ret

Disassembly of section .text.hot.xStreamBufferBytesAvailable:

00000000 <xStreamBufferBytesAvailable>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	0c 94 00 00 	jmp	0	; 0x0 <xStreamBufferBytesAvailable>

Disassembly of section .text.hot.xStreamBufferSend:

00000000 <xStreamBufferSend>:
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	4f 92       	push	r4
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
   a:	7f 92       	push	r7
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  24:	00 d0       	rcall	.+0      	; 0x26 <xStreamBufferSend+0x26>
  26:	00 d0       	rcall	.+0      	; 0x28 <xStreamBufferSend+0x28>
  28:	1f 92       	push	r1
  2a:	cd b7       	in	r28, 0x3d	; 61
  2c:	de b7       	in	r29, 0x3e	; 62
  2e:	5c 01       	movw	r10, r24
  30:	1b 01       	movw	r2, r22
  32:	2a 01       	movw	r4, r20
  34:	3d 83       	std	Y+5, r19	; 0x05
  36:	2c 83       	std	Y+4, r18	; 0x04
  38:	fc 01       	movw	r30, r24
  3a:	84 81       	ldd	r24, Z+4	; 0x04
  3c:	95 81       	ldd	r25, Z+5	; 0x05
  3e:	01 97       	sbiw	r24, 0x01	; 1
  40:	26 85       	ldd	r18, Z+14	; 0x0e
  42:	4a 01       	movw	r8, r20
  44:	20 ff       	sbrs	r18, 0
  46:	00 c0       	rjmp	.+0      	; 0x48 <xStreamBufferSend+0x48>
  48:	f2 e0       	ldi	r31, 0x02	; 2
  4a:	8f 0e       	add	r8, r31
  4c:	91 1c       	adc	r9, r1
  4e:	88 15       	cp	r24, r8
  50:	99 05       	cpc	r25, r9
  52:	00 f4       	brcc	.+0      	; 0x54 <xStreamBufferSend+0x54>
  54:	1d 82       	std	Y+5, r1	; 0x05
  56:	1c 82       	std	Y+4, r1	; 0x04
  58:	8c 81       	ldd	r24, Y+4	; 0x04
  5a:	9d 81       	ldd	r25, Y+5	; 0x05
  5c:	89 2b       	or	r24, r25
  5e:	01 f0       	breq	.+0      	; 0x60 <xStreamBufferSend+0x60>
  60:	00 c0       	rjmp	.+0      	; 0x62 <xStreamBufferSend+0x62>
  62:	c5 01       	movw	r24, r10
  64:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferSend>
  68:	3c 01       	movw	r6, r24
  6a:	84 01       	movw	r16, r8
  6c:	93 01       	movw	r18, r6
  6e:	a2 01       	movw	r20, r4
  70:	b1 01       	movw	r22, r2
  72:	c5 01       	movw	r24, r10
  74:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferSend>
  78:	4c 01       	movw	r8, r24
  7a:	89 2b       	or	r24, r25
  7c:	01 f0       	breq	.+0      	; 0x7e <xStreamBufferSend+0x7e>
  7e:	c5 01       	movw	r24, r10
  80:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferSend>
  84:	f5 01       	movw	r30, r10
  86:	26 81       	ldd	r18, Z+6	; 0x06
  88:	37 81       	ldd	r19, Z+7	; 0x07
  8a:	82 17       	cp	r24, r18
  8c:	93 07       	cpc	r25, r19
  8e:	00 f0       	brcs	.+0      	; 0x90 <xStreamBufferSend+0x90>
  90:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferSend>
  94:	f5 01       	movw	r30, r10
  96:	80 85       	ldd	r24, Z+8	; 0x08
  98:	91 85       	ldd	r25, Z+9	; 0x09
  9a:	89 2b       	or	r24, r25
  9c:	01 f0       	breq	.+0      	; 0x9e <xStreamBufferSend+0x9e>
  9e:	80 85       	ldd	r24, Z+8	; 0x08
  a0:	91 85       	ldd	r25, Z+9	; 0x09
  a2:	f1 2c       	mov	r15, r1
  a4:	e1 2c       	mov	r14, r1
  a6:	10 e0       	ldi	r17, 0x00	; 0
  a8:	00 e0       	ldi	r16, 0x00	; 0
  aa:	20 e0       	ldi	r18, 0x00	; 0
  ac:	30 e0       	ldi	r19, 0x00	; 0
  ae:	a9 01       	movw	r20, r18
  b0:	67 85       	ldd	r22, Z+15	; 0x0f
  b2:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferSend>
  b6:	f5 01       	movw	r30, r10
  b8:	11 86       	std	Z+9, r1	; 0x09
  ba:	10 86       	std	Z+8, r1	; 0x08
  bc:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferSend>
  c0:	c4 01       	movw	r24, r8
  c2:	0f 90       	pop	r0
  c4:	0f 90       	pop	r0
  c6:	0f 90       	pop	r0
  c8:	0f 90       	pop	r0
  ca:	0f 90       	pop	r0
  cc:	df 91       	pop	r29
  ce:	cf 91       	pop	r28
  d0:	1f 91       	pop	r17
  d2:	0f 91       	pop	r16
  d4:	ff 90       	pop	r15
  d6:	ef 90       	pop	r14
  d8:	df 90       	pop	r13
  da:	cf 90       	pop	r12
  dc:	bf 90       	pop	r11
  de:	af 90       	pop	r10
  e0:	9f 90       	pop	r9
  e2:	8f 90       	pop	r8
  e4:	7f 90       	pop	r7
  e6:	6f 90       	pop	r6
  e8:	5f 90       	pop	r5
  ea:	4f 90       	pop	r4
  ec:	3f 90       	pop	r3
  ee:	2f 90       	pop	r2
  f0:	08 95       	ret
  f2:	84 17       	cp	r24, r20
  f4:	95 07       	cpc	r25, r21
  f6:	00 f0       	brcs	.+0      	; 0xf8 <xStreamBufferSend+0xf8>
  f8:	00 c0       	rjmp	.+0      	; 0xfa <xStreamBufferSend+0xfa>
  fa:	4c 01       	movw	r8, r24
  fc:	00 c0       	rjmp	.+0      	; 0xfe <xStreamBufferSend+0xfe>
  fe:	ce 01       	movw	r24, r28
 100:	01 96       	adiw	r24, 0x01	; 1
 102:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferSend>
 106:	0f b6       	in	r0, 0x3f	; 63
 108:	f8 94       	cli
 10a:	0f 92       	push	r0
 10c:	c5 01       	movw	r24, r10
 10e:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferSend>
 112:	3c 01       	movw	r6, r24
 114:	88 15       	cp	r24, r8
 116:	99 05       	cpc	r25, r9
 118:	00 f4       	brcc	.+0      	; 0x11a <xStreamBufferSend+0x11a>
 11a:	f5 01       	movw	r30, r10
 11c:	67 85       	ldd	r22, Z+15	; 0x0f
 11e:	90 e0       	ldi	r25, 0x00	; 0
 120:	80 e0       	ldi	r24, 0x00	; 0
 122:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferSend>
 126:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferSend>
 12a:	f5 01       	movw	r30, r10
 12c:	93 87       	std	Z+11, r25	; 0x0b
 12e:	82 87       	std	Z+10, r24	; 0x0a
 130:	0f 90       	pop	r0
 132:	0f be       	out	0x3f, r0	; 63
 134:	cc 80       	ldd	r12, Y+4	; 0x04
 136:	dd 80       	ldd	r13, Y+5	; 0x05
 138:	f1 2c       	mov	r15, r1
 13a:	e1 2c       	mov	r14, r1
 13c:	00 e0       	ldi	r16, 0x00	; 0
 13e:	10 e0       	ldi	r17, 0x00	; 0
 140:	98 01       	movw	r18, r16
 142:	40 e0       	ldi	r20, 0x00	; 0
 144:	50 e0       	ldi	r21, 0x00	; 0
 146:	ba 01       	movw	r22, r20
 148:	87 85       	ldd	r24, Z+15	; 0x0f
 14a:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferSend>
 14e:	f5 01       	movw	r30, r10
 150:	13 86       	std	Z+11, r1	; 0x0b
 152:	12 86       	std	Z+10, r1	; 0x0a
 154:	be 01       	movw	r22, r28
 156:	6c 5f       	subi	r22, 0xFC	; 252
 158:	7f 4f       	sbci	r23, 0xFF	; 255
 15a:	ce 01       	movw	r24, r28
 15c:	01 96       	adiw	r24, 0x01	; 1
 15e:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferSend>
 162:	88 23       	and	r24, r24
 164:	01 f0       	breq	.+0      	; 0x166 <xStreamBufferSend+0x166>
 166:	61 14       	cp	r6, r1
 168:	71 04       	cpc	r7, r1
 16a:	01 f4       	brne	.+0      	; 0x16c <xStreamBufferSend+0x16c>
 16c:	00 c0       	rjmp	.+0      	; 0x16e <xStreamBufferSend+0x16e>
 16e:	00 c0       	rjmp	.+0      	; 0x170 <xStreamBufferSend+0x170>
 170:	0f 90       	pop	r0
 172:	0f be       	out	0x3f, r0	; 63
 174:	00 c0       	rjmp	.+0      	; 0x176 <__SREG__+0x137>

Disassembly of section .text.hot.xStreamBufferSendFromISR:

00000000 <xStreamBufferSendFromISR>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	af 92       	push	r10
   2:	bf 92       	push	r11

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	cf 92       	push	r12
   6:	df 92       	push	r13
   8:	ef 92       	push	r14
   a:	ff 92       	push	r15
   c:	0f 93       	push	r16
   e:	1f 93       	push	r17
  10:	cf 93       	push	r28
  12:	df 93       	push	r29
  14:	ec 01       	movw	r28, r24
  16:	5b 01       	movw	r10, r22
  18:	7a 01       	movw	r14, r20
  1a:	69 01       	movw	r12, r18
  1c:	8e 85       	ldd	r24, Y+14	; 0x0e
  1e:	8a 01       	movw	r16, r20
  20:	80 ff       	sbrs	r24, 0
  22:	00 c0       	rjmp	.+0      	; 0x24 <xStreamBufferSendFromISR+0x24>
  24:	0e 5f       	subi	r16, 0xFE	; 254
  26:	1f 4f       	sbci	r17, 0xFF	; 255
  28:	ce 01       	movw	r24, r28
  2a:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferSendFromISR>
  2e:	9c 01       	movw	r18, r24
  30:	a7 01       	movw	r20, r14
  32:	b5 01       	movw	r22, r10
  34:	ce 01       	movw	r24, r28
  36:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferSendFromISR>
  3a:	5c 01       	movw	r10, r24
  3c:	89 2b       	or	r24, r25
  3e:	01 f0       	breq	.+0      	; 0x40 <xStreamBufferSendFromISR+0x40>
  40:	ce 01       	movw	r24, r28
  42:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferSendFromISR>
  46:	2e 81       	ldd	r18, Y+6	; 0x06
  48:	3f 81       	ldd	r19, Y+7	; 0x07
  4a:	82 17       	cp	r24, r18
  4c:	93 07       	cpc	r25, r19
  4e:	00 f0       	brcs	.+0      	; 0x50 <xStreamBufferSendFromISR+0x50>
  50:	88 85       	ldd	r24, Y+8	; 0x08
  52:	99 85       	ldd	r25, Y+9	; 0x09
  54:	89 2b       	or	r24, r25
  56:	01 f0       	breq	.+0      	; 0x58 <xStreamBufferSendFromISR+0x58>
  58:	88 85       	ldd	r24, Y+8	; 0x08
  5a:	99 85       	ldd	r25, Y+9	; 0x09
  5c:	f1 2c       	mov	r15, r1
  5e:	e1 2c       	mov	r14, r1
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	00 e0       	ldi	r16, 0x00	; 0
  64:	20 e0       	ldi	r18, 0x00	; 0
  66:	30 e0       	ldi	r19, 0x00	; 0
  68:	a9 01       	movw	r20, r18
  6a:	6f 85       	ldd	r22, Y+15	; 0x0f
  6c:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferSendFromISR>
  70:	19 86       	std	Y+9, r1	; 0x09
  72:	18 86       	std	Y+8, r1	; 0x08
  74:	c5 01       	movw	r24, r10
  76:	df 91       	pop	r29
  78:	cf 91       	pop	r28
  7a:	1f 91       	pop	r17
  7c:	0f 91       	pop	r16
  7e:	ff 90       	pop	r15
  80:	ef 90       	pop	r14
  82:	df 90       	pop	r13
  84:	cf 90       	pop	r12
  86:	bf 90       	pop	r11
  88:	af 90       	pop	r10
  8a:	08 95       	ret

Disassembly of section .text.hot.xStreamBufferReceive:

00000000 <xStreamBufferReceive>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	6f 92       	push	r6
   2:	7f 92       	push	r7

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	8f 92       	push	r8
   6:	9f 92       	push	r9
   8:	af 92       	push	r10
   a:	bf 92       	push	r11
   c:	cf 92       	push	r12
   e:	df 92       	push	r13
  10:	ef 92       	push	r14
  12:	ff 92       	push	r15
  14:	0f 93       	push	r16
  16:	1f 93       	push	r17
  18:	cf 93       	push	r28
  1a:	df 93       	push	r29
  1c:	ec 01       	movw	r28, r24
  1e:	4b 01       	movw	r8, r22
  20:	3a 01       	movw	r6, r20
  22:	69 01       	movw	r12, r18
  24:	8e 85       	ldd	r24, Y+14	; 0x0e
  26:	80 fd       	sbrc	r24, 0
  28:	00 c0       	rjmp	.+0      	; 0x2a <xStreamBufferReceive+0x2a>
  2a:	b1 2c       	mov	r11, r1
  2c:	a1 2c       	mov	r10, r1
  2e:	82 ff       	sbrs	r24, 2
  30:	00 c0       	rjmp	.+0      	; 0x32 <xStreamBufferReceive+0x32>
  32:	ae 80       	ldd	r10, Y+6	; 0x06
  34:	bf 80       	ldd	r11, Y+7	; 0x07
  36:	c1 14       	cp	r12, r1
  38:	d1 04       	cpc	r13, r1
  3a:	01 f0       	breq	.+0      	; 0x3c <xStreamBufferReceive+0x3c>
  3c:	0f b6       	in	r0, 0x3f	; 63
  3e:	f8 94       	cli
  40:	0f 92       	push	r0
  42:	ce 01       	movw	r24, r28
  44:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferReceive>
  48:	8c 01       	movw	r16, r24
  4a:	a8 16       	cp	r10, r24
  4c:	b9 06       	cpc	r11, r25
  4e:	00 f0       	brcs	.+0      	; 0x50 <xStreamBufferReceive+0x50>
  50:	6f 85       	ldd	r22, Y+15	; 0x0f
  52:	90 e0       	ldi	r25, 0x00	; 0
  54:	80 e0       	ldi	r24, 0x00	; 0
  56:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferReceive>
  5a:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferReceive>
  5e:	99 87       	std	Y+9, r25	; 0x09
  60:	88 87       	std	Y+8, r24	; 0x08
  62:	0f 90       	pop	r0
  64:	0f be       	out	0x3f, r0	; 63
  66:	a0 16       	cp	r10, r16
  68:	b1 06       	cpc	r11, r17
  6a:	00 f0       	brcs	.+0      	; 0x6c <xStreamBufferReceive+0x6c>
  6c:	f1 2c       	mov	r15, r1
  6e:	e1 2c       	mov	r14, r1
  70:	00 e0       	ldi	r16, 0x00	; 0
  72:	10 e0       	ldi	r17, 0x00	; 0
  74:	98 01       	movw	r18, r16
  76:	40 e0       	ldi	r20, 0x00	; 0
  78:	50 e0       	ldi	r21, 0x00	; 0
  7a:	ba 01       	movw	r22, r20
  7c:	8f 85       	ldd	r24, Y+15	; 0x0f
  7e:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferReceive>
  82:	19 86       	std	Y+9, r1	; 0x09
  84:	18 86       	std	Y+8, r1	; 0x08
  86:	ce 01       	movw	r24, r28
  88:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferReceive>
  8c:	8c 01       	movw	r16, r24
  8e:	a8 16       	cp	r10, r24
  90:	b9 06       	cpc	r11, r25
  92:	00 f0       	brcs	.+0      	; 0x94 <xStreamBufferReceive+0x94>
  94:	b1 2c       	mov	r11, r1
  96:	a1 2c       	mov	r10, r1
  98:	c5 01       	movw	r24, r10
  9a:	df 91       	pop	r29
  9c:	cf 91       	pop	r28
  9e:	1f 91       	pop	r17
  a0:	0f 91       	pop	r16
  a2:	ff 90       	pop	r15
  a4:	ef 90       	pop	r14
  a6:	df 90       	pop	r13
  a8:	cf 90       	pop	r12
  aa:	bf 90       	pop	r11
  ac:	af 90       	pop	r10
  ae:	9f 90       	pop	r9
  b0:	8f 90       	pop	r8
  b2:	7f 90       	pop	r7
  b4:	6f 90       	pop	r6
  b6:	08 95       	ret
  b8:	82 e0       	ldi	r24, 0x02	; 2
  ba:	a8 2e       	mov	r10, r24
  bc:	b1 2c       	mov	r11, r1
  be:	00 c0       	rjmp	.+0      	; 0xc0 <xStreamBufferReceive+0xc0>
  c0:	98 01       	movw	r18, r16
  c2:	a3 01       	movw	r20, r6
  c4:	b4 01       	movw	r22, r8
  c6:	ce 01       	movw	r24, r28
  c8:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferReceive>
  cc:	5c 01       	movw	r10, r24
  ce:	89 2b       	or	r24, r25
  d0:	01 f0       	breq	.+0      	; 0xd2 <xStreamBufferReceive+0xd2>
  d2:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferReceive>
  d6:	8a 85       	ldd	r24, Y+10	; 0x0a
  d8:	9b 85       	ldd	r25, Y+11	; 0x0b
  da:	89 2b       	or	r24, r25
  dc:	01 f0       	breq	.+0      	; 0xde <xStreamBufferReceive+0xde>
  de:	8a 85       	ldd	r24, Y+10	; 0x0a
  e0:	9b 85       	ldd	r25, Y+11	; 0x0b
  e2:	f1 2c       	mov	r15, r1
  e4:	e1 2c       	mov	r14, r1
  e6:	10 e0       	ldi	r17, 0x00	; 0
  e8:	00 e0       	ldi	r16, 0x00	; 0
  ea:	20 e0       	ldi	r18, 0x00	; 0
  ec:	30 e0       	ldi	r19, 0x00	; 0
  ee:	a9 01       	movw	r20, r18
  f0:	6f 85       	ldd	r22, Y+15	; 0x0f
  f2:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferReceive>
  f6:	1b 86       	std	Y+11, r1	; 0x0b
  f8:	1a 86       	std	Y+10, r1	; 0x0a
  fa:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferReceive>
  fe:	00 c0       	rjmp	.+0      	; 0x100 <__SREG__+0xc1>

Disassembly of section .text.hot.xStreamBufferNextMessageLengthBytes:

00000000 <xStreamBufferNextMessageLengthBytes>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	00 d0       	rcall	.+0      	; 0xa <xStreamBufferNextMessageLengthBytes+0xa>
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	fc 01       	movw	r30, r24
  10:	26 85       	ldd	r18, Z+14	; 0x0e
  12:	20 fd       	sbrc	r18, 0
  14:	00 c0       	rjmp	.+0      	; 0x16 <xStreamBufferNextMessageLengthBytes+0x16>
  16:	90 e0       	ldi	r25, 0x00	; 0
  18:	80 e0       	ldi	r24, 0x00	; 0
  1a:	0f 90       	pop	r0
  1c:	0f 90       	pop	r0
  1e:	df 91       	pop	r29
  20:	cf 91       	pop	r28
  22:	1f 91       	pop	r17
  24:	0f 91       	pop	r16
  26:	08 95       	ret
  28:	8c 01       	movw	r16, r24
  2a:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferNextMessageLengthBytes>
  2e:	03 97       	sbiw	r24, 0x03	; 3
  30:	00 f0       	brcs	.+0      	; 0x32 <xStreamBufferNextMessageLengthBytes+0x32>
  32:	f8 01       	movw	r30, r16
  34:	20 81       	ld	r18, Z
  36:	31 81       	ldd	r19, Z+1	; 0x01
  38:	42 e0       	ldi	r20, 0x02	; 2
  3a:	50 e0       	ldi	r21, 0x00	; 0
  3c:	be 01       	movw	r22, r28
  3e:	6f 5f       	subi	r22, 0xFF	; 255
  40:	7f 4f       	sbci	r23, 0xFF	; 255
  42:	c8 01       	movw	r24, r16
  44:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferNextMessageLengthBytes>
  48:	89 81       	ldd	r24, Y+1	; 0x01
  4a:	9a 81       	ldd	r25, Y+2	; 0x02
  4c:	00 c0       	rjmp	.+0      	; 0x4e <__SREG__+0xf>

Disassembly of section .text.hot.xStreamBufferReceiveFromISR:

00000000 <xStreamBufferReceiveFromISR>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	af 92       	push	r10
   2:	bf 92       	push	r11

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	cf 92       	push	r12
   6:	df 92       	push	r13
   8:	ef 92       	push	r14
   a:	ff 92       	push	r15
   c:	0f 93       	push	r16
   e:	1f 93       	push	r17
  10:	cf 93       	push	r28
  12:	df 93       	push	r29
  14:	ec 01       	movw	r28, r24
  16:	5b 01       	movw	r10, r22
  18:	7a 01       	movw	r14, r20
  1a:	69 01       	movw	r12, r18
  1c:	8e 85       	ldd	r24, Y+14	; 0x0e
  1e:	10 e0       	ldi	r17, 0x00	; 0
  20:	00 e0       	ldi	r16, 0x00	; 0
  22:	80 ff       	sbrs	r24, 0
  24:	00 c0       	rjmp	.+0      	; 0x26 <xStreamBufferReceiveFromISR+0x26>
  26:	02 e0       	ldi	r16, 0x02	; 2
  28:	10 e0       	ldi	r17, 0x00	; 0
  2a:	ce 01       	movw	r24, r28
  2c:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferReceiveFromISR>
  30:	08 17       	cp	r16, r24
  32:	19 07       	cpc	r17, r25
  34:	00 f0       	brcs	.+0      	; 0x36 <xStreamBufferReceiveFromISR+0x36>
  36:	b1 2c       	mov	r11, r1
  38:	a1 2c       	mov	r10, r1
  3a:	c5 01       	movw	r24, r10
  3c:	df 91       	pop	r29
  3e:	cf 91       	pop	r28
  40:	1f 91       	pop	r17
  42:	0f 91       	pop	r16
  44:	ff 90       	pop	r15
  46:	ef 90       	pop	r14
  48:	df 90       	pop	r13
  4a:	cf 90       	pop	r12
  4c:	bf 90       	pop	r11
  4e:	af 90       	pop	r10
  50:	08 95       	ret
  52:	9c 01       	movw	r18, r24
  54:	a7 01       	movw	r20, r14
  56:	b5 01       	movw	r22, r10
  58:	ce 01       	movw	r24, r28
  5a:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferReceiveFromISR>
  5e:	5c 01       	movw	r10, r24
  60:	89 2b       	or	r24, r25
  62:	01 f0       	breq	.+0      	; 0x64 <xStreamBufferReceiveFromISR+0x64>
  64:	8a 85       	ldd	r24, Y+10	; 0x0a
  66:	9b 85       	ldd	r25, Y+11	; 0x0b
  68:	89 2b       	or	r24, r25
  6a:	01 f0       	breq	.+0      	; 0x6c <xStreamBufferReceiveFromISR+0x6c>
  6c:	8a 85       	ldd	r24, Y+10	; 0x0a
  6e:	9b 85       	ldd	r25, Y+11	; 0x0b
  70:	f1 2c       	mov	r15, r1
  72:	e1 2c       	mov	r14, r1
  74:	10 e0       	ldi	r17, 0x00	; 0
  76:	00 e0       	ldi	r16, 0x00	; 0
  78:	20 e0       	ldi	r18, 0x00	; 0
  7a:	30 e0       	ldi	r19, 0x00	; 0
  7c:	a9 01       	movw	r20, r18
  7e:	6f 85       	ldd	r22, Y+15	; 0x0f
  80:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferReceiveFromISR>
  84:	1b 86       	std	Y+11, r1	; 0x0b
  86:	1a 86       	std	Y+10, r1	; 0x0a
  88:	00 c0       	rjmp	.+0      	; 0x8a <__SREG__+0x4b>

Disassembly of section .text.hot.xStreamBufferIsEmpty:

00000000 <xStreamBufferIsEmpty>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	fc 01       	movw	r30, r24
   2:	20 81       	ld	r18, Z

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	31 81       	ldd	r19, Z+1	; 0x01
   6:	42 81       	ldd	r20, Z+2	; 0x02
   8:	53 81       	ldd	r21, Z+3	; 0x03
   a:	81 e0       	ldi	r24, 0x01	; 1
   c:	42 17       	cp	r20, r18
   e:	53 07       	cpc	r21, r19
  10:	01 f0       	breq	.+0      	; 0x12 <xStreamBufferIsEmpty+0x12>
  12:	80 e0       	ldi	r24, 0x00	; 0
  14:	08 95       	ret

Disassembly of section .text.hot.xStreamBufferIsFull:

00000000 <xStreamBufferIsFull>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	cf 93       	push	r28
   2:	df 93       	push	r29

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	fc 01       	movw	r30, r24
   6:	26 85       	ldd	r18, Z+14	; 0x0e
   8:	d0 e0       	ldi	r29, 0x00	; 0
   a:	c0 e0       	ldi	r28, 0x00	; 0
   c:	20 ff       	sbrs	r18, 0
   e:	00 c0       	rjmp	.+0      	; 0x10 <xStreamBufferIsFull+0x10>
  10:	c2 e0       	ldi	r28, 0x02	; 2
  12:	d0 e0       	ldi	r29, 0x00	; 0
  14:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferIsFull>
  18:	21 e0       	ldi	r18, 0x01	; 1
  1a:	c8 17       	cp	r28, r24
  1c:	d9 07       	cpc	r29, r25
  1e:	00 f4       	brcc	.+0      	; 0x20 <xStreamBufferIsFull+0x20>
  20:	20 e0       	ldi	r18, 0x00	; 0
  22:	82 2f       	mov	r24, r18
  24:	df 91       	pop	r29
  26:	cf 91       	pop	r28
  28:	08 95       	ret

Disassembly of section .text.hot.xStreamBufferSendCompletedFromISR:

00000000 <xStreamBufferSendCompletedFromISR>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	cf 92       	push	r12
   2:	df 92       	push	r13

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	fc 01       	movw	r30, r24
  12:	20 85       	ldd	r18, Z+8	; 0x08
  14:	31 85       	ldd	r19, Z+9	; 0x09
  16:	23 2b       	or	r18, r19
  18:	01 f0       	breq	.+0      	; 0x1a <xStreamBufferSendCompletedFromISR+0x1a>
  1a:	6b 01       	movw	r12, r22
  1c:	ec 01       	movw	r28, r24
  1e:	80 85       	ldd	r24, Z+8	; 0x08
  20:	91 85       	ldd	r25, Z+9	; 0x09
  22:	f1 2c       	mov	r15, r1
  24:	e1 2c       	mov	r14, r1
  26:	10 e0       	ldi	r17, 0x00	; 0
  28:	00 e0       	ldi	r16, 0x00	; 0
  2a:	20 e0       	ldi	r18, 0x00	; 0
  2c:	30 e0       	ldi	r19, 0x00	; 0
  2e:	a9 01       	movw	r20, r18
  30:	67 85       	ldd	r22, Z+15	; 0x0f
  32:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferSendCompletedFromISR>
  36:	19 86       	std	Y+9, r1	; 0x09
  38:	18 86       	std	Y+8, r1	; 0x08
  3a:	81 e0       	ldi	r24, 0x01	; 1
  3c:	df 91       	pop	r29
  3e:	cf 91       	pop	r28
  40:	1f 91       	pop	r17
  42:	0f 91       	pop	r16
  44:	ff 90       	pop	r15
  46:	ef 90       	pop	r14
  48:	df 90       	pop	r13
  4a:	cf 90       	pop	r12
  4c:	08 95       	ret
  4e:	80 e0       	ldi	r24, 0x00	; 0
  50:	00 c0       	rjmp	.+0      	; 0x52 <__SREG__+0x13>

Disassembly of section .text.hot.xStreamBufferReceiveCompletedFromISR:

00000000 <xStreamBufferReceiveCompletedFromISR>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	cf 92       	push	r12
   2:	df 92       	push	r13

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	fc 01       	movw	r30, r24
  12:	22 85       	ldd	r18, Z+10	; 0x0a
  14:	33 85       	ldd	r19, Z+11	; 0x0b
  16:	23 2b       	or	r18, r19
  18:	01 f0       	breq	.+0      	; 0x1a <xStreamBufferReceiveCompletedFromISR+0x1a>
  1a:	6b 01       	movw	r12, r22
  1c:	ec 01       	movw	r28, r24
  1e:	82 85       	ldd	r24, Z+10	; 0x0a
  20:	93 85       	ldd	r25, Z+11	; 0x0b
  22:	f1 2c       	mov	r15, r1
  24:	e1 2c       	mov	r14, r1
  26:	10 e0       	ldi	r17, 0x00	; 0
  28:	00 e0       	ldi	r16, 0x00	; 0
  2a:	20 e0       	ldi	r18, 0x00	; 0
  2c:	30 e0       	ldi	r19, 0x00	; 0
  2e:	a9 01       	movw	r20, r18
  30:	67 85       	ldd	r22, Z+15	; 0x0f
  32:	0e 94 00 00 	call	0	; 0x0 <xStreamBufferReceiveCompletedFromISR>
  36:	1b 86       	std	Y+11, r1	; 0x0b
  38:	1a 86       	std	Y+10, r1	; 0x0a
  3a:	81 e0       	ldi	r24, 0x01	; 1
  3c:	df 91       	pop	r29
  3e:	cf 91       	pop	r28
  40:	1f 91       	pop	r17
  42:	0f 91       	pop	r16
  44:	ff 90       	pop	r15
  46:	ef 90       	pop	r14
  48:	df 90       	pop	r13
  4a:	cf 90       	pop	r12
  4c:	08 95       	ret
  4e:	80 e0       	ldi	r24, 0x00	; 0
  50:	00 c0       	rjmp	.+0      	; 0x52 <__SREG__+0x13>

Disassembly of section .text.hot.uxStreamBufferGetStreamBufferNotificationIndex:

00000000 <uxStreamBufferGetStreamBufferNotificationIndex>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	fc 01       	movw	r30, r24
   2:	87 85       	ldd	r24, Z+15	; 0x0f

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	08 95       	ret

Disassembly of section .text.hot.vStreamBufferSetStreamBufferNotificationIndex:

00000000 <vStreamBufferSetStreamBufferNotificationIndex>:
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
   0:	fc 01       	movw	r30, r24
   2:	67 87       	std	Z+15, r22	; 0x0f

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
   4:	08 95       	ret

tasks.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00003cd8  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000035ee  00000000  00000000  00003d0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.hot.prvResetNextTaskUnblockTime 00000030  00000000  00000000  000072fa  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.hot.prvAddCurrentTaskToDelayedList 00000120  00000000  00000000  0000732a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.hot.prvCheckTasksWaitingTermination 00000054  00000000  00000000  0000744a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.prvIdleTask 00000016  00000000  00000000  0000749e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.hot.xTaskCreate 00000256  00000000  00000000  000074b4  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.hot.vTaskDelete 000000ba  00000000  00000000  0000770a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.hot.uxTaskPriorityGet 0000001c  00000000  00000000  000077c4  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text.hot.uxTaskPriorityGetFromISR 00000012  00000000  00000000  000077e0  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.hot.uxTaskBasePriorityGet 0000001c  00000000  00000000  000077f2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text.hot.uxTaskBasePriorityGetFromISR 00000012  00000000  00000000  0000780e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text.hot.vTaskPrioritySet 00000112  00000000  00000000  00007820  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 16 .text.hot.vTaskResume 000000d6  00000000  00000000  00007932  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 17 .text.hot.xTaskResumeFromISR 000000e0  00000000  00000000  00007a08  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 18 .rodata.str1.1 00000005  00000000  00000000  00007ae8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 19 .text.hot.vTaskStartScheduler 0000009a  00000000  00000000  00007aed  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 20 .text.hot.vTaskEndScheduler 00000022  00000000  00000000  00007b87  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 21 .text.hot.vTaskSuspendAll 0000000c  00000000  00000000  00007ba9  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 22 .text.hot.xTaskGetTickCount 00000014  00000000  00000000  00007bb5  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 23 .text.hot.xTaskGetTickCountFromISR 0000000a  00000000  00000000  00007bc9  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 24 .text.hot.uxTaskGetNumberOfTasks 00000006  00000000  00000000  00007bd3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 25 .text.hot.pcTaskGetName 00000010  00000000  00000000  00007bd9  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 26 .text.hot.xTaskIncrementTick 000001f8  00000000  00000000  00007be9  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 27 .text.hot.xTaskResumeAll 0000019a  00000000  00000000  00007de1  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 28 .text.hot.xTaskDelayUntil 00000066  00000000  00000000  00007f7b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 29 .text.hot.vTaskDelay 0000002a  00000000  00000000  00007fe1  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 30 .text.hot.xTaskCatchUpTicks 00000030  00000000  00000000  0000800b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 31 .text.hot.vTaskSwitchContext 000000c2  00000000  00000000  0000803b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 32 .text.hot.vTaskSuspend 000000aa  00000000  00000000  000080fd  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 33 .text.hot.vTaskPlaceOnEventList 00000022  00000000  00000000  000081a7  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 34 .text.hot.vTaskPlaceOnUnorderedEventList 0000008a  00000000  00000000  000081c9  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 35 .text.hot.vTaskPlaceOnEventListRestricted 00000090  00000000  00000000  00008253  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 36 .text.hot.xTaskRemoveFromEventList 0000014a  00000000  00000000  000082e3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 37 .text.hot.vTaskRemoveFromUnorderedEventList 0000010e  00000000  00000000  0000842d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 38 .text.hot.vTaskSetTimeOutState 00000020  00000000  00000000  0000853b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 39 .text.hot.vTaskInternalSetTimeOutState 00000016  00000000  00000000  0000855b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 40 .text.hot.xTaskCheckForTimeOut 00000062  00000000  00000000  00008571  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 41 .text.hot.vTaskMissedYield 00000008  00000000  00000000  000085d3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 42 .text.hot.uxTaskGetStackHighWaterMark 00000022  00000000  00000000  000085db  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 43 .text.hot.xTaskGetCurrentTaskHandle 0000000a  00000000  00000000  000085fd  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 44 .text.hot.xTaskGetCurrentTaskHandleForCore 00000014  00000000  00000000  00008607  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 45 .text.hot.xTaskGetSchedulerState 0000001c  00000000  00000000  0000861b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 46 .text.hot.xTaskPriorityInherit 000000fc  00000000  00000000  00008637  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 47 .text.hot.xTaskPriorityDisinherit 000000ae  00000000  00000000  00008733  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 48 .text.hot.vTaskPriorityDisinheritAfterTimeout 000000c6  00000000  00000000  000087e1  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 49 .text.hot.uxTaskResetEventItemValue 0000002e  00000000  00000000  000088a7  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 50 .text.hot.pvTaskIncrementMutexHeldCount 00000016  00000000  00000000  000088d5  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 51 .text.hot.ulTaskGenericNotifyTake 00000104  00000000  00000000  000088eb  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 52 .text.hot.xTaskGenericNotifyWait 0000016e  00000000  00000000  000089ef  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 53 .text.hot.xTaskGenericNotify 000001ce  00000000  00000000  00008b5d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 54 .text.hot.xTaskGenericNotifyFromISR 0000021e  00000000  00000000  00008d2b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 55 .text.hot.vTaskGenericNotifyGiveFromISR 00000156  00000000  00000000  00008f49  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 56 .text.hot.xTaskGenericNotifyStateClear 0000002c  00000000  00000000  0000909f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 57 .text.hot.ulTaskGenericNotifyValueClear 0000005c  00000000  00000000  000090cb  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 58 .text.hot.vTaskResetState 00000042  00000000  00000000  00009127  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 59 .bss.uxSchedulerSuspended 00000001  00000000  00000000  00009169  2**0
                  ALLOC
 60 .data.uxTopUsedPriority 00000001  00000000  00000000  00009169  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 61 .bss.xIdleTaskHandles 00000002  00000000  00000000  0000916a  2**0
                  ALLOC
 62 .bss.xNextTaskUnblockTime 00000002  00000000  00000000  0000916a  2**0
                  ALLOC
 63 .bss.uxTaskNumber 00000001  00000000  00000000  0000916a  2**0
                  ALLOC
 64 .bss.xNumOfOverflows 00000001  00000000  00000000  0000916a  2**0
                  ALLOC
 65 .bss.xYieldPendings 00000001  00000000  00000000  0000916a  2**0
                  ALLOC
 66 .bss.xPendedTicks 00000002  00000000  00000000  0000916a  2**0
                  ALLOC
 67 .bss.xSchedulerRunning 00000001  00000000  00000000  0000916a  2**0
                  ALLOC
 68 .bss.uxTopReadyPriority 00000001  00000000  00000000  0000916a  2**0
                  ALLOC
 69 .bss.xTickCount 00000002  00000000  00000000  0000916a  2**0
                  ALLOC
 70 .bss.uxCurrentNumberOfTasks 00000001  00000000  00000000  0000916a  2**0
                  ALLOC
 71 .bss.xSuspendedTaskList 00000009  00000000  00000000  0000916a  2**0
                  ALLOC
 72 .bss.uxDeletedTasksWaitingCleanUp 00000001  00000000  00000000  0000916a  2**0
                  ALLOC
 73 .bss.xTasksWaitingTermination 00000009  00000000  00000000  0000916a  2**0
                  ALLOC
 74 .bss.xPendingReadyList 00000009  00000000  00000000  0000916a  2**0
                  ALLOC
 75 .bss.pxOverflowDelayedTaskList 00000002  00000000  00000000  0000916a  2**0
                  ALLOC
 76 .bss.pxDelayedTaskList 00000002  00000000  00000000  0000916a  2**0
                  ALLOC
 77 .bss.xDelayedTaskList2 00000009  00000000  00000000  0000916a  2**0
                  ALLOC
 78 .bss.xDelayedTaskList1 00000009  00000000  00000000  0000916a  2**0
                  ALLOC
 79 .bss.pxReadyTasksLists 00000024  00000000  00000000  0000916a  2**0
                  ALLOC
 80 .bss.pxCurrentTCB 00000002  00000000  00000000  0000916a  2**0
                  ALLOC
 81 .comment      00000012  00000000  00000000  0000916a  2**0
                  CONTENTS, READONLY

Disassembly of section .text.hot.prvResetNextTaskUnblockTime:

00000000 <prvResetNextTaskUnblockTime>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	80 81       	ld	r24, Z
   a:	81 11       	cpse	r24, r1
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	00 c0       	rjmp	.+0      	; 0xe <prvResetNextTaskUnblockTime+0xe>
   e:	8f ef       	ldi	r24, 0xFF	; 255
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	9f ef       	ldi	r25, 0xFF	; 255
  12:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
  16:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
    uxTopReadyPriority = tskIDLE_PRIORITY;
  1a:	08 95       	ret
    xSchedulerRunning = pdFALSE;
  1c:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xPendedTicks = ( TickType_t ) 0U;
  20:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  24:	05 80       	ldd	r0, Z+5	; 0x05
  26:	f6 81       	ldd	r31, Z+6	; 0x06

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	e0 2d       	mov	r30, r0
  2a:	80 81       	ld	r24, Z
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	91 81       	ldd	r25, Z+1	; 0x01
  2e:	00 c0       	rjmp	.+0      	; 0x30 <__zero_reg__+0x2f>

Disassembly of section .text.hot.prvAddCurrentTaskToDelayedList:

00000000 <prvAddCurrentTaskToDelayedList>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	bf 92       	push	r11
   2:	cf 92       	push	r12
   4:	df 92       	push	r13
   6:	ef 92       	push	r14
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	ff 92       	push	r15
   a:	0f 93       	push	r16
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	1f 93       	push	r17
   e:	cf 93       	push	r28
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	df 93       	push	r29
  12:	ec 01       	movw	r28, r24
  14:	b6 2e       	mov	r11, r22
  16:	c0 90 00 00 	lds	r12, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    uxTopReadyPriority = tskIDLE_PRIORITY;
  1a:	d0 90 00 00 	lds	r13, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xSchedulerRunning = pdFALSE;
  1e:	00 91 00 00 	lds	r16, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xPendedTicks = ( TickType_t ) 0U;
  22:	10 91 00 00 	lds	r17, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  26:	e0 90 00 00 	lds	r14, 0x0000	; 0x800000 <__SREG__+0x7fffc1>

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  2a:	f0 90 00 00 	lds	r15, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2e:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    uxTaskNumber = ( UBaseType_t ) 0U;
  32:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  36:	02 96       	adiw	r24, 0x02	; 2
  38:	0e 94 00 00 	call	0	; 0x0 <prvAddCurrentTaskToDelayedList>

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	cf 3f       	cpi	r28, 0xFF	; 255
  3e:	dc 07       	cpc	r29, r28
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	01 f0       	breq	.+0      	; 0x42 <prvAddCurrentTaskToDelayedList+0x42>
  42:	00 c0       	rjmp	.+0      	; 0x44 <prvAddCurrentTaskToDelayedList+0x44>
  44:	bb 20       	and	r11, r11
  46:	01 f4       	brne	.+0      	; 0x48 <prvAddCurrentTaskToDelayedList+0x48>
  48:	00 c0       	rjmp	.+0      	; 0x4a <prvAddCurrentTaskToDelayedList+0x4a>
  4a:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  4e:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  52:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  56:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  5a:	15 96       	adiw	r26, 0x05	; 5
  5c:	fc 93       	st	X, r31
  5e:	ee 93       	st	-X, r30
  60:	14 97       	sbiw	r26, 0x04	; 4
  62:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  66:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  6a:	84 81       	ldd	r24, Z+4	; 0x04
  6c:	95 81       	ldd	r25, Z+5	; 0x05
  6e:	17 96       	adiw	r26, 0x07	; 7
  70:	9c 93       	st	X, r25
  72:	8e 93       	st	-X, r24
  74:	16 97       	sbiw	r26, 0x06	; 6
  76:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  7a:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  7e:	a4 81       	ldd	r26, Z+4	; 0x04
  80:	b5 81       	ldd	r27, Z+5	; 0x05
  82:	02 96       	adiw	r24, 0x02	; 2
  84:	13 96       	adiw	r26, 0x03	; 3
  86:	9c 93       	st	X, r25
  88:	8e 93       	st	-X, r24
  8a:	12 97       	sbiw	r26, 0x02	; 2
  8c:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  90:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  94:	02 96       	adiw	r24, 0x02	; 2
  96:	95 83       	std	Z+5, r25	; 0x05
  98:	84 83       	std	Z+4, r24	; 0x04
  9a:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  9e:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  a2:	80 e0       	ldi	r24, 0x00	; 0
  a4:	90 e0       	ldi	r25, 0x00	; 0
  a6:	93 87       	std	Z+11, r25	; 0x0b
  a8:	82 87       	std	Z+10, r24	; 0x0a
  aa:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  ae:	8f 5f       	subi	r24, 0xFF	; 255
  b0:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  b4:	df 91       	pop	r29
  b6:	cf 91       	pop	r28
  b8:	1f 91       	pop	r17
  ba:	0f 91       	pop	r16
  bc:	ff 90       	pop	r15
  be:	ef 90       	pop	r14
  c0:	df 90       	pop	r13
  c2:	cf 90       	pop	r12
  c4:	bf 90       	pop	r11
  c6:	08 95       	ret
  c8:	cc 0d       	add	r28, r12
  ca:	dd 1d       	adc	r29, r13
  cc:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  d0:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  d4:	d3 83       	std	Z+3, r29	; 0x03
  d6:	c2 83       	std	Z+2, r28	; 0x02
  d8:	60 91 00 00 	lds	r22, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  dc:	70 91 00 00 	lds	r23, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  e0:	6e 5f       	subi	r22, 0xFE	; 254
  e2:	7f 4f       	sbci	r23, 0xFF	; 255
  e4:	cc 15       	cp	r28, r12
  e6:	dd 05       	cpc	r29, r13
  e8:	00 f4       	brcc	.+0      	; 0xea <prvAddCurrentTaskToDelayedList+0xea>
  ea:	c7 01       	movw	r24, r14
  ec:	df 91       	pop	r29
  ee:	cf 91       	pop	r28
  f0:	1f 91       	pop	r17
  f2:	0f 91       	pop	r16
  f4:	ff 90       	pop	r15
  f6:	ef 90       	pop	r14
  f8:	df 90       	pop	r13
  fa:	cf 90       	pop	r12
  fc:	bf 90       	pop	r11
  fe:	0c 94 00 00 	jmp	0	; 0x0 <prvAddCurrentTaskToDelayedList>
 102:	c8 01       	movw	r24, r16
 104:	0e 94 00 00 	call	0	; 0x0 <prvAddCurrentTaskToDelayedList>
 108:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 10c:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 110:	c8 17       	cp	r28, r24
 112:	d9 07       	cpc	r29, r25
 114:	00 f4       	brcc	.+0      	; 0x116 <prvAddCurrentTaskToDelayedList+0x116>
 116:	d0 93 00 00 	sts	0x0000, r29	; 0x800000 <__SREG__+0x7fffc1>
 11a:	c0 93 00 00 	sts	0x0000, r28	; 0x800000 <__SREG__+0x7fffc1>
 11e:	00 c0       	rjmp	.+0      	; 0x120 <__SREG__+0xe1>

Disassembly of section .text.hot.prvCheckTasksWaitingTermination:

00000000 <prvCheckTasksWaitingTermination>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	81 11       	cpse	r24, r1
   a:	00 c0       	rjmp	.+0      	; 0xc <prvCheckTasksWaitingTermination+0xc>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	df 91       	pop	r29
   e:	cf 91       	pop	r28
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	08 95       	ret
  12:	0f b6       	in	r0, 0x3f	; 63
  14:	f8 94       	cli
  16:	0f 92       	push	r0
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xSchedulerRunning = pdFALSE;
  1c:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xPendedTicks = ( TickType_t ) 0U;
  20:	c6 81       	ldd	r28, Z+6	; 0x06
  22:	d7 81       	ldd	r29, Z+7	; 0x07
  24:	ce 01       	movw	r24, r28
  26:	02 96       	adiw	r24, 0x02	; 2

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	0e 94 00 00 	call	0	; 0x0 <prvCheckTasksWaitingTermination>
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	81 50       	subi	r24, 0x01	; 1
  32:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  36:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  3a:	81 50       	subi	r24, 0x01	; 1

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	0f 90       	pop	r0
  42:	0f be       	out	0x3f, r0	; 63
  44:	8f 89       	ldd	r24, Y+23	; 0x17
  46:	98 8d       	ldd	r25, Y+24	; 0x18
  48:	0e 94 00 00 	call	0	; 0x0 <prvCheckTasksWaitingTermination>
  4c:	ce 01       	movw	r24, r28
  4e:	0e 94 00 00 	call	0	; 0x0 <prvCheckTasksWaitingTermination>
  52:	00 c0       	rjmp	.+0      	; 0x54 <__SREG__+0x15>

Disassembly of section .text.prvIdleTask:

00000000 <prvIdleTask>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	0e 94 00 00 	call	0	; 0x0 <prvIdleTask>
   4:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	82 30       	cpi	r24, 0x02	; 2
   a:	00 f0       	brcs	.+0      	; 0xc <prvIdleTask+0xc>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	0e 94 00 00 	call	0	; 0x0 <prvIdleTask>
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	0e 94 00 00 	call	0	; 0x0 <prvIdleTask>
  14:	00 c0       	rjmp	.+0      	; 0x16 <__zero_reg__+0x15>

Disassembly of section .text.hot.xTaskCreate:

00000000 <xTaskCreate>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	5f 92       	push	r5
   2:	6f 92       	push	r6
   4:	7f 92       	push	r7
   6:	8f 92       	push	r8
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	9f 92       	push	r9
   a:	af 92       	push	r10
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	bf 92       	push	r11
   e:	cf 92       	push	r12
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	df 92       	push	r13
  12:	ef 92       	push	r14
  14:	ff 92       	push	r15
  16:	0f 93       	push	r16
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	1f 93       	push	r17
  1a:	cf 93       	push	r28
    xSchedulerRunning = pdFALSE;
  1c:	df 93       	push	r29
  1e:	3c 01       	movw	r6, r24
    xPendedTicks = ( TickType_t ) 0U;
  20:	6b 01       	movw	r12, r22
  22:	5a 01       	movw	r10, r20
  24:	49 01       	movw	r8, r18
  26:	50 2e       	mov	r5, r16

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	ca 01       	movw	r24, r20
  2a:	0e 94 00 00 	call	0	; 0x0 <xTaskCreate>
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2e:	8c 01       	movw	r16, r24
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	89 2b       	or	r24, r25
  32:	01 f4       	brne	.+0      	; 0x34 <xTaskCreate+0x34>
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	00 c0       	rjmp	.+0      	; 0x36 <xTaskCreate+0x36>
  36:	80 e3       	ldi	r24, 0x30	; 48
  38:	90 e0       	ldi	r25, 0x00	; 0
  3a:	0e 94 00 00 	call	0	; 0x0 <xTaskCreate>

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3e:	ec 01       	movw	r28, r24
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	89 2b       	or	r24, r25
  42:	01 f4       	brne	.+0      	; 0x44 <xTaskCreate+0x44>
  44:	00 c0       	rjmp	.+0      	; 0x46 <xTaskCreate+0x46>
  46:	80 e3       	ldi	r24, 0x30	; 48
  48:	de 01       	movw	r26, r28
  4a:	1d 92       	st	X+, r1
  4c:	8a 95       	dec	r24
  4e:	01 f4       	brne	.+0      	; 0x50 <xTaskCreate+0x50>
  50:	18 8f       	std	Y+24, r17	; 0x18
  52:	0f 8b       	std	Y+23, r16	; 0x17
  54:	a5 01       	movw	r20, r10
  56:	65 ea       	ldi	r22, 0xA5	; 165
  58:	70 e0       	ldi	r23, 0x00	; 0
  5a:	c8 01       	movw	r24, r16
  5c:	0e 94 00 00 	call	0	; 0x0 <xTaskCreate>
  60:	b1 e0       	ldi	r27, 0x01	; 1
  62:	ab 1a       	sub	r10, r27
  64:	b1 08       	sbc	r11, r1
  66:	8f 89       	ldd	r24, Y+23	; 0x17
  68:	98 8d       	ldd	r25, Y+24	; 0x18
  6a:	a8 0e       	add	r10, r24
  6c:	b9 1e       	adc	r11, r25
  6e:	c1 14       	cp	r12, r1
  70:	d1 04       	cpc	r13, r1
  72:	01 f0       	breq	.+0      	; 0x74 <xTaskCreate+0x74>
  74:	00 c0       	rjmp	.+0      	; 0x76 <xTaskCreate+0x76>
  76:	05 2d       	mov	r16, r5
  78:	04 30       	cpi	r16, 0x04	; 4
  7a:	00 f0       	brcs	.+0      	; 0x7c <xTaskCreate+0x7c>
  7c:	03 e0       	ldi	r16, 0x03	; 3
  7e:	0e 8b       	std	Y+22, r16	; 0x16
  80:	09 a7       	std	Y+41, r16	; 0x29
  82:	6e 01       	movw	r12, r28
  84:	b2 e0       	ldi	r27, 0x02	; 2
  86:	cb 0e       	add	r12, r27
  88:	d1 1c       	adc	r13, r1
  8a:	c6 01       	movw	r24, r12
  8c:	0e 94 00 00 	call	0	; 0x0 <xTaskCreate>
  90:	ce 01       	movw	r24, r28
  92:	0c 96       	adiw	r24, 0x0c	; 12
  94:	0e 94 00 00 	call	0	; 0x0 <xTaskCreate>
  98:	d9 87       	std	Y+9, r29	; 0x09
  9a:	c8 87       	std	Y+8, r28	; 0x08
  9c:	84 e0       	ldi	r24, 0x04	; 4
  9e:	90 e0       	ldi	r25, 0x00	; 0
  a0:	80 1b       	sub	r24, r16
  a2:	91 09       	sbc	r25, r1
  a4:	9d 87       	std	Y+13, r25	; 0x0d
  a6:	8c 87       	std	Y+12, r24	; 0x0c
  a8:	db 8b       	std	Y+19, r29	; 0x13
  aa:	ca 8b       	std	Y+18, r28	; 0x12
  ac:	a4 01       	movw	r20, r8
  ae:	b3 01       	movw	r22, r6
  b0:	c5 01       	movw	r24, r10
  b2:	0e 94 00 00 	call	0	; 0x0 <xTaskCreate>
  b6:	99 83       	std	Y+1, r25	; 0x01
  b8:	88 83       	st	Y, r24
  ba:	e1 14       	cp	r14, r1
  bc:	f1 04       	cpc	r15, r1
  be:	01 f0       	breq	.+0      	; 0xc0 <xTaskCreate+0xc0>
  c0:	f7 01       	movw	r30, r14
  c2:	d1 83       	std	Z+1, r29	; 0x01
  c4:	c0 83       	st	Z, r28
  c6:	0f b6       	in	r0, 0x3f	; 63
  c8:	f8 94       	cli
  ca:	0f 92       	push	r0
  cc:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  d0:	8f 5f       	subi	r24, 0xFF	; 255
  d2:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  d6:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  da:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  de:	89 2b       	or	r24, r25
  e0:	01 f0       	breq	.+0      	; 0xe2 <xTaskCreate+0xe2>
  e2:	00 c0       	rjmp	.+0      	; 0xe4 <xTaskCreate+0xe4>
  e4:	d0 93 00 00 	sts	0x0000, r29	; 0x800000 <__SREG__+0x7fffc1>
  e8:	c0 93 00 00 	sts	0x0000, r28	; 0x800000 <__SREG__+0x7fffc1>
  ec:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  f0:	81 30       	cpi	r24, 0x01	; 1
  f2:	01 f4       	brne	.+0      	; 0xf4 <xTaskCreate+0xf4>
  f4:	80 e0       	ldi	r24, 0x00	; 0
  f6:	90 e0       	ldi	r25, 0x00	; 0
  f8:	0e 94 00 00 	call	0	; 0x0 <xTaskCreate>
  fc:	80 e0       	ldi	r24, 0x00	; 0
  fe:	90 e0       	ldi	r25, 0x00	; 0
 100:	0e 94 00 00 	call	0	; 0x0 <xTaskCreate>
 104:	80 e0       	ldi	r24, 0x00	; 0
 106:	90 e0       	ldi	r25, 0x00	; 0
 108:	0e 94 00 00 	call	0	; 0x0 <xTaskCreate>
 10c:	80 e0       	ldi	r24, 0x00	; 0
 10e:	90 e0       	ldi	r25, 0x00	; 0
 110:	0e 94 00 00 	call	0	; 0x0 <xTaskCreate>
 114:	80 e0       	ldi	r24, 0x00	; 0
 116:	90 e0       	ldi	r25, 0x00	; 0
 118:	0e 94 00 00 	call	0	; 0x0 <xTaskCreate>
 11c:	80 e0       	ldi	r24, 0x00	; 0
 11e:	90 e0       	ldi	r25, 0x00	; 0
 120:	0e 94 00 00 	call	0	; 0x0 <xTaskCreate>
 124:	80 e0       	ldi	r24, 0x00	; 0
 126:	90 e0       	ldi	r25, 0x00	; 0
 128:	0e 94 00 00 	call	0	; 0x0 <xTaskCreate>
 12c:	80 e0       	ldi	r24, 0x00	; 0
 12e:	90 e0       	ldi	r25, 0x00	; 0
 130:	0e 94 00 00 	call	0	; 0x0 <xTaskCreate>
 134:	80 e0       	ldi	r24, 0x00	; 0
 136:	90 e0       	ldi	r25, 0x00	; 0
 138:	0e 94 00 00 	call	0	; 0x0 <xTaskCreate>
 13c:	80 e0       	ldi	r24, 0x00	; 0
 13e:	90 e0       	ldi	r25, 0x00	; 0
 140:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
 144:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
 148:	80 e0       	ldi	r24, 0x00	; 0
 14a:	90 e0       	ldi	r25, 0x00	; 0
 14c:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
 150:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
 154:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 158:	8f 5f       	subi	r24, 0xFF	; 255
 15a:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
 15e:	ae 89       	ldd	r26, Y+22	; 0x16
 160:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 164:	8a 17       	cp	r24, r26
 166:	00 f4       	brcc	.+0      	; 0x168 <xTaskCreate+0x168>
 168:	a0 93 00 00 	sts	0x0000, r26	; 0x800000 <__SREG__+0x7fffc1>
 16c:	89 e0       	ldi	r24, 0x09	; 9
 16e:	8a 9f       	mul	r24, r26
 170:	d0 01       	movw	r26, r0
 172:	11 24       	eor	r1, r1
 174:	a0 50       	subi	r26, 0x00	; 0
 176:	b0 40       	sbci	r27, 0x00	; 0
 178:	11 96       	adiw	r26, 0x01	; 1
 17a:	0d 90       	ld	r0, X+
 17c:	bc 91       	ld	r27, X
 17e:	a0 2d       	mov	r26, r0
 180:	bd 83       	std	Y+5, r27	; 0x05
 182:	ac 83       	std	Y+4, r26	; 0x04
 184:	14 96       	adiw	r26, 0x04	; 4
 186:	2d 91       	ld	r18, X+
 188:	3c 91       	ld	r19, X
 18a:	15 97       	sbiw	r26, 0x05	; 5
 18c:	3f 83       	std	Y+7, r19	; 0x07
 18e:	2e 83       	std	Y+6, r18	; 0x06
 190:	14 96       	adiw	r26, 0x04	; 4
 192:	ed 91       	ld	r30, X+
 194:	fc 91       	ld	r31, X
 196:	15 97       	sbiw	r26, 0x05	; 5
 198:	d3 82       	std	Z+3, r13	; 0x03
 19a:	c2 82       	std	Z+2, r12	; 0x02
 19c:	15 96       	adiw	r26, 0x05	; 5
 19e:	dc 92       	st	X, r13
 1a0:	ce 92       	st	-X, r12
 1a2:	14 97       	sbiw	r26, 0x04	; 4
 1a4:	ee 89       	ldd	r30, Y+22	; 0x16
 1a6:	e8 9f       	mul	r30, r24
 1a8:	f0 01       	movw	r30, r0
 1aa:	11 24       	eor	r1, r1
 1ac:	e0 50       	subi	r30, 0x00	; 0
 1ae:	f0 40       	sbci	r31, 0x00	; 0
 1b0:	fb 87       	std	Y+11, r31	; 0x0b
 1b2:	ea 87       	std	Y+10, r30	; 0x0a
 1b4:	80 81       	ld	r24, Z
 1b6:	8f 5f       	subi	r24, 0xFF	; 255
 1b8:	80 83       	st	Z, r24
 1ba:	0f 90       	pop	r0
 1bc:	0f be       	out	0x3f, r0	; 63
 1be:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1c2:	88 23       	and	r24, r24
 1c4:	01 f0       	breq	.+0      	; 0x1c6 <xTaskCreate+0x1c6>
 1c6:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1ca:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1ce:	96 89       	ldd	r25, Z+22	; 0x16
 1d0:	8e 89       	ldd	r24, Y+22	; 0x16
 1d2:	98 17       	cp	r25, r24
 1d4:	00 f4       	brcc	.+0      	; 0x1d6 <xTaskCreate+0x1d6>
 1d6:	0e 94 00 00 	call	0	; 0x0 <xTaskCreate>
 1da:	81 e0       	ldi	r24, 0x01	; 1
 1dc:	00 c0       	rjmp	.+0      	; 0x1de <xTaskCreate+0x1de>
 1de:	c8 01       	movw	r24, r16
 1e0:	0e 94 00 00 	call	0	; 0x0 <xTaskCreate>
 1e4:	8f ef       	ldi	r24, 0xFF	; 255
 1e6:	df 91       	pop	r29
 1e8:	cf 91       	pop	r28
 1ea:	1f 91       	pop	r17
 1ec:	0f 91       	pop	r16
 1ee:	ff 90       	pop	r15
 1f0:	ef 90       	pop	r14
 1f2:	df 90       	pop	r13
 1f4:	cf 90       	pop	r12
 1f6:	bf 90       	pop	r11
 1f8:	af 90       	pop	r10
 1fa:	9f 90       	pop	r9
 1fc:	8f 90       	pop	r8
 1fe:	7f 90       	pop	r7
 200:	6f 90       	pop	r6
 202:	5f 90       	pop	r5
 204:	08 95       	ret
 206:	f6 01       	movw	r30, r12
 208:	ae 01       	movw	r20, r28
 20a:	47 5e       	subi	r20, 0xE7	; 231
 20c:	5f 4f       	sbci	r21, 0xFF	; 255
 20e:	c6 01       	movw	r24, r12
 210:	40 96       	adiw	r24, 0x10	; 16
 212:	21 91       	ld	r18, Z+
 214:	da 01       	movw	r26, r20
 216:	2d 93       	st	X+, r18
 218:	ad 01       	movw	r20, r26
 21a:	9f 01       	movw	r18, r30
 21c:	21 50       	subi	r18, 0x01	; 1
 21e:	31 09       	sbc	r19, r1
 220:	d9 01       	movw	r26, r18
 222:	2c 91       	ld	r18, X
 224:	22 23       	and	r18, r18
 226:	01 f0       	breq	.+0      	; 0x228 <xTaskCreate+0x228>
 228:	8e 17       	cp	r24, r30
 22a:	9f 07       	cpc	r25, r31
 22c:	01 f4       	brne	.+0      	; 0x22e <xTaskCreate+0x22e>
 22e:	18 a6       	std	Y+40, r1	; 0x28
 230:	00 c0       	rjmp	.+0      	; 0x232 <xTaskCreate+0x232>
 232:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 236:	81 11       	cpse	r24, r1
 238:	00 c0       	rjmp	.+0      	; 0x23a <xTaskCreate+0x23a>
 23a:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 23e:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 242:	9e 89       	ldd	r25, Y+22	; 0x16
 244:	86 89       	ldd	r24, Z+22	; 0x16
 246:	98 17       	cp	r25, r24
 248:	00 f4       	brcc	.+0      	; 0x24a <xTaskCreate+0x24a>
 24a:	00 c0       	rjmp	.+0      	; 0x24c <xTaskCreate+0x24c>
 24c:	d0 93 00 00 	sts	0x0000, r29	; 0x800000 <__SREG__+0x7fffc1>
 250:	c0 93 00 00 	sts	0x0000, r28	; 0x800000 <__SREG__+0x7fffc1>
 254:	00 c0       	rjmp	.+0      	; 0x256 <__SREG__+0x217>

Disassembly of section .text.hot.vTaskDelete:

00000000 <vTaskDelete>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	ec 01       	movw	r28, r24
   a:	0f b6       	in	r0, 0x3f	; 63
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	f8 94       	cli
   e:	0f 92       	push	r0
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	89 2b       	or	r24, r25
  12:	01 f4       	brne	.+0      	; 0x14 <vTaskDelete+0x14>
  14:	c0 91 00 00 	lds	r28, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	d0 91 00 00 	lds	r29, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xSchedulerRunning = pdFALSE;
  1c:	8e 01       	movw	r16, r28
  1e:	0e 5f       	subi	r16, 0xFE	; 254
    xPendedTicks = ( TickType_t ) 0U;
  20:	1f 4f       	sbci	r17, 0xFF	; 255
  22:	c8 01       	movw	r24, r16
  24:	0e 94 00 00 	call	0	; 0x0 <vTaskDelete>

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	8c 89       	ldd	r24, Y+20	; 0x14
  2a:	9d 89       	ldd	r25, Y+21	; 0x15
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	89 2b       	or	r24, r25
  2e:	01 f0       	breq	.+0      	; 0x30 <vTaskDelete+0x30>
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	ce 01       	movw	r24, r28
  32:	0c 96       	adiw	r24, 0x0c	; 12
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	0e 94 00 00 	call	0	; 0x0 <vTaskDelete>
  38:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	8f 5f       	subi	r24, 0xFF	; 255
  3e:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  42:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  46:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  4a:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  4e:	22 23       	and	r18, r18
  50:	01 f0       	breq	.+0      	; 0x52 <vTaskDelete+0x52>
  52:	8c 17       	cp	r24, r28
  54:	9d 07       	cpc	r25, r29
  56:	01 f4       	brne	.+0      	; 0x58 <vTaskDelete+0x58>
  58:	b8 01       	movw	r22, r16
  5a:	80 e0       	ldi	r24, 0x00	; 0
  5c:	90 e0       	ldi	r25, 0x00	; 0
  5e:	0e 94 00 00 	call	0	; 0x0 <vTaskDelete>
  62:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  66:	8f 5f       	subi	r24, 0xFF	; 255
  68:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  6c:	81 e0       	ldi	r24, 0x01	; 1
  6e:	0f 90       	pop	r0
  70:	0f be       	out	0x3f, r0	; 63
  72:	81 30       	cpi	r24, 0x01	; 1
  74:	01 f0       	breq	.+0      	; 0x76 <vTaskDelete+0x76>
  76:	8f 89       	ldd	r24, Y+23	; 0x17
  78:	98 8d       	ldd	r25, Y+24	; 0x18
  7a:	0e 94 00 00 	call	0	; 0x0 <vTaskDelete>
  7e:	ce 01       	movw	r24, r28
  80:	0e 94 00 00 	call	0	; 0x0 <vTaskDelete>
  84:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  88:	88 23       	and	r24, r24
  8a:	01 f0       	breq	.+0      	; 0x8c <vTaskDelete+0x8c>
  8c:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  90:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  94:	8c 17       	cp	r24, r28
  96:	9d 07       	cpc	r25, r29
  98:	01 f4       	brne	.+0      	; 0x9a <vTaskDelete+0x9a>
  9a:	0e 94 00 00 	call	0	; 0x0 <vTaskDelete>
  9e:	df 91       	pop	r29
  a0:	cf 91       	pop	r28
  a2:	1f 91       	pop	r17
  a4:	0f 91       	pop	r16
  a6:	08 95       	ret
  a8:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  ac:	81 50       	subi	r24, 0x01	; 1
  ae:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  b2:	0e 94 00 00 	call	0	; 0x0 <vTaskDelete>
  b6:	80 e0       	ldi	r24, 0x00	; 0
  b8:	00 c0       	rjmp	.+0      	; 0xba <__SREG__+0x7b>

Disassembly of section .text.hot.uxTaskPriorityGet:

00000000 <uxTaskPriorityGet>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	0f b6       	in	r0, 0x3f	; 63
   2:	f8 94       	cli
   4:	0f 92       	push	r0
   6:	00 97       	sbiw	r24, 0x00	; 0
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	01 f4       	brne	.+0      	; 0xa <uxTaskPriorityGet+0xa>
   a:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   e:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  12:	fc 01       	movw	r30, r24
  14:	86 89       	ldd	r24, Z+22	; 0x16
  16:	0f 90       	pop	r0
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	0f be       	out	0x3f, r0	; 63
  1a:	08 95       	ret

Disassembly of section .text.hot.uxTaskPriorityGetFromISR:

00000000 <uxTaskPriorityGetFromISR>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	00 97       	sbiw	r24, 0x00	; 0
   2:	01 f4       	brne	.+0      	; 0x4 <uxTaskPriorityGetFromISR+0x4>
   4:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	fc 01       	movw	r30, r24
   e:	86 89       	ldd	r24, Z+22	; 0x16
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	08 95       	ret

Disassembly of section .text.hot.uxTaskBasePriorityGet:

00000000 <uxTaskBasePriorityGet>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	0f b6       	in	r0, 0x3f	; 63
   2:	f8 94       	cli
   4:	0f 92       	push	r0
   6:	00 97       	sbiw	r24, 0x00	; 0
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	01 f4       	brne	.+0      	; 0xa <uxTaskBasePriorityGet+0xa>
   a:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   e:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  12:	fc 01       	movw	r30, r24
  14:	81 a5       	ldd	r24, Z+41	; 0x29
  16:	0f 90       	pop	r0
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	0f be       	out	0x3f, r0	; 63
  1a:	08 95       	ret

Disassembly of section .text.hot.uxTaskBasePriorityGetFromISR:

00000000 <uxTaskBasePriorityGetFromISR>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	00 97       	sbiw	r24, 0x00	; 0
   2:	01 f4       	brne	.+0      	; 0x4 <uxTaskBasePriorityGetFromISR+0x4>
   4:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	fc 01       	movw	r30, r24
   e:	81 a5       	ldd	r24, Z+41	; 0x29
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	08 95       	ret

Disassembly of section .text.hot.vTaskPrioritySet:

00000000 <vTaskPrioritySet>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	1f 93       	push	r17
   6:	cf 93       	push	r28
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	df 93       	push	r29
   a:	ec 01       	movw	r28, r24
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	64 30       	cpi	r22, 0x04	; 4
   e:	00 f0       	brcs	.+0      	; 0x10 <vTaskPrioritySet+0x10>
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	63 e0       	ldi	r22, 0x03	; 3
  12:	0f b6       	in	r0, 0x3f	; 63
  14:	f8 94       	cli
  16:	0f 92       	push	r0
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	20 97       	sbiw	r28, 0x00	; 0
  1a:	01 f4       	brne	.+0      	; 0x1c <vTaskPrioritySet+0x1c>
    xSchedulerRunning = pdFALSE;
  1c:	c0 91 00 00 	lds	r28, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xPendedTicks = ( TickType_t ) 0U;
  20:	d0 91 00 00 	lds	r29, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  24:	99 a5       	ldd	r25, Y+41	; 0x29
  26:	96 17       	cp	r25, r22

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	01 f4       	brne	.+0      	; 0x2a <vTaskPrioritySet+0x2a>
  2a:	00 c0       	rjmp	.+0      	; 0x2c <vTaskPrioritySet+0x2c>
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	96 17       	cp	r25, r22
  36:	00 f4       	brcc	.+0      	; 0x38 <vTaskPrioritySet+0x38>
  38:	2c 17       	cp	r18, r28
  3a:	3d 07       	cpc	r19, r29

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	01 f0       	breq	.+0      	; 0x3e <vTaskPrioritySet+0x3e>
  3e:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  42:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  46:	11 e0       	ldi	r17, 0x01	; 1
  48:	86 89       	ldd	r24, Z+22	; 0x16
  4a:	86 17       	cp	r24, r22
  4c:	00 f0       	brcs	.+0      	; 0x4e <vTaskPrioritySet+0x4e>
  4e:	10 e0       	ldi	r17, 0x00	; 0
  50:	00 c0       	rjmp	.+0      	; 0x52 <vTaskPrioritySet+0x52>
  52:	11 e0       	ldi	r17, 0x01	; 1
  54:	2c 17       	cp	r18, r28
  56:	3d 07       	cpc	r19, r29
  58:	01 f4       	brne	.+0      	; 0x5a <vTaskPrioritySet+0x5a>
  5a:	8e 89       	ldd	r24, Y+22	; 0x16
  5c:	98 17       	cp	r25, r24
  5e:	01 f0       	breq	.+0      	; 0x60 <vTaskPrioritySet+0x60>
  60:	86 17       	cp	r24, r22
  62:	00 f4       	brcc	.+0      	; 0x64 <vTaskPrioritySet+0x64>
  64:	6e 8b       	std	Y+22, r22	; 0x16
  66:	69 a7       	std	Y+41, r22	; 0x29
  68:	2c 85       	ldd	r18, Y+12	; 0x0c
  6a:	3d 85       	ldd	r19, Y+13	; 0x0d
  6c:	37 fd       	sbrc	r19, 7
  6e:	00 c0       	rjmp	.+0      	; 0x70 <vTaskPrioritySet+0x70>
  70:	24 e0       	ldi	r18, 0x04	; 4
  72:	30 e0       	ldi	r19, 0x00	; 0
  74:	26 1b       	sub	r18, r22
  76:	31 09       	sbc	r19, r1
  78:	3d 87       	std	Y+13, r19	; 0x0d
  7a:	2c 87       	std	Y+12, r18	; 0x0c
  7c:	29 e0       	ldi	r18, 0x09	; 9
  7e:	82 9f       	mul	r24, r18
  80:	c0 01       	movw	r24, r0
  82:	11 24       	eor	r1, r1
  84:	80 50       	subi	r24, 0x00	; 0
  86:	90 40       	sbci	r25, 0x00	; 0
  88:	2a 85       	ldd	r18, Y+10	; 0x0a
  8a:	3b 85       	ldd	r19, Y+11	; 0x0b
  8c:	28 17       	cp	r18, r24
  8e:	39 07       	cpc	r19, r25
  90:	01 f4       	brne	.+0      	; 0x92 <vTaskPrioritySet+0x92>
  92:	7e 01       	movw	r14, r28
  94:	82 e0       	ldi	r24, 0x02	; 2
  96:	e8 0e       	add	r14, r24
  98:	f1 1c       	adc	r15, r1
  9a:	c7 01       	movw	r24, r14
  9c:	0e 94 00 00 	call	0	; 0x0 <vTaskPrioritySet>
  a0:	ae 89       	ldd	r26, Y+22	; 0x16
  a2:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  a6:	8a 17       	cp	r24, r26
  a8:	00 f4       	brcc	.+0      	; 0xaa <vTaskPrioritySet+0xaa>
  aa:	a0 93 00 00 	sts	0x0000, r26	; 0x800000 <__SREG__+0x7fffc1>
  ae:	89 e0       	ldi	r24, 0x09	; 9
  b0:	8a 9f       	mul	r24, r26
  b2:	d0 01       	movw	r26, r0
  b4:	11 24       	eor	r1, r1
  b6:	a0 50       	subi	r26, 0x00	; 0
  b8:	b0 40       	sbci	r27, 0x00	; 0
  ba:	11 96       	adiw	r26, 0x01	; 1
  bc:	0d 90       	ld	r0, X+
  be:	bc 91       	ld	r27, X
  c0:	a0 2d       	mov	r26, r0
  c2:	bd 83       	std	Y+5, r27	; 0x05
  c4:	ac 83       	std	Y+4, r26	; 0x04
  c6:	14 96       	adiw	r26, 0x04	; 4
  c8:	2d 91       	ld	r18, X+
  ca:	3c 91       	ld	r19, X
  cc:	15 97       	sbiw	r26, 0x05	; 5
  ce:	3f 83       	std	Y+7, r19	; 0x07
  d0:	2e 83       	std	Y+6, r18	; 0x06
  d2:	14 96       	adiw	r26, 0x04	; 4
  d4:	ed 91       	ld	r30, X+
  d6:	fc 91       	ld	r31, X
  d8:	15 97       	sbiw	r26, 0x05	; 5
  da:	f3 82       	std	Z+3, r15	; 0x03
  dc:	e2 82       	std	Z+2, r14	; 0x02
  de:	15 96       	adiw	r26, 0x05	; 5
  e0:	fc 92       	st	X, r15
  e2:	ee 92       	st	-X, r14
  e4:	14 97       	sbiw	r26, 0x04	; 4
  e6:	ee 89       	ldd	r30, Y+22	; 0x16
  e8:	e8 9f       	mul	r30, r24
  ea:	f0 01       	movw	r30, r0
  ec:	11 24       	eor	r1, r1
  ee:	e0 50       	subi	r30, 0x00	; 0
  f0:	f0 40       	sbci	r31, 0x00	; 0
  f2:	fb 87       	std	Y+11, r31	; 0x0b
  f4:	ea 87       	std	Y+10, r30	; 0x0a
  f6:	80 81       	ld	r24, Z
  f8:	8f 5f       	subi	r24, 0xFF	; 255
  fa:	80 83       	st	Z, r24
  fc:	11 11       	cpse	r17, r1
  fe:	0e 94 00 00 	call	0	; 0x0 <vTaskPrioritySet>
 102:	0f 90       	pop	r0
 104:	0f be       	out	0x3f, r0	; 63
 106:	df 91       	pop	r29
 108:	cf 91       	pop	r28
 10a:	1f 91       	pop	r17
 10c:	ff 90       	pop	r15
 10e:	ef 90       	pop	r14
 110:	08 95       	ret

Disassembly of section .text.hot.vTaskResume:

00000000 <vTaskResume>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	ec 01       	movw	r28, r24
   a:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   e:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  12:	8c 17       	cp	r24, r28
  14:	9d 07       	cpc	r25, r29
  16:	01 f4       	brne	.+0      	; 0x18 <vTaskResume+0x18>
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	00 c0       	rjmp	.+0      	; 0x1a <vTaskResume+0x1a>
  1a:	20 97       	sbiw	r28, 0x00	; 0
    xSchedulerRunning = pdFALSE;
  1c:	01 f4       	brne	.+0      	; 0x1e <vTaskResume+0x1e>
  1e:	00 c0       	rjmp	.+0      	; 0x20 <vTaskResume+0x20>
    xPendedTicks = ( TickType_t ) 0U;
  20:	0f b6       	in	r0, 0x3f	; 63
  22:	f8 94       	cli
  24:	0f 92       	push	r0
  26:	8a 85       	ldd	r24, Y+10	; 0x0a

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	9b 85       	ldd	r25, Y+11	; 0x0b
  2a:	80 50       	subi	r24, 0x00	; 0
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	90 40       	sbci	r25, 0x00	; 0
  2e:	01 f0       	breq	.+0      	; 0x30 <vTaskResume+0x30>
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	00 c0       	rjmp	.+0      	; 0x32 <vTaskResume+0x32>
  32:	8c 89       	ldd	r24, Y+20	; 0x14
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	9d 89       	ldd	r25, Y+21	; 0x15
  36:	e0 e0       	ldi	r30, 0x00	; 0
  38:	80 30       	cpi	r24, 0x00	; 0
  3a:	9e 07       	cpc	r25, r30

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	01 f4       	brne	.+0      	; 0x3e <vTaskResume+0x3e>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <vTaskResume+0x40>
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	89 2b       	or	r24, r25
  42:	01 f0       	breq	.+0      	; 0x44 <vTaskResume+0x44>
  44:	00 c0       	rjmp	.+0      	; 0x46 <vTaskResume+0x46>
  46:	8f a5       	ldd	r24, Y+47	; 0x2f
  48:	81 30       	cpi	r24, 0x01	; 1
  4a:	01 f0       	breq	.+0      	; 0x4c <vTaskResume+0x4c>
  4c:	8e 01       	movw	r16, r28
  4e:	0e 5f       	subi	r16, 0xFE	; 254
  50:	1f 4f       	sbci	r17, 0xFF	; 255
  52:	c8 01       	movw	r24, r16
  54:	0e 94 00 00 	call	0	; 0x0 <vTaskResume>
  58:	ae 89       	ldd	r26, Y+22	; 0x16
  5a:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  5e:	8a 17       	cp	r24, r26
  60:	00 f4       	brcc	.+0      	; 0x62 <vTaskResume+0x62>
  62:	a0 93 00 00 	sts	0x0000, r26	; 0x800000 <__SREG__+0x7fffc1>
  66:	29 e0       	ldi	r18, 0x09	; 9
  68:	2a 9f       	mul	r18, r26
  6a:	d0 01       	movw	r26, r0
  6c:	11 24       	eor	r1, r1
  6e:	a0 50       	subi	r26, 0x00	; 0
  70:	b0 40       	sbci	r27, 0x00	; 0
  72:	11 96       	adiw	r26, 0x01	; 1
  74:	0d 90       	ld	r0, X+
  76:	bc 91       	ld	r27, X
  78:	a0 2d       	mov	r26, r0
  7a:	bd 83       	std	Y+5, r27	; 0x05
  7c:	ac 83       	std	Y+4, r26	; 0x04
  7e:	14 96       	adiw	r26, 0x04	; 4
  80:	8d 91       	ld	r24, X+
  82:	9c 91       	ld	r25, X
  84:	15 97       	sbiw	r26, 0x05	; 5
  86:	9f 83       	std	Y+7, r25	; 0x07
  88:	8e 83       	std	Y+6, r24	; 0x06
  8a:	14 96       	adiw	r26, 0x04	; 4
  8c:	8d 91       	ld	r24, X+
  8e:	9c 91       	ld	r25, X
  90:	15 97       	sbiw	r26, 0x05	; 5
  92:	fc 01       	movw	r30, r24
  94:	13 83       	std	Z+3, r17	; 0x03
  96:	02 83       	std	Z+2, r16	; 0x02
  98:	15 96       	adiw	r26, 0x05	; 5
  9a:	1c 93       	st	X, r17
  9c:	0e 93       	st	-X, r16
  9e:	14 97       	sbiw	r26, 0x04	; 4
  a0:	9e 89       	ldd	r25, Y+22	; 0x16
  a2:	92 9f       	mul	r25, r18
  a4:	f0 01       	movw	r30, r0
  a6:	11 24       	eor	r1, r1
  a8:	e0 50       	subi	r30, 0x00	; 0
  aa:	f0 40       	sbci	r31, 0x00	; 0
  ac:	fb 87       	std	Y+11, r31	; 0x0b
  ae:	ea 87       	std	Y+10, r30	; 0x0a
  b0:	80 81       	ld	r24, Z
  b2:	8f 5f       	subi	r24, 0xFF	; 255
  b4:	80 83       	st	Z, r24
  b6:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  ba:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  be:	86 89       	ldd	r24, Z+22	; 0x16
  c0:	89 17       	cp	r24, r25
  c2:	00 f4       	brcc	.+0      	; 0xc4 <vTaskResume+0xc4>
  c4:	0e 94 00 00 	call	0	; 0x0 <vTaskResume>
  c8:	0f 90       	pop	r0
  ca:	0f be       	out	0x3f, r0	; 63
  cc:	df 91       	pop	r29
  ce:	cf 91       	pop	r28
  d0:	1f 91       	pop	r17
  d2:	0f 91       	pop	r16
  d4:	08 95       	ret

Disassembly of section .text.hot.xTaskResumeFromISR:

00000000 <xTaskResumeFromISR>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	1f 93       	push	r17
   6:	cf 93       	push	r28
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	df 93       	push	r29
   a:	ec 01       	movw	r28, r24
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	8a 85       	ldd	r24, Y+10	; 0x0a
   e:	9b 85       	ldd	r25, Y+11	; 0x0b
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	80 50       	subi	r24, 0x00	; 0
  12:	90 40       	sbci	r25, 0x00	; 0
  14:	01 f0       	breq	.+0      	; 0x16 <xTaskResumeFromISR+0x16>
  16:	00 c0       	rjmp	.+0      	; 0x18 <xTaskResumeFromISR+0x18>
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	8c 89       	ldd	r24, Y+20	; 0x14
  1a:	9d 89       	ldd	r25, Y+21	; 0x15
    xSchedulerRunning = pdFALSE;
  1c:	20 e0       	ldi	r18, 0x00	; 0
  1e:	80 30       	cpi	r24, 0x00	; 0
    xPendedTicks = ( TickType_t ) 0U;
  20:	92 07       	cpc	r25, r18
  22:	01 f4       	brne	.+0      	; 0x24 <xTaskResumeFromISR+0x24>
  24:	00 c0       	rjmp	.+0      	; 0x26 <xTaskResumeFromISR+0x26>
  26:	89 2b       	or	r24, r25

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	01 f0       	breq	.+0      	; 0x2a <xTaskResumeFromISR+0x2a>
  2a:	00 c0       	rjmp	.+0      	; 0x2c <xTaskResumeFromISR+0x2c>
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	8f a5       	ldd	r24, Y+47	; 0x2f
  2e:	81 30       	cpi	r24, 0x01	; 1
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	01 f4       	brne	.+0      	; 0x32 <xTaskResumeFromISR+0x32>
  32:	00 c0       	rjmp	.+0      	; 0x34 <xTaskResumeFromISR+0x34>
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  38:	81 11       	cpse	r24, r1
  3a:	00 c0       	rjmp	.+0      	; 0x3c <xTaskResumeFromISR+0x3c>

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  44:	9e 89       	ldd	r25, Y+22	; 0x16
  46:	86 89       	ldd	r24, Z+22	; 0x16
  48:	10 e0       	ldi	r17, 0x00	; 0
  4a:	89 17       	cp	r24, r25
  4c:	00 f4       	brcc	.+0      	; 0x4e <xTaskResumeFromISR+0x4e>
  4e:	81 e0       	ldi	r24, 0x01	; 1
  50:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  54:	11 e0       	ldi	r17, 0x01	; 1
  56:	7e 01       	movw	r14, r28
  58:	82 e0       	ldi	r24, 0x02	; 2
  5a:	e8 0e       	add	r14, r24
  5c:	f1 1c       	adc	r15, r1
  5e:	c7 01       	movw	r24, r14
  60:	0e 94 00 00 	call	0	; 0x0 <xTaskResumeFromISR>
  64:	ae 89       	ldd	r26, Y+22	; 0x16
  66:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  6a:	8a 17       	cp	r24, r26
  6c:	00 f4       	brcc	.+0      	; 0x6e <xTaskResumeFromISR+0x6e>
  6e:	a0 93 00 00 	sts	0x0000, r26	; 0x800000 <__SREG__+0x7fffc1>
  72:	89 e0       	ldi	r24, 0x09	; 9
  74:	8a 9f       	mul	r24, r26
  76:	d0 01       	movw	r26, r0
  78:	11 24       	eor	r1, r1
  7a:	a0 50       	subi	r26, 0x00	; 0
  7c:	b0 40       	sbci	r27, 0x00	; 0
  7e:	11 96       	adiw	r26, 0x01	; 1
  80:	0d 90       	ld	r0, X+
  82:	bc 91       	ld	r27, X
  84:	a0 2d       	mov	r26, r0
  86:	bd 83       	std	Y+5, r27	; 0x05
  88:	ac 83       	std	Y+4, r26	; 0x04
  8a:	14 96       	adiw	r26, 0x04	; 4
  8c:	2d 91       	ld	r18, X+
  8e:	3c 91       	ld	r19, X
  90:	15 97       	sbiw	r26, 0x05	; 5
  92:	3f 83       	std	Y+7, r19	; 0x07
  94:	2e 83       	std	Y+6, r18	; 0x06
  96:	14 96       	adiw	r26, 0x04	; 4
  98:	ed 91       	ld	r30, X+
  9a:	fc 91       	ld	r31, X
  9c:	15 97       	sbiw	r26, 0x05	; 5
  9e:	f3 82       	std	Z+3, r15	; 0x03
  a0:	e2 82       	std	Z+2, r14	; 0x02
  a2:	15 96       	adiw	r26, 0x05	; 5
  a4:	fc 92       	st	X, r15
  a6:	ee 92       	st	-X, r14
  a8:	14 97       	sbiw	r26, 0x04	; 4
  aa:	ee 89       	ldd	r30, Y+22	; 0x16
  ac:	e8 9f       	mul	r30, r24
  ae:	f0 01       	movw	r30, r0
  b0:	11 24       	eor	r1, r1
  b2:	e0 50       	subi	r30, 0x00	; 0
  b4:	f0 40       	sbci	r31, 0x00	; 0
  b6:	fb 87       	std	Y+11, r31	; 0x0b
  b8:	ea 87       	std	Y+10, r30	; 0x0a
  ba:	80 81       	ld	r24, Z
  bc:	8f 5f       	subi	r24, 0xFF	; 255
  be:	80 83       	st	Z, r24
  c0:	81 2f       	mov	r24, r17
  c2:	df 91       	pop	r29
  c4:	cf 91       	pop	r28
  c6:	1f 91       	pop	r17
  c8:	ff 90       	pop	r15
  ca:	ef 90       	pop	r14
  cc:	08 95       	ret
  ce:	be 01       	movw	r22, r28
  d0:	64 5f       	subi	r22, 0xF4	; 244
  d2:	7f 4f       	sbci	r23, 0xFF	; 255
  d4:	80 e0       	ldi	r24, 0x00	; 0
  d6:	90 e0       	ldi	r25, 0x00	; 0
  d8:	0e 94 00 00 	call	0	; 0x0 <xTaskResumeFromISR>
  dc:	10 e0       	ldi	r17, 0x00	; 0
  de:	00 c0       	rjmp	.+0      	; 0xe0 <__SREG__+0xa1>

Disassembly of section .text.hot.vTaskStartScheduler:

00000000 <vTaskStartScheduler>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	cf 93       	push	r28
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	df 93       	push	r29
   a:	cd b7       	in	r28, 0x3d	; 61
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	de b7       	in	r29, 0x3e	; 62
   e:	60 97       	sbiw	r28, 0x10	; 16
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	0f b6       	in	r0, 0x3f	; 63
  12:	f8 94       	cli
  14:	de bf       	out	0x3e, r29	; 62
  16:	0f be       	out	0x3f, r0	; 63
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	cd bf       	out	0x3d, r28	; 61
  1a:	a0 e0       	ldi	r26, 0x00	; 0
    xSchedulerRunning = pdFALSE;
  1c:	b0 e0       	ldi	r27, 0x00	; 0
  1e:	fe 01       	movw	r30, r28
    xPendedTicks = ( TickType_t ) 0U;
  20:	31 96       	adiw	r30, 0x01	; 1
  22:	20 e0       	ldi	r18, 0x00	; 0
  24:	30 e0       	ldi	r19, 0x00	; 0
  26:	bf 01       	movw	r22, r30

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	8d 91       	ld	r24, X+
  2a:	81 93       	st	Z+, r24
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	88 23       	and	r24, r24
  2e:	01 f0       	breq	.+0      	; 0x30 <vTaskStartScheduler+0x30>
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	2a 17       	cp	r18, r26
  32:	3b 07       	cpc	r19, r27
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	01 f4       	brne	.+0      	; 0x36 <vTaskStartScheduler+0x36>
  36:	80 e0       	ldi	r24, 0x00	; 0
  38:	e8 2e       	mov	r14, r24
  3a:	80 e0       	ldi	r24, 0x00	; 0

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	f8 2e       	mov	r15, r24
  3e:	00 e0       	ldi	r16, 0x00	; 0
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	30 e0       	ldi	r19, 0x00	; 0
  42:	20 e0       	ldi	r18, 0x00	; 0
  44:	40 ec       	ldi	r20, 0xC0	; 192
  46:	50 e0       	ldi	r21, 0x00	; 0
  48:	80 e0       	ldi	r24, 0x00	; 0
  4a:	90 e0       	ldi	r25, 0x00	; 0
  4c:	0e 94 00 00 	call	0	; 0x0 <vTaskStartScheduler>
  50:	88 23       	and	r24, r24
  52:	01 f0       	breq	.+0      	; 0x54 <vTaskStartScheduler+0x54>
  54:	81 30       	cpi	r24, 0x01	; 1
  56:	01 f4       	brne	.+0      	; 0x58 <vTaskStartScheduler+0x58>
  58:	0e 94 00 00 	call	0	; 0x0 <vTaskStartScheduler>
  5c:	81 30       	cpi	r24, 0x01	; 1
  5e:	01 f4       	brne	.+0      	; 0x60 <vTaskStartScheduler+0x60>
  60:	f8 94       	cli
  62:	2f ef       	ldi	r18, 0xFF	; 255
  64:	3f ef       	ldi	r19, 0xFF	; 255
  66:	30 93 00 00 	sts	0x0000, r19	; 0x800000 <__SREG__+0x7fffc1>
  6a:	20 93 00 00 	sts	0x0000, r18	; 0x800000 <__SREG__+0x7fffc1>
  6e:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  72:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  76:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  7a:	0e 94 00 00 	call	0	; 0x0 <vTaskStartScheduler>
  7e:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  82:	60 96       	adiw	r28, 0x10	; 16
  84:	0f b6       	in	r0, 0x3f	; 63
  86:	f8 94       	cli
  88:	de bf       	out	0x3e, r29	; 62
  8a:	0f be       	out	0x3f, r0	; 63
  8c:	cd bf       	out	0x3d, r28	; 61
  8e:	df 91       	pop	r29
  90:	cf 91       	pop	r28
  92:	0f 91       	pop	r16
  94:	ff 90       	pop	r15
  96:	ef 90       	pop	r14
  98:	08 95       	ret

Disassembly of section .text.hot.vTaskEndScheduler:

00000000 <vTaskEndScheduler>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	0e 94 00 00 	call	0	; 0x0 <vTaskEndScheduler>
   4:	0e 94 00 00 	call	0	; 0x0 <vTaskEndScheduler>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	0e 94 00 00 	call	0	; 0x0 <vTaskEndScheduler>
  14:	0e 94 00 00 	call	0	; 0x0 <vTaskEndScheduler>
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	f8 94       	cli
  1a:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
    xSchedulerRunning = pdFALSE;
  1e:	0c 94 00 00 	jmp	0	; 0x0 <vTaskEndScheduler>

Disassembly of section .text.hot.vTaskSuspendAll:

00000000 <vTaskSuspendAll>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	8f 5f       	subi	r24, 0xFF	; 255
   6:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   a:	08 95       	ret

Disassembly of section .text.hot.xTaskGetTickCount:

00000000 <xTaskGetTickCount>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	0f b6       	in	r0, 0x3f	; 63
   2:	f8 94       	cli
   4:	0f 92       	push	r0
   6:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   a:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   e:	0f 90       	pop	r0
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	0f be       	out	0x3f, r0	; 63
  12:	08 95       	ret

Disassembly of section .text.hot.xTaskGetTickCountFromISR:

00000000 <xTaskGetTickCountFromISR>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	08 95       	ret

Disassembly of section .text.hot.uxTaskGetNumberOfTasks:

00000000 <uxTaskGetNumberOfTasks>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	08 95       	ret

Disassembly of section .text.hot.pcTaskGetName:

00000000 <pcTaskGetName>:
   0:	00 97       	sbiw	r24, 0x00	; 0
   2:	01 f4       	brne	.+0      	; 0x4 <pcTaskGetName+0x4>
   4:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	49 96       	adiw	r24, 0x19	; 25
   e:	08 95       	ret

Disassembly of section .text.hot.xTaskIncrementTick:

00000000 <xTaskIncrementTick>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  14:	81 11       	cpse	r24, r1
  16:	00 c0       	rjmp	.+0      	; 0x18 <xTaskIncrementTick+0x18>
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	c0 91 00 00 	lds	r28, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xSchedulerRunning = pdFALSE;
  1c:	d0 91 00 00 	lds	r29, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xPendedTicks = ( TickType_t ) 0U;
  20:	6e 01       	movw	r12, r28
  22:	8f ef       	ldi	r24, 0xFF	; 255
  24:	c8 1a       	sub	r12, r24
  26:	d8 0a       	sbc	r13, r24

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	d0 92 00 00 	sts	0x0000, r13	; 0x800000 <__SREG__+0x7fffc1>
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	c0 92 00 00 	sts	0x0000, r12	; 0x800000 <__SREG__+0x7fffc1>
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	c1 14       	cp	r12, r1
  32:	d1 04       	cpc	r13, r1
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	01 f4       	brne	.+0      	; 0x36 <xTaskIncrementTick+0x36>
  36:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  3a:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3e:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  42:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  46:	30 93 00 00 	sts	0x0000, r19	; 0x800000 <__SREG__+0x7fffc1>
  4a:	20 93 00 00 	sts	0x0000, r18	; 0x800000 <__SREG__+0x7fffc1>
  4e:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
  52:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  56:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  5a:	8f 5f       	subi	r24, 0xFF	; 255
  5c:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  60:	0e 94 00 00 	call	0	; 0x0 <xTaskIncrementTick>
  64:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  68:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  6c:	c8 16       	cp	r12, r24
  6e:	d9 06       	cpc	r13, r25
  70:	00 f4       	brcc	.+0      	; 0x72 <xTaskIncrementTick+0x72>
  72:	80 e0       	ldi	r24, 0x00	; 0
  74:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  78:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  7c:	e6 89       	ldd	r30, Z+22	; 0x16
  7e:	d9 e0       	ldi	r29, 0x09	; 9
  80:	ed 9f       	mul	r30, r29
  82:	f0 01       	movw	r30, r0
  84:	11 24       	eor	r1, r1
  86:	e0 50       	subi	r30, 0x00	; 0
  88:	f0 40       	sbci	r31, 0x00	; 0
  8a:	90 81       	ld	r25, Z
  8c:	92 30       	cpi	r25, 0x02	; 2
  8e:	00 f0       	brcs	.+0      	; 0x90 <xTaskIncrementTick+0x90>
  90:	81 e0       	ldi	r24, 0x01	; 1
  92:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  96:	91 11       	cpse	r25, r1
  98:	81 e0       	ldi	r24, 0x01	; 1
  9a:	df 91       	pop	r29
  9c:	cf 91       	pop	r28
  9e:	1f 91       	pop	r17
  a0:	0f 91       	pop	r16
  a2:	ff 90       	pop	r15
  a4:	ef 90       	pop	r14
  a6:	df 90       	pop	r13
  a8:	cf 90       	pop	r12
  aa:	08 95       	ret
  ac:	80 e0       	ldi	r24, 0x00	; 0
  ae:	69 e0       	ldi	r22, 0x09	; 9
  b0:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  b4:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  b8:	90 81       	ld	r25, Z
  ba:	91 11       	cpse	r25, r1
  bc:	00 c0       	rjmp	.+0      	; 0xbe <xTaskIncrementTick+0xbe>
  be:	2f ef       	ldi	r18, 0xFF	; 255
  c0:	3f ef       	ldi	r19, 0xFF	; 255
  c2:	30 93 00 00 	sts	0x0000, r19	; 0x800000 <__SREG__+0x7fffc1>
  c6:	20 93 00 00 	sts	0x0000, r18	; 0x800000 <__SREG__+0x7fffc1>
  ca:	00 c0       	rjmp	.+0      	; 0xcc <xTaskIncrementTick+0xcc>
  cc:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  d0:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  d4:	05 80       	ldd	r0, Z+5	; 0x05
  d6:	f6 81       	ldd	r31, Z+6	; 0x06
  d8:	e0 2d       	mov	r30, r0
  da:	06 80       	ldd	r0, Z+6	; 0x06
  dc:	f7 81       	ldd	r31, Z+7	; 0x07
  de:	e0 2d       	mov	r30, r0
  e0:	22 81       	ldd	r18, Z+2	; 0x02
  e2:	33 81       	ldd	r19, Z+3	; 0x03
  e4:	c2 16       	cp	r12, r18
  e6:	d3 06       	cpc	r13, r19
  e8:	00 f0       	brcs	.+0      	; 0xea <xTaskIncrementTick+0xea>
  ea:	c2 85       	ldd	r28, Z+10	; 0x0a
  ec:	d3 85       	ldd	r29, Z+11	; 0x0b
  ee:	24 81       	ldd	r18, Z+4	; 0x04
  f0:	35 81       	ldd	r19, Z+5	; 0x05
  f2:	46 81       	ldd	r20, Z+6	; 0x06
  f4:	57 81       	ldd	r21, Z+7	; 0x07
  f6:	d9 01       	movw	r26, r18
  f8:	15 96       	adiw	r26, 0x05	; 5
  fa:	5c 93       	st	X, r21
  fc:	4e 93       	st	-X, r20
  fe:	14 97       	sbiw	r26, 0x04	; 4
 100:	46 81       	ldd	r20, Z+6	; 0x06
 102:	57 81       	ldd	r21, Z+7	; 0x07
 104:	da 01       	movw	r26, r20
 106:	13 96       	adiw	r26, 0x03	; 3
 108:	3c 93       	st	X, r19
 10a:	2e 93       	st	-X, r18
 10c:	12 97       	sbiw	r26, 0x02	; 2
 10e:	9f 01       	movw	r18, r30
 110:	2e 5f       	subi	r18, 0xFE	; 254
 112:	3f 4f       	sbci	r19, 0xFF	; 255
 114:	09 81       	ldd	r16, Y+1	; 0x01
 116:	1a 81       	ldd	r17, Y+2	; 0x02
 118:	02 17       	cp	r16, r18
 11a:	13 07       	cpc	r17, r19
 11c:	01 f4       	brne	.+0      	; 0x11e <xTaskIncrementTick+0x11e>
 11e:	5a 83       	std	Y+2, r21	; 0x02
 120:	49 83       	std	Y+1, r20	; 0x01
 122:	13 86       	std	Z+11, r1	; 0x0b
 124:	12 86       	std	Z+10, r1	; 0x0a
 126:	98 81       	ld	r25, Y
 128:	91 50       	subi	r25, 0x01	; 1
 12a:	98 83       	st	Y, r25
 12c:	a4 89       	ldd	r26, Z+20	; 0x14
 12e:	b5 89       	ldd	r27, Z+21	; 0x15
 130:	10 97       	sbiw	r26, 0x00	; 0
 132:	01 f0       	breq	.+0      	; 0x134 <xTaskIncrementTick+0x134>
 134:	46 85       	ldd	r20, Z+14	; 0x0e
 136:	57 85       	ldd	r21, Z+15	; 0x0f
 138:	00 89       	ldd	r16, Z+16	; 0x10
 13a:	11 89       	ldd	r17, Z+17	; 0x11
 13c:	ea 01       	movw	r28, r20
 13e:	1d 83       	std	Y+5, r17	; 0x05
 140:	0c 83       	std	Y+4, r16	; 0x04
 142:	00 89       	ldd	r16, Z+16	; 0x10
 144:	11 89       	ldd	r17, Z+17	; 0x11
 146:	e8 01       	movw	r28, r16
 148:	5b 83       	std	Y+3, r21	; 0x03
 14a:	4a 83       	std	Y+2, r20	; 0x02
 14c:	11 96       	adiw	r26, 0x01	; 1
 14e:	ed 90       	ld	r14, X+
 150:	fc 90       	ld	r15, X
 152:	12 97       	sbiw	r26, 0x02	; 2
 154:	af 01       	movw	r20, r30
 156:	44 5f       	subi	r20, 0xF4	; 244
 158:	5f 4f       	sbci	r21, 0xFF	; 255
 15a:	e4 16       	cp	r14, r20
 15c:	f5 06       	cpc	r15, r21
 15e:	01 f4       	brne	.+0      	; 0x160 <xTaskIncrementTick+0x160>
 160:	12 96       	adiw	r26, 0x02	; 2
 162:	1c 93       	st	X, r17
 164:	0e 93       	st	-X, r16
 166:	11 97       	sbiw	r26, 0x01	; 1
 168:	15 8a       	std	Z+21, r1	; 0x15
 16a:	14 8a       	std	Z+20, r1	; 0x14
 16c:	9c 91       	ld	r25, X
 16e:	91 50       	subi	r25, 0x01	; 1
 170:	9c 93       	st	X, r25
 172:	a6 89       	ldd	r26, Z+22	; 0x16
 174:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 178:	9a 17       	cp	r25, r26
 17a:	00 f4       	brcc	.+0      	; 0x17c <xTaskIncrementTick+0x17c>
 17c:	a0 93 00 00 	sts	0x0000, r26	; 0x800000 <__SREG__+0x7fffc1>
 180:	6a 9f       	mul	r22, r26
 182:	d0 01       	movw	r26, r0
 184:	11 24       	eor	r1, r1
 186:	a0 50       	subi	r26, 0x00	; 0
 188:	b0 40       	sbci	r27, 0x00	; 0
 18a:	11 96       	adiw	r26, 0x01	; 1
 18c:	0d 90       	ld	r0, X+
 18e:	bc 91       	ld	r27, X
 190:	a0 2d       	mov	r26, r0
 192:	b5 83       	std	Z+5, r27	; 0x05
 194:	a4 83       	std	Z+4, r26	; 0x04
 196:	14 96       	adiw	r26, 0x04	; 4
 198:	4d 91       	ld	r20, X+
 19a:	5c 91       	ld	r21, X
 19c:	15 97       	sbiw	r26, 0x05	; 5
 19e:	57 83       	std	Z+7, r21	; 0x07
 1a0:	46 83       	std	Z+6, r20	; 0x06
 1a2:	14 96       	adiw	r26, 0x04	; 4
 1a4:	4d 91       	ld	r20, X+
 1a6:	5c 91       	ld	r21, X
 1a8:	15 97       	sbiw	r26, 0x05	; 5
 1aa:	ea 01       	movw	r28, r20
 1ac:	3b 83       	std	Y+3, r19	; 0x03
 1ae:	2a 83       	std	Y+2, r18	; 0x02
 1b0:	15 96       	adiw	r26, 0x05	; 5
 1b2:	3c 93       	st	X, r19
 1b4:	2e 93       	st	-X, r18
 1b6:	14 97       	sbiw	r26, 0x04	; 4
 1b8:	26 89       	ldd	r18, Z+22	; 0x16
 1ba:	26 9f       	mul	r18, r22
 1bc:	d0 01       	movw	r26, r0
 1be:	11 24       	eor	r1, r1
 1c0:	a0 50       	subi	r26, 0x00	; 0
 1c2:	b0 40       	sbci	r27, 0x00	; 0
 1c4:	b3 87       	std	Z+11, r27	; 0x0b
 1c6:	a2 87       	std	Z+10, r26	; 0x0a
 1c8:	9c 91       	ld	r25, X
 1ca:	9f 5f       	subi	r25, 0xFF	; 255
 1cc:	9c 93       	st	X, r25
 1ce:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1d2:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1d6:	96 89       	ldd	r25, Z+22	; 0x16
 1d8:	92 17       	cp	r25, r18
 1da:	00 f0       	brcs	.+0      	; 0x1dc <xTaskIncrementTick+0x1dc>
 1dc:	00 c0       	rjmp	.+0      	; 0x1de <xTaskIncrementTick+0x1de>
 1de:	81 e0       	ldi	r24, 0x01	; 1
 1e0:	00 c0       	rjmp	.+0      	; 0x1e2 <xTaskIncrementTick+0x1e2>
 1e2:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1e6:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1ea:	01 96       	adiw	r24, 0x01	; 1
 1ec:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
 1f0:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
 1f4:	80 e0       	ldi	r24, 0x00	; 0
 1f6:	00 c0       	rjmp	.+0      	; 0x1f8 <__SREG__+0x1b9>

Disassembly of section .text.hot.xTaskResumeAll:

00000000 <xTaskResumeAll>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	0f b6       	in	r0, 0x3f	; 63
   e:	f8 94       	cli
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	0f 92       	push	r0
  12:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  16:	81 50       	subi	r24, 0x01	; 1
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
    xSchedulerRunning = pdFALSE;
  1c:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xPendedTicks = ( TickType_t ) 0U;
  20:	88 23       	and	r24, r24
  22:	01 f0       	breq	.+0      	; 0x24 <xTaskResumeAll+0x24>
  24:	80 e0       	ldi	r24, 0x00	; 0
  26:	0f 90       	pop	r0

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	0f be       	out	0x3f, r0	; 63
  2a:	df 91       	pop	r29
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	cf 91       	pop	r28
  2e:	1f 91       	pop	r17
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	0f 91       	pop	r16
  32:	ff 90       	pop	r15
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	ef 90       	pop	r14
  36:	08 95       	ret
  38:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	88 23       	and	r24, r24
  3e:	01 f0       	breq	.+0      	; 0x40 <xTaskResumeAll+0x40>
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	e0 90 00 00 	lds	r14, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  44:	f0 90 00 00 	lds	r15, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  48:	f0 e0       	ldi	r31, 0x00	; 0
  4a:	e0 e0       	ldi	r30, 0x00	; 0
  4c:	39 e0       	ldi	r19, 0x09	; 9
  4e:	41 e0       	ldi	r20, 0x01	; 1
  50:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  54:	81 11       	cpse	r24, r1
  56:	00 c0       	rjmp	.+0      	; 0x58 <xTaskResumeAll+0x58>
  58:	ef 2b       	or	r30, r31
  5a:	01 f0       	breq	.+0      	; 0x5c <xTaskResumeAll+0x5c>
  5c:	0e 94 00 00 	call	0	; 0x0 <xTaskResumeAll>
  60:	c0 91 00 00 	lds	r28, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  64:	d0 91 00 00 	lds	r29, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  68:	20 97       	sbiw	r28, 0x00	; 0
  6a:	01 f0       	breq	.+0      	; 0x6c <xTaskResumeAll+0x6c>
  6c:	11 e0       	ldi	r17, 0x01	; 1
  6e:	0e 94 00 00 	call	0	; 0x0 <xTaskResumeAll>
  72:	81 11       	cpse	r24, r1
  74:	10 93 00 00 	sts	0x0000, r17	; 0x800000 <__SREG__+0x7fffc1>
  78:	21 97       	sbiw	r28, 0x01	; 1
  7a:	01 f4       	brne	.+0      	; 0x7c <xTaskResumeAll+0x7c>
  7c:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  80:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  84:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  88:	88 23       	and	r24, r24
  8a:	01 f0       	breq	.+0      	; 0x8c <xTaskResumeAll+0x8c>
  8c:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  90:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  94:	0e 94 00 00 	call	0	; 0x0 <xTaskResumeAll>
  98:	81 e0       	ldi	r24, 0x01	; 1
  9a:	00 c0       	rjmp	.+0      	; 0x9c <xTaskResumeAll+0x9c>
  9c:	d7 01       	movw	r26, r14
  9e:	16 96       	adiw	r26, 0x06	; 6
  a0:	ed 91       	ld	r30, X+
  a2:	fc 91       	ld	r31, X
  a4:	a4 89       	ldd	r26, Z+20	; 0x14
  a6:	b5 89       	ldd	r27, Z+21	; 0x15
  a8:	66 85       	ldd	r22, Z+14	; 0x0e
  aa:	77 85       	ldd	r23, Z+15	; 0x0f
  ac:	80 89       	ldd	r24, Z+16	; 0x10
  ae:	91 89       	ldd	r25, Z+17	; 0x11
  b0:	eb 01       	movw	r28, r22
  b2:	9d 83       	std	Y+5, r25	; 0x05
  b4:	8c 83       	std	Y+4, r24	; 0x04
  b6:	80 89       	ldd	r24, Z+16	; 0x10
  b8:	91 89       	ldd	r25, Z+17	; 0x11
  ba:	ec 01       	movw	r28, r24
  bc:	7b 83       	std	Y+3, r23	; 0x03
  be:	6a 83       	std	Y+2, r22	; 0x02
  c0:	bf 01       	movw	r22, r30
  c2:	64 5f       	subi	r22, 0xF4	; 244
  c4:	7f 4f       	sbci	r23, 0xFF	; 255
  c6:	11 96       	adiw	r26, 0x01	; 1
  c8:	0d 91       	ld	r16, X+
  ca:	1c 91       	ld	r17, X
  cc:	12 97       	sbiw	r26, 0x02	; 2
  ce:	06 17       	cp	r16, r22
  d0:	17 07       	cpc	r17, r23
  d2:	01 f4       	brne	.+0      	; 0xd4 <xTaskResumeAll+0xd4>
  d4:	12 96       	adiw	r26, 0x02	; 2
  d6:	9c 93       	st	X, r25
  d8:	8e 93       	st	-X, r24
  da:	11 97       	sbiw	r26, 0x01	; 1
  dc:	15 8a       	std	Z+21, r1	; 0x15
  de:	14 8a       	std	Z+20, r1	; 0x14
  e0:	8c 91       	ld	r24, X
  e2:	81 50       	subi	r24, 0x01	; 1
  e4:	8c 93       	st	X, r24
  e6:	a2 85       	ldd	r26, Z+10	; 0x0a
  e8:	b3 85       	ldd	r27, Z+11	; 0x0b
  ea:	84 81       	ldd	r24, Z+4	; 0x04
  ec:	95 81       	ldd	r25, Z+5	; 0x05
  ee:	66 81       	ldd	r22, Z+6	; 0x06
  f0:	77 81       	ldd	r23, Z+7	; 0x07
  f2:	ec 01       	movw	r28, r24
  f4:	7d 83       	std	Y+5, r23	; 0x05
  f6:	6c 83       	std	Y+4, r22	; 0x04
  f8:	66 81       	ldd	r22, Z+6	; 0x06
  fa:	77 81       	ldd	r23, Z+7	; 0x07
  fc:	eb 01       	movw	r28, r22
  fe:	9b 83       	std	Y+3, r25	; 0x03
 100:	8a 83       	std	Y+2, r24	; 0x02
 102:	cf 01       	movw	r24, r30
 104:	02 96       	adiw	r24, 0x02	; 2
 106:	11 96       	adiw	r26, 0x01	; 1
 108:	0d 91       	ld	r16, X+
 10a:	1c 91       	ld	r17, X
 10c:	12 97       	sbiw	r26, 0x02	; 2
 10e:	08 17       	cp	r16, r24
 110:	19 07       	cpc	r17, r25
 112:	01 f4       	brne	.+0      	; 0x114 <xTaskResumeAll+0x114>
 114:	12 96       	adiw	r26, 0x02	; 2
 116:	7c 93       	st	X, r23
 118:	6e 93       	st	-X, r22
 11a:	11 97       	sbiw	r26, 0x01	; 1
 11c:	13 86       	std	Z+11, r1	; 0x0b
 11e:	12 86       	std	Z+10, r1	; 0x0a
 120:	2c 91       	ld	r18, X
 122:	21 50       	subi	r18, 0x01	; 1
 124:	2c 93       	st	X, r18
 126:	a6 89       	ldd	r26, Z+22	; 0x16
 128:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 12c:	2a 17       	cp	r18, r26
 12e:	00 f4       	brcc	.+0      	; 0x130 <xTaskResumeAll+0x130>
 130:	a0 93 00 00 	sts	0x0000, r26	; 0x800000 <__SREG__+0x7fffc1>
 134:	3a 9f       	mul	r19, r26
 136:	d0 01       	movw	r26, r0
 138:	11 24       	eor	r1, r1
 13a:	a0 50       	subi	r26, 0x00	; 0
 13c:	b0 40       	sbci	r27, 0x00	; 0
 13e:	11 96       	adiw	r26, 0x01	; 1
 140:	0d 90       	ld	r0, X+
 142:	bc 91       	ld	r27, X
 144:	a0 2d       	mov	r26, r0
 146:	b5 83       	std	Z+5, r27	; 0x05
 148:	a4 83       	std	Z+4, r26	; 0x04
 14a:	14 96       	adiw	r26, 0x04	; 4
 14c:	6d 91       	ld	r22, X+
 14e:	7c 91       	ld	r23, X
 150:	15 97       	sbiw	r26, 0x05	; 5
 152:	77 83       	std	Z+7, r23	; 0x07
 154:	66 83       	std	Z+6, r22	; 0x06
 156:	14 96       	adiw	r26, 0x04	; 4
 158:	6d 91       	ld	r22, X+
 15a:	7c 91       	ld	r23, X
 15c:	15 97       	sbiw	r26, 0x05	; 5
 15e:	eb 01       	movw	r28, r22
 160:	9b 83       	std	Y+3, r25	; 0x03
 162:	8a 83       	std	Y+2, r24	; 0x02
 164:	15 96       	adiw	r26, 0x05	; 5
 166:	9c 93       	st	X, r25
 168:	8e 93       	st	-X, r24
 16a:	14 97       	sbiw	r26, 0x04	; 4
 16c:	96 89       	ldd	r25, Z+22	; 0x16
 16e:	93 9f       	mul	r25, r19
 170:	d0 01       	movw	r26, r0
 172:	11 24       	eor	r1, r1
 174:	a0 50       	subi	r26, 0x00	; 0
 176:	b0 40       	sbci	r27, 0x00	; 0
 178:	b3 87       	std	Z+11, r27	; 0x0b
 17a:	a2 87       	std	Z+10, r26	; 0x0a
 17c:	8c 91       	ld	r24, X
 17e:	8f 5f       	subi	r24, 0xFF	; 255
 180:	8c 93       	st	X, r24
 182:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 186:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 18a:	56 96       	adiw	r26, 0x16	; 22
 18c:	8c 91       	ld	r24, X
 18e:	89 17       	cp	r24, r25
 190:	00 f0       	brcs	.+0      	; 0x192 <xTaskResumeAll+0x192>
 192:	00 c0       	rjmp	.+0      	; 0x194 <xTaskResumeAll+0x194>
 194:	40 93 00 00 	sts	0x0000, r20	; 0x800000 <__SREG__+0x7fffc1>
 198:	00 c0       	rjmp	.+0      	; 0x19a <__SREG__+0x15b>

Disassembly of section .text.hot.xTaskDelayUntil:

00000000 <xTaskDelayUntil>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	ec 01       	movw	r28, r24
   a:	8b 01       	movw	r16, r22
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	0e 94 00 00 	call	0	; 0x0 <xTaskDelayUntil>
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  14:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	48 81       	ld	r20, Y
  1a:	59 81       	ldd	r21, Y+1	; 0x01
    xSchedulerRunning = pdFALSE;
  1c:	ca 01       	movw	r24, r20
  1e:	80 0f       	add	r24, r16
    xPendedTicks = ( TickType_t ) 0U;
  20:	91 1f       	adc	r25, r17
  22:	99 83       	std	Y+1, r25	; 0x01
  24:	88 83       	st	Y, r24
  26:	24 17       	cp	r18, r20

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	35 07       	cpc	r19, r21
  2a:	00 f4       	brcc	.+0      	; 0x2c <xTaskDelayUntil+0x2c>
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	84 17       	cp	r24, r20
  2e:	95 07       	cpc	r25, r21
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	00 f0       	brcs	.+0      	; 0x32 <xTaskDelayUntil+0x32>
  32:	c0 e0       	ldi	r28, 0x00	; 0
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	0e 94 00 00 	call	0	; 0x0 <xTaskDelayUntil>
  38:	81 11       	cpse	r24, r1
  3a:	00 c0       	rjmp	.+0      	; 0x3c <xTaskDelayUntil+0x3c>

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	0e 94 00 00 	call	0	; 0x0 <xTaskDelayUntil>
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	8c 2f       	mov	r24, r28
  42:	df 91       	pop	r29
  44:	cf 91       	pop	r28
  46:	1f 91       	pop	r17
  48:	0f 91       	pop	r16
  4a:	08 95       	ret
  4c:	84 17       	cp	r24, r20
  4e:	95 07       	cpc	r25, r21
  50:	00 f0       	brcs	.+0      	; 0x52 <xTaskDelayUntil+0x52>
  52:	28 17       	cp	r18, r24
  54:	39 07       	cpc	r19, r25
  56:	00 f4       	brcc	.+0      	; 0x58 <xTaskDelayUntil+0x58>
  58:	60 e0       	ldi	r22, 0x00	; 0
  5a:	82 1b       	sub	r24, r18
  5c:	93 0b       	sbc	r25, r19
  5e:	0e 94 00 00 	call	0	; 0x0 <xTaskDelayUntil>
  62:	c1 e0       	ldi	r28, 0x01	; 1
  64:	00 c0       	rjmp	.+0      	; 0x66 <__SREG__+0x27>

Disassembly of section .text.hot.vTaskDelay:

00000000 <vTaskDelay>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
   6:	89 2b       	or	r24, r25
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	01 f4       	brne	.+0      	; 0xa <vTaskDelay+0xa>
   a:	0e 94 00 00 	call	0	; 0x0 <vTaskDelay>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   e:	df 91       	pop	r29
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	cf 91       	pop	r28
  12:	08 95       	ret
  14:	0e 94 00 00 	call	0	; 0x0 <vTaskDelay>
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	60 e0       	ldi	r22, 0x00	; 0
  1a:	ce 01       	movw	r24, r28
    xSchedulerRunning = pdFALSE;
  1c:	0e 94 00 00 	call	0	; 0x0 <vTaskDelay>
    xPendedTicks = ( TickType_t ) 0U;
  20:	0e 94 00 00 	call	0	; 0x0 <vTaskDelay>
  24:	88 23       	and	r24, r24
  26:	01 f0       	breq	.+0      	; 0x28 <vTaskDelay+0x28>

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	00 c0       	rjmp	.+0      	; 0x2a <__zero_reg__+0x29>

Disassembly of section .text.hot.xTaskCatchUpTicks:

00000000 <xTaskCatchUpTicks>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
   6:	0e 94 00 00 	call	0	; 0x0 <xTaskCatchUpTicks>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   a:	0f b6       	in	r0, 0x3f	; 63
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	f8 94       	cli
   e:	0f 92       	push	r0
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  14:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	8c 0f       	add	r24, r28
  1a:	9d 1f       	adc	r25, r29
    xSchedulerRunning = pdFALSE;
  1c:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
    xPendedTicks = ( TickType_t ) 0U;
  20:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  24:	0f 90       	pop	r0
  26:	0f be       	out	0x3f, r0	; 63

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	df 91       	pop	r29
  2a:	cf 91       	pop	r28
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	0c 94 00 00 	jmp	0	; 0x0 <xTaskCatchUpTicks>

Disassembly of section .text.hot.vTaskSwitchContext:

00000000 <vTaskSwitchContext>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	88 23       	and	r24, r24
   6:	01 f0       	breq	.+0      	; 0x8 <vTaskSwitchContext+0x8>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	81 e0       	ldi	r24, 0x01	; 1
   a:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   e:	08 95       	ret
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  14:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xSchedulerRunning = pdFALSE;
  1c:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xPendedTicks = ( TickType_t ) 0U;
  20:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  24:	2d 91       	ld	r18, X+
  26:	3c 91       	ld	r19, X

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	87 89       	ldd	r24, Z+23	; 0x17
  2a:	90 8d       	ldd	r25, Z+24	; 0x18
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	82 17       	cp	r24, r18
  2e:	93 07       	cpc	r25, r19
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	00 f0       	brcs	.+0      	; 0x32 <vTaskSwitchContext+0x32>
  32:	60 91 00 00 	lds	r22, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  36:	70 91 00 00 	lds	r23, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  3a:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3e:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  42:	67 5e       	subi	r22, 0xE7	; 231
  44:	7f 4f       	sbci	r23, 0xFF	; 255
  46:	0e 94 00 00 	call	0	; 0x0 <vTaskSwitchContext>
  4a:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  4e:	89 e0       	ldi	r24, 0x09	; 9
  50:	42 2f       	mov	r20, r18
  52:	50 e0       	ldi	r21, 0x00	; 0
  54:	84 9f       	mul	r24, r20
  56:	f0 01       	movw	r30, r0
  58:	85 9f       	mul	r24, r21
  5a:	f0 0d       	add	r31, r0
  5c:	11 24       	eor	r1, r1
  5e:	e0 50       	subi	r30, 0x00	; 0
  60:	f0 40       	sbci	r31, 0x00	; 0
  62:	90 81       	ld	r25, Z
  64:	99 23       	and	r25, r25
  66:	01 f0       	breq	.+0      	; 0x68 <vTaskSwitchContext+0x68>
  68:	a1 81       	ldd	r26, Z+1	; 0x01
  6a:	b2 81       	ldd	r27, Z+2	; 0x02
  6c:	12 96       	adiw	r26, 0x02	; 2
  6e:	6d 91       	ld	r22, X+
  70:	7c 91       	ld	r23, X
  72:	72 83       	std	Z+2, r23	; 0x02
  74:	61 83       	std	Z+1, r22	; 0x01
  76:	28 9f       	mul	r18, r24
  78:	c0 01       	movw	r24, r0
  7a:	11 24       	eor	r1, r1
  7c:	80 50       	subi	r24, 0x00	; 0
  7e:	90 40       	sbci	r25, 0x00	; 0
  80:	68 17       	cp	r22, r24
  82:	79 07       	cpc	r23, r25
  84:	01 f4       	brne	.+0      	; 0x86 <vTaskSwitchContext+0x86>
  86:	85 81       	ldd	r24, Z+5	; 0x05
  88:	96 81       	ldd	r25, Z+6	; 0x06
  8a:	92 83       	std	Z+2, r25	; 0x02
  8c:	81 83       	std	Z+1, r24	; 0x01
  8e:	89 e0       	ldi	r24, 0x09	; 9
  90:	84 9f       	mul	r24, r20
  92:	f0 01       	movw	r30, r0
  94:	85 9f       	mul	r24, r21
  96:	f0 0d       	add	r31, r0
  98:	11 24       	eor	r1, r1
  9a:	e0 50       	subi	r30, 0x00	; 0
  9c:	f0 40       	sbci	r31, 0x00	; 0
  9e:	01 80       	ldd	r0, Z+1	; 0x01
  a0:	f2 81       	ldd	r31, Z+2	; 0x02
  a2:	e0 2d       	mov	r30, r0
  a4:	86 81       	ldd	r24, Z+6	; 0x06
  a6:	97 81       	ldd	r25, Z+7	; 0x07
  a8:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
  ac:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  b0:	20 93 00 00 	sts	0x0000, r18	; 0x800000 <__SREG__+0x7fffc1>
  b4:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  b8:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  bc:	08 95       	ret
  be:	21 50       	subi	r18, 0x01	; 1
  c0:	00 c0       	rjmp	.+0      	; 0xc2 <__SREG__+0x83>

Disassembly of section .text.hot.vTaskSuspend:

00000000 <vTaskSuspend>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	ec 01       	movw	r28, r24
   a:	0f b6       	in	r0, 0x3f	; 63
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	f8 94       	cli
   e:	0f 92       	push	r0
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	89 2b       	or	r24, r25
  12:	01 f4       	brne	.+0      	; 0x14 <vTaskSuspend+0x14>
  14:	c0 91 00 00 	lds	r28, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	d0 91 00 00 	lds	r29, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xSchedulerRunning = pdFALSE;
  1c:	8e 01       	movw	r16, r28
  1e:	0e 5f       	subi	r16, 0xFE	; 254
    xPendedTicks = ( TickType_t ) 0U;
  20:	1f 4f       	sbci	r17, 0xFF	; 255
  22:	c8 01       	movw	r24, r16
  24:	0e 94 00 00 	call	0	; 0x0 <vTaskSuspend>

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	8c 89       	ldd	r24, Y+20	; 0x14
  2a:	9d 89       	ldd	r25, Y+21	; 0x15
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	89 2b       	or	r24, r25
  2e:	01 f0       	breq	.+0      	; 0x30 <vTaskSuspend+0x30>
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	ce 01       	movw	r24, r28
  32:	0c 96       	adiw	r24, 0x0c	; 12
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	0e 94 00 00 	call	0	; 0x0 <vTaskSuspend>
  38:	b8 01       	movw	r22, r16
  3a:	80 e0       	ldi	r24, 0x00	; 0

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	90 e0       	ldi	r25, 0x00	; 0
  3e:	0e 94 00 00 	call	0	; 0x0 <vTaskSuspend>
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  42:	8f a5       	ldd	r24, Y+47	; 0x2f
  44:	81 30       	cpi	r24, 0x01	; 1
  46:	01 f4       	brne	.+0      	; 0x48 <vTaskSuspend+0x48>
  48:	1f a6       	std	Y+47, r1	; 0x2f
  4a:	0f 90       	pop	r0
  4c:	0f be       	out	0x3f, r0	; 63
  4e:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  52:	88 23       	and	r24, r24
  54:	01 f0       	breq	.+0      	; 0x56 <vTaskSuspend+0x56>
  56:	0f b6       	in	r0, 0x3f	; 63
  58:	f8 94       	cli
  5a:	0f 92       	push	r0
  5c:	0e 94 00 00 	call	0	; 0x0 <vTaskSuspend>
  60:	0f 90       	pop	r0
  62:	0f be       	out	0x3f, r0	; 63
  64:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  68:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  6c:	8c 17       	cp	r24, r28
  6e:	9d 07       	cpc	r25, r29
  70:	01 f4       	brne	.+0      	; 0x72 <vTaskSuspend+0x72>
  72:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  76:	88 23       	and	r24, r24
  78:	01 f0       	breq	.+0      	; 0x7a <vTaskSuspend+0x7a>
  7a:	0e 94 00 00 	call	0	; 0x0 <vTaskSuspend>
  7e:	df 91       	pop	r29
  80:	cf 91       	pop	r28
  82:	1f 91       	pop	r17
  84:	0f 91       	pop	r16
  86:	08 95       	ret
  88:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  8c:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  90:	98 13       	cpse	r25, r24
  92:	00 c0       	rjmp	.+0      	; 0x94 <vTaskSuspend+0x94>
  94:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  98:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  9c:	00 c0       	rjmp	.+0      	; 0x9e <vTaskSuspend+0x9e>
  9e:	df 91       	pop	r29
  a0:	cf 91       	pop	r28
  a2:	1f 91       	pop	r17
  a4:	0f 91       	pop	r16
  a6:	0c 94 00 00 	jmp	0	; 0x0 <vTaskSuspend>

Disassembly of section .text.hot.vTaskPlaceOnEventList:

00000000 <vTaskPlaceOnEventList>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	eb 01       	movw	r28, r22
   6:	60 91 00 00 	lds	r22, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   a:	70 91 00 00 	lds	r23, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   e:	64 5f       	subi	r22, 0xF4	; 244
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	7f 4f       	sbci	r23, 0xFF	; 255
  12:	0e 94 00 00 	call	0	; 0x0 <vTaskPlaceOnEventList>
  16:	61 e0       	ldi	r22, 0x01	; 1
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	ce 01       	movw	r24, r28
  1a:	df 91       	pop	r29
    xSchedulerRunning = pdFALSE;
  1c:	cf 91       	pop	r28
  1e:	0c 94 00 00 	jmp	0	; 0x0 <vTaskPlaceOnEventList>

Disassembly of section .text.hot.vTaskPlaceOnUnorderedEventList:

00000000 <vTaskPlaceOnUnorderedEventList>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	fc 01       	movw	r30, r24
   6:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   a:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   e:	70 68       	ori	r23, 0x80	; 128
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	1d 96       	adiw	r26, 0x0d	; 13
  12:	7c 93       	st	X, r23
  14:	6e 93       	st	-X, r22
  16:	1c 97       	sbiw	r26, 0x0c	; 12
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	a1 81       	ldd	r26, Z+1	; 0x01
  1a:	b2 81       	ldd	r27, Z+2	; 0x02
    xSchedulerRunning = pdFALSE;
  1c:	c0 91 00 00 	lds	r28, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xPendedTicks = ( TickType_t ) 0U;
  20:	d0 91 00 00 	lds	r29, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  24:	bf 87       	std	Y+15, r27	; 0x0f
  26:	ae 87       	std	Y+14, r26	; 0x0e

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	c0 91 00 00 	lds	r28, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	d0 91 00 00 	lds	r29, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	14 96       	adiw	r26, 0x04	; 4
  32:	8d 91       	ld	r24, X+
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	9c 91       	ld	r25, X
  36:	15 97       	sbiw	r26, 0x05	; 5
  38:	99 8b       	std	Y+17, r25	; 0x11
  3a:	88 8b       	std	Y+16, r24	; 0x10

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  44:	14 96       	adiw	r26, 0x04	; 4
  46:	cd 91       	ld	r28, X+
  48:	dc 91       	ld	r29, X
  4a:	15 97       	sbiw	r26, 0x05	; 5
  4c:	24 5f       	subi	r18, 0xF4	; 244
  4e:	3f 4f       	sbci	r19, 0xFF	; 255
  50:	3b 83       	std	Y+3, r19	; 0x03
  52:	2a 83       	std	Y+2, r18	; 0x02
  54:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  58:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  5c:	24 5f       	subi	r18, 0xF4	; 244
  5e:	3f 4f       	sbci	r19, 0xFF	; 255
  60:	15 96       	adiw	r26, 0x05	; 5
  62:	3c 93       	st	X, r19
  64:	2e 93       	st	-X, r18
  66:	14 97       	sbiw	r26, 0x04	; 4
  68:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  6c:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  70:	55 96       	adiw	r26, 0x15	; 21
  72:	fc 93       	st	X, r31
  74:	ee 93       	st	-X, r30
  76:	54 97       	sbiw	r26, 0x14	; 20
  78:	90 81       	ld	r25, Z
  7a:	9f 5f       	subi	r25, 0xFF	; 255
  7c:	90 83       	st	Z, r25
  7e:	61 e0       	ldi	r22, 0x01	; 1
  80:	ca 01       	movw	r24, r20
  82:	df 91       	pop	r29
  84:	cf 91       	pop	r28
  86:	0c 94 00 00 	jmp	0	; 0x0 <vTaskPlaceOnUnorderedEventList>

Disassembly of section .text.hot.vTaskPlaceOnEventListRestricted:

00000000 <vTaskPlaceOnEventListRestricted>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	fc 01       	movw	r30, r24
   a:	8b 01       	movw	r16, r22
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	a1 81       	ldd	r26, Z+1	; 0x01
   e:	b2 81       	ldd	r27, Z+2	; 0x02
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  14:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	ec 01       	movw	r28, r24
  1a:	bf 87       	std	Y+15, r27	; 0x0f
    xSchedulerRunning = pdFALSE;
  1c:	ae 87       	std	Y+14, r26	; 0x0e
  1e:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xPendedTicks = ( TickType_t ) 0U;
  22:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  26:	14 96       	adiw	r26, 0x04	; 4

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	2d 91       	ld	r18, X+
  2a:	3c 91       	ld	r19, X
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	15 97       	sbiw	r26, 0x05	; 5
  2e:	ec 01       	movw	r28, r24
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	39 8b       	std	Y+17, r19	; 0x11
  32:	28 8b       	std	Y+16, r18	; 0x10
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  38:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	14 96       	adiw	r26, 0x04	; 4
  3e:	8d 91       	ld	r24, X+
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	9c 91       	ld	r25, X
  42:	15 97       	sbiw	r26, 0x05	; 5
  44:	24 5f       	subi	r18, 0xF4	; 244
  46:	3f 4f       	sbci	r19, 0xFF	; 255
  48:	ec 01       	movw	r28, r24
  4a:	3b 83       	std	Y+3, r19	; 0x03
  4c:	2a 83       	std	Y+2, r18	; 0x02
  4e:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  52:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  56:	24 5f       	subi	r18, 0xF4	; 244
  58:	3f 4f       	sbci	r19, 0xFF	; 255
  5a:	15 96       	adiw	r26, 0x05	; 5
  5c:	3c 93       	st	X, r19
  5e:	2e 93       	st	-X, r18
  60:	14 97       	sbiw	r26, 0x04	; 4
  62:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  66:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  6a:	55 96       	adiw	r26, 0x15	; 21
  6c:	fc 93       	st	X, r31
  6e:	ee 93       	st	-X, r30
  70:	54 97       	sbiw	r26, 0x14	; 20
  72:	90 81       	ld	r25, Z
  74:	9f 5f       	subi	r25, 0xFF	; 255
  76:	90 83       	st	Z, r25
  78:	44 23       	and	r20, r20
  7a:	01 f0       	breq	.+0      	; 0x7c <vTaskPlaceOnEventListRestricted+0x7c>
  7c:	0f ef       	ldi	r16, 0xFF	; 255
  7e:	1f ef       	ldi	r17, 0xFF	; 255
  80:	64 2f       	mov	r22, r20
  82:	c8 01       	movw	r24, r16
  84:	df 91       	pop	r29
  86:	cf 91       	pop	r28
  88:	1f 91       	pop	r17
  8a:	0f 91       	pop	r16
  8c:	0c 94 00 00 	jmp	0	; 0x0 <vTaskPlaceOnEventListRestricted>

Disassembly of section .text.hot.xTaskRemoveFromEventList:

00000000 <xTaskRemoveFromEventList>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	dc 01       	movw	r26, r24
   6:	15 96       	adiw	r26, 0x05	; 5
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	ed 91       	ld	r30, X+
   a:	fc 91       	ld	r31, X
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	06 80       	ldd	r0, Z+6	; 0x06
   e:	f7 81       	ldd	r31, Z+7	; 0x07
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	e0 2d       	mov	r30, r0
  12:	a4 89       	ldd	r26, Z+20	; 0x14
  14:	b5 89       	ldd	r27, Z+21	; 0x15
  16:	86 85       	ldd	r24, Z+14	; 0x0e
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	97 85       	ldd	r25, Z+15	; 0x0f
  1a:	20 89       	ldd	r18, Z+16	; 0x10
    xSchedulerRunning = pdFALSE;
  1c:	31 89       	ldd	r19, Z+17	; 0x11
  1e:	ec 01       	movw	r28, r24
    xPendedTicks = ( TickType_t ) 0U;
  20:	3d 83       	std	Y+5, r19	; 0x05
  22:	2c 83       	std	Y+4, r18	; 0x04
  24:	c0 89       	ldd	r28, Z+16	; 0x10
  26:	d1 89       	ldd	r29, Z+17	; 0x11

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	9b 83       	std	Y+3, r25	; 0x03
  2a:	8a 83       	std	Y+2, r24	; 0x02
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	cf 01       	movw	r24, r30
  2e:	0c 96       	adiw	r24, 0x0c	; 12
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	11 96       	adiw	r26, 0x01	; 1
  32:	2d 91       	ld	r18, X+
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	3c 91       	ld	r19, X
  36:	12 97       	sbiw	r26, 0x02	; 2
  38:	28 17       	cp	r18, r24
  3a:	39 07       	cpc	r19, r25

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	01 f4       	brne	.+0      	; 0x3e <xTaskRemoveFromEventList+0x3e>
  3e:	12 96       	adiw	r26, 0x02	; 2
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	dc 93       	st	X, r29
  42:	ce 93       	st	-X, r28
  44:	11 97       	sbiw	r26, 0x01	; 1
  46:	15 8a       	std	Z+21, r1	; 0x15
  48:	14 8a       	std	Z+20, r1	; 0x14
  4a:	2c 91       	ld	r18, X
  4c:	21 50       	subi	r18, 0x01	; 1
  4e:	2c 93       	st	X, r18
  50:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  54:	21 11       	cpse	r18, r1
  56:	00 c0       	rjmp	.+0      	; 0x58 <xTaskRemoveFromEventList+0x58>
  58:	a2 85       	ldd	r26, Z+10	; 0x0a
  5a:	b3 85       	ldd	r27, Z+11	; 0x0b
  5c:	84 81       	ldd	r24, Z+4	; 0x04
  5e:	95 81       	ldd	r25, Z+5	; 0x05
  60:	26 81       	ldd	r18, Z+6	; 0x06
  62:	37 81       	ldd	r19, Z+7	; 0x07
  64:	ec 01       	movw	r28, r24
  66:	3d 83       	std	Y+5, r19	; 0x05
  68:	2c 83       	std	Y+4, r18	; 0x04
  6a:	c6 81       	ldd	r28, Z+6	; 0x06
  6c:	d7 81       	ldd	r29, Z+7	; 0x07
  6e:	9b 83       	std	Y+3, r25	; 0x03
  70:	8a 83       	std	Y+2, r24	; 0x02
  72:	cf 01       	movw	r24, r30
  74:	02 96       	adiw	r24, 0x02	; 2
  76:	11 96       	adiw	r26, 0x01	; 1
  78:	2d 91       	ld	r18, X+
  7a:	3c 91       	ld	r19, X
  7c:	12 97       	sbiw	r26, 0x02	; 2
  7e:	28 17       	cp	r18, r24
  80:	39 07       	cpc	r19, r25
  82:	01 f4       	brne	.+0      	; 0x84 <xTaskRemoveFromEventList+0x84>
  84:	12 96       	adiw	r26, 0x02	; 2
  86:	dc 93       	st	X, r29
  88:	ce 93       	st	-X, r28
  8a:	11 97       	sbiw	r26, 0x01	; 1
  8c:	13 86       	std	Z+11, r1	; 0x0b
  8e:	12 86       	std	Z+10, r1	; 0x0a
  90:	2c 91       	ld	r18, X
  92:	21 50       	subi	r18, 0x01	; 1
  94:	2c 93       	st	X, r18
  96:	c6 89       	ldd	r28, Z+22	; 0x16
  98:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  9c:	2c 17       	cp	r18, r28
  9e:	00 f4       	brcc	.+0      	; 0xa0 <xTaskRemoveFromEventList+0xa0>
  a0:	c0 93 00 00 	sts	0x0000, r28	; 0x800000 <__SREG__+0x7fffc1>
  a4:	29 e0       	ldi	r18, 0x09	; 9
  a6:	2c 9f       	mul	r18, r28
  a8:	e0 01       	movw	r28, r0
  aa:	11 24       	eor	r1, r1
  ac:	c0 50       	subi	r28, 0x00	; 0
  ae:	d0 40       	sbci	r29, 0x00	; 0
  b0:	09 80       	ldd	r0, Y+1	; 0x01
  b2:	da 81       	ldd	r29, Y+2	; 0x02
  b4:	c0 2d       	mov	r28, r0
  b6:	d5 83       	std	Z+5, r29	; 0x05
  b8:	c4 83       	std	Z+4, r28	; 0x04
  ba:	4c 81       	ldd	r20, Y+4	; 0x04
  bc:	5d 81       	ldd	r21, Y+5	; 0x05
  be:	57 83       	std	Z+7, r21	; 0x07
  c0:	46 83       	std	Z+6, r20	; 0x06
  c2:	ac 81       	ldd	r26, Y+4	; 0x04
  c4:	bd 81       	ldd	r27, Y+5	; 0x05
  c6:	13 96       	adiw	r26, 0x03	; 3
  c8:	9c 93       	st	X, r25
  ca:	8e 93       	st	-X, r24
  cc:	12 97       	sbiw	r26, 0x02	; 2
  ce:	9d 83       	std	Y+5, r25	; 0x05
  d0:	8c 83       	std	Y+4, r24	; 0x04
  d2:	a6 89       	ldd	r26, Z+22	; 0x16
  d4:	a2 9f       	mul	r26, r18
  d6:	d0 01       	movw	r26, r0
  d8:	11 24       	eor	r1, r1
  da:	a0 50       	subi	r26, 0x00	; 0
  dc:	b0 40       	sbci	r27, 0x00	; 0
  de:	b3 87       	std	Z+11, r27	; 0x0b
  e0:	a2 87       	std	Z+10, r26	; 0x0a
  e2:	8c 91       	ld	r24, X
  e4:	8f 5f       	subi	r24, 0xFF	; 255
  e6:	8c 93       	st	X, r24
  e8:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  ec:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  f0:	96 89       	ldd	r25, Z+22	; 0x16
  f2:	56 96       	adiw	r26, 0x16	; 22
  f4:	8c 91       	ld	r24, X
  f6:	89 17       	cp	r24, r25
  f8:	00 f4       	brcc	.+0      	; 0xfa <xTaskRemoveFromEventList+0xfa>
  fa:	81 e0       	ldi	r24, 0x01	; 1
  fc:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
 100:	df 91       	pop	r29
 102:	cf 91       	pop	r28
 104:	08 95       	ret
 106:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 10a:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 10e:	b7 87       	std	Z+15, r27	; 0x0f
 110:	a6 87       	std	Z+14, r26	; 0x0e
 112:	14 96       	adiw	r26, 0x04	; 4
 114:	2d 91       	ld	r18, X+
 116:	3c 91       	ld	r19, X
 118:	15 97       	sbiw	r26, 0x05	; 5
 11a:	31 8b       	std	Z+17, r19	; 0x11
 11c:	20 8b       	std	Z+16, r18	; 0x10
 11e:	14 96       	adiw	r26, 0x04	; 4
 120:	cd 91       	ld	r28, X+
 122:	dc 91       	ld	r29, X
 124:	15 97       	sbiw	r26, 0x05	; 5
 126:	9b 83       	std	Y+3, r25	; 0x03
 128:	8a 83       	std	Y+2, r24	; 0x02
 12a:	15 96       	adiw	r26, 0x05	; 5
 12c:	9c 93       	st	X, r25
 12e:	8e 93       	st	-X, r24
 130:	14 97       	sbiw	r26, 0x04	; 4
 132:	80 e0       	ldi	r24, 0x00	; 0
 134:	90 e0       	ldi	r25, 0x00	; 0
 136:	95 8b       	std	Z+21, r25	; 0x15
 138:	84 8b       	std	Z+20, r24	; 0x14
 13a:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 13e:	8f 5f       	subi	r24, 0xFF	; 255
 140:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
 144:	00 c0       	rjmp	.+0      	; 0x146 <xTaskRemoveFromEventList+0x146>
 146:	80 e0       	ldi	r24, 0x00	; 0
 148:	00 c0       	rjmp	.+0      	; 0x14a <__SREG__+0x10b>

Disassembly of section .text.hot.vTaskRemoveFromUnorderedEventList:

00000000 <vTaskRemoveFromUnorderedEventList>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	dc 01       	movw	r26, r24
   6:	70 68       	ori	r23, 0x80	; 128
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	11 96       	adiw	r26, 0x01	; 1
   a:	7c 93       	st	X, r23
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	6e 93       	st	-X, r22
   e:	16 96       	adiw	r26, 0x06	; 6
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	ed 91       	ld	r30, X+
  12:	fc 91       	ld	r31, X
  14:	17 97       	sbiw	r26, 0x07	; 7
  16:	18 96       	adiw	r26, 0x08	; 8
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	4d 91       	ld	r20, X+
  1a:	5c 91       	ld	r21, X
    xSchedulerRunning = pdFALSE;
  1c:	19 97       	sbiw	r26, 0x09	; 9
  1e:	12 96       	adiw	r26, 0x02	; 2
    xPendedTicks = ( TickType_t ) 0U;
  20:	2d 91       	ld	r18, X+
  22:	3c 91       	ld	r19, X
  24:	13 97       	sbiw	r26, 0x03	; 3
  26:	14 96       	adiw	r26, 0x04	; 4

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	8d 91       	ld	r24, X+
  2a:	9c 91       	ld	r25, X
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	15 97       	sbiw	r26, 0x05	; 5
  2e:	e9 01       	movw	r28, r18
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	9d 83       	std	Y+5, r25	; 0x05
  32:	8c 83       	std	Y+4, r24	; 0x04
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	14 96       	adiw	r26, 0x04	; 4
  36:	8d 91       	ld	r24, X+
  38:	9c 91       	ld	r25, X
  3a:	15 97       	sbiw	r26, 0x05	; 5

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	ec 01       	movw	r28, r24
  3e:	3b 83       	std	Y+3, r19	; 0x03
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	2a 83       	std	Y+2, r18	; 0x02
  42:	ea 01       	movw	r28, r20
  44:	29 81       	ldd	r18, Y+1	; 0x01
  46:	3a 81       	ldd	r19, Y+2	; 0x02
  48:	2a 17       	cp	r18, r26
  4a:	3b 07       	cpc	r19, r27
  4c:	01 f4       	brne	.+0      	; 0x4e <vTaskRemoveFromUnorderedEventList+0x4e>
  4e:	9a 83       	std	Y+2, r25	; 0x02
  50:	89 83       	std	Y+1, r24	; 0x01
  52:	19 96       	adiw	r26, 0x09	; 9
  54:	1c 92       	st	X, r1
  56:	1e 92       	st	-X, r1
  58:	18 97       	sbiw	r26, 0x08	; 8
  5a:	da 01       	movw	r26, r20
  5c:	8c 91       	ld	r24, X
  5e:	81 50       	subi	r24, 0x01	; 1
  60:	8c 93       	st	X, r24
  62:	a2 85       	ldd	r26, Z+10	; 0x0a
  64:	b3 85       	ldd	r27, Z+11	; 0x0b
  66:	84 81       	ldd	r24, Z+4	; 0x04
  68:	95 81       	ldd	r25, Z+5	; 0x05
  6a:	26 81       	ldd	r18, Z+6	; 0x06
  6c:	37 81       	ldd	r19, Z+7	; 0x07
  6e:	ec 01       	movw	r28, r24
  70:	3d 83       	std	Y+5, r19	; 0x05
  72:	2c 83       	std	Y+4, r18	; 0x04
  74:	c6 81       	ldd	r28, Z+6	; 0x06
  76:	d7 81       	ldd	r29, Z+7	; 0x07
  78:	9b 83       	std	Y+3, r25	; 0x03
  7a:	8a 83       	std	Y+2, r24	; 0x02
  7c:	cf 01       	movw	r24, r30
  7e:	02 96       	adiw	r24, 0x02	; 2
  80:	11 96       	adiw	r26, 0x01	; 1
  82:	2d 91       	ld	r18, X+
  84:	3c 91       	ld	r19, X
  86:	12 97       	sbiw	r26, 0x02	; 2
  88:	28 17       	cp	r18, r24
  8a:	39 07       	cpc	r19, r25
  8c:	01 f4       	brne	.+0      	; 0x8e <vTaskRemoveFromUnorderedEventList+0x8e>
  8e:	12 96       	adiw	r26, 0x02	; 2
  90:	dc 93       	st	X, r29
  92:	ce 93       	st	-X, r28
  94:	11 97       	sbiw	r26, 0x01	; 1
  96:	13 86       	std	Z+11, r1	; 0x0b
  98:	12 86       	std	Z+10, r1	; 0x0a
  9a:	2c 91       	ld	r18, X
  9c:	21 50       	subi	r18, 0x01	; 1
  9e:	2c 93       	st	X, r18
  a0:	c6 89       	ldd	r28, Z+22	; 0x16
  a2:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  a6:	2c 17       	cp	r18, r28
  a8:	00 f4       	brcc	.+0      	; 0xaa <vTaskRemoveFromUnorderedEventList+0xaa>
  aa:	c0 93 00 00 	sts	0x0000, r28	; 0x800000 <__SREG__+0x7fffc1>
  ae:	49 e0       	ldi	r20, 0x09	; 9
  b0:	4c 9f       	mul	r20, r28
  b2:	e0 01       	movw	r28, r0
  b4:	11 24       	eor	r1, r1
  b6:	c0 50       	subi	r28, 0x00	; 0
  b8:	d0 40       	sbci	r29, 0x00	; 0
  ba:	09 80       	ldd	r0, Y+1	; 0x01
  bc:	da 81       	ldd	r29, Y+2	; 0x02
  be:	c0 2d       	mov	r28, r0
  c0:	d5 83       	std	Z+5, r29	; 0x05
  c2:	c4 83       	std	Z+4, r28	; 0x04
  c4:	2c 81       	ldd	r18, Y+4	; 0x04
  c6:	3d 81       	ldd	r19, Y+5	; 0x05
  c8:	37 83       	std	Z+7, r19	; 0x07
  ca:	26 83       	std	Z+6, r18	; 0x06
  cc:	2c 81       	ldd	r18, Y+4	; 0x04
  ce:	3d 81       	ldd	r19, Y+5	; 0x05
  d0:	d9 01       	movw	r26, r18
  d2:	13 96       	adiw	r26, 0x03	; 3
  d4:	9c 93       	st	X, r25
  d6:	8e 93       	st	-X, r24
  d8:	12 97       	sbiw	r26, 0x02	; 2
  da:	9d 83       	std	Y+5, r25	; 0x05
  dc:	8c 83       	std	Y+4, r24	; 0x04
  de:	96 89       	ldd	r25, Z+22	; 0x16
  e0:	94 9f       	mul	r25, r20
  e2:	d0 01       	movw	r26, r0
  e4:	11 24       	eor	r1, r1
  e6:	a0 50       	subi	r26, 0x00	; 0
  e8:	b0 40       	sbci	r27, 0x00	; 0
  ea:	b3 87       	std	Z+11, r27	; 0x0b
  ec:	a2 87       	std	Z+10, r26	; 0x0a
  ee:	8c 91       	ld	r24, X
  f0:	8f 5f       	subi	r24, 0xFF	; 255
  f2:	8c 93       	st	X, r24
  f4:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  f8:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  fc:	86 89       	ldd	r24, Z+22	; 0x16
  fe:	89 17       	cp	r24, r25
 100:	00 f4       	brcc	.+0      	; 0x102 <vTaskRemoveFromUnorderedEventList+0x102>
 102:	81 e0       	ldi	r24, 0x01	; 1
 104:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
 108:	df 91       	pop	r29
 10a:	cf 91       	pop	r28
 10c:	08 95       	ret

Disassembly of section .text.hot.vTaskSetTimeOutState:

00000000 <vTaskSetTimeOutState>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	0f b6       	in	r0, 0x3f	; 63
   2:	f8 94       	cli
   4:	0f 92       	push	r0
   6:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   a:	fc 01       	movw	r30, r24
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	20 83       	st	Z, r18
   e:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  12:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  16:	32 83       	std	Z+2, r19	; 0x02
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	21 83       	std	Z+1, r18	; 0x01
  1a:	0f 90       	pop	r0
    xSchedulerRunning = pdFALSE;
  1c:	0f be       	out	0x3f, r0	; 63
  1e:	08 95       	ret

Disassembly of section .text.hot.vTaskInternalSetTimeOutState:

00000000 <vTaskInternalSetTimeOutState>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	fc 01       	movw	r30, r24
   6:	20 83       	st	Z, r18
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	32 83       	std	Z+2, r19	; 0x02
  12:	21 83       	std	Z+1, r18	; 0x01
  14:	08 95       	ret

Disassembly of section .text.hot.xTaskCheckForTimeOut:

00000000 <xTaskCheckForTimeOut>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	f8 94       	cli
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	0f 92       	push	r0
   a:	40 91 00 00 	lds	r20, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   e:	50 91 00 00 	lds	r21, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  12:	db 01       	movw	r26, r22
  14:	2d 91       	ld	r18, X+
  16:	3c 91       	ld	r19, X
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	2f 3f       	cpi	r18, 0xFF	; 255
  1a:	32 07       	cpc	r19, r18
    xSchedulerRunning = pdFALSE;
  1c:	01 f0       	breq	.+0      	; 0x1e <xTaskCheckForTimeOut+0x1e>
  1e:	ec 01       	movw	r28, r24
    xPendedTicks = ( TickType_t ) 0U;
  20:	e9 81       	ldd	r30, Y+1	; 0x01
  22:	fa 81       	ldd	r31, Y+2	; 0x02
  24:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	b8 81       	ld	r27, Y
  2a:	ba 17       	cp	r27, r26
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	01 f0       	breq	.+0      	; 0x2e <xTaskCheckForTimeOut+0x2e>
  2e:	4e 17       	cp	r20, r30
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	5f 07       	cpc	r21, r31
  32:	00 f0       	brcs	.+0      	; 0x34 <xTaskCheckForTimeOut+0x34>
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	fb 01       	movw	r30, r22
  36:	11 82       	std	Z+1, r1	; 0x01
  38:	10 82       	st	Z, r1
  3a:	81 e0       	ldi	r24, 0x01	; 1

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	0f 90       	pop	r0
  3e:	0f be       	out	0x3f, r0	; 63
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	df 91       	pop	r29
  42:	cf 91       	pop	r28
  44:	08 95       	ret
  46:	4e 1b       	sub	r20, r30
  48:	5f 0b       	sbc	r21, r31
  4a:	42 17       	cp	r20, r18
  4c:	53 07       	cpc	r21, r19
  4e:	00 f4       	brcc	.+0      	; 0x50 <xTaskCheckForTimeOut+0x50>
  50:	24 1b       	sub	r18, r20
  52:	35 0b       	sbc	r19, r21
  54:	db 01       	movw	r26, r22
  56:	2d 93       	st	X+, r18
  58:	3c 93       	st	X, r19
  5a:	0e 94 00 00 	call	0	; 0x0 <xTaskCheckForTimeOut>
  5e:	80 e0       	ldi	r24, 0x00	; 0
  60:	00 c0       	rjmp	.+0      	; 0x62 <__SREG__+0x23>

Disassembly of section .text.hot.vTaskMissedYield:

00000000 <vTaskMissedYield>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	81 e0       	ldi	r24, 0x01	; 1
   2:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
   6:	08 95       	ret

Disassembly of section .text.hot.uxTaskGetStackHighWaterMark:

00000000 <uxTaskGetStackHighWaterMark>:
   0:	00 97       	sbiw	r24, 0x00	; 0
   2:	01 f4       	brne	.+0      	; 0x4 <uxTaskGetStackHighWaterMark+0x4>
   4:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	fc 01       	movw	r30, r24
   e:	27 89       	ldd	r18, Z+23	; 0x17
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	30 8d       	ldd	r19, Z+24	; 0x18
  12:	f9 01       	movw	r30, r18
  14:	cf 01       	movw	r24, r30
  16:	82 1b       	sub	r24, r18
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	93 0b       	sbc	r25, r19
  1a:	41 91       	ld	r20, Z+
    xSchedulerRunning = pdFALSE;
  1c:	45 3a       	cpi	r20, 0xA5	; 165
  1e:	01 f0       	breq	.+0      	; 0x20 <uxTaskGetStackHighWaterMark+0x20>
    xPendedTicks = ( TickType_t ) 0U;
  20:	08 95       	ret

Disassembly of section .text.hot.xTaskGetCurrentTaskHandle:

00000000 <xTaskGetCurrentTaskHandle>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	08 95       	ret

Disassembly of section .text.hot.xTaskGetCurrentTaskHandleForCore:

00000000 <xTaskGetCurrentTaskHandleForCore>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	81 11       	cpse	r24, r1
   2:	00 c0       	rjmp	.+0      	; 0x4 <xTaskGetCurrentTaskHandleForCore+0x4>
   4:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	08 95       	ret
   e:	90 e0       	ldi	r25, 0x00	; 0
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	80 e0       	ldi	r24, 0x00	; 0
  12:	08 95       	ret

Disassembly of section .text.hot.xTaskGetSchedulerState:

00000000 <xTaskGetSchedulerState>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	88 23       	and	r24, r24
   6:	01 f0       	breq	.+0      	; 0x8 <xTaskGetSchedulerState+0x8>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	88 23       	and	r24, r24
   e:	01 f0       	breq	.+0      	; 0x10 <xTaskGetSchedulerState+0x10>
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	80 e0       	ldi	r24, 0x00	; 0
  12:	08 95       	ret
  14:	81 e0       	ldi	r24, 0x01	; 1
  16:	08 95       	ret
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	82 e0       	ldi	r24, 0x02	; 2
  1a:	08 95       	ret

Disassembly of section .text.hot.xTaskPriorityInherit:

00000000 <xTaskPriorityInherit>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	ec 01       	movw	r28, r24
   a:	89 2b       	or	r24, r25
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	01 f4       	brne	.+0      	; 0xe <xTaskPriorityInherit+0xe>
   e:	00 c0       	rjmp	.+0      	; 0x10 <xTaskPriorityInherit+0x10>
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	8e 89       	ldd	r24, Y+22	; 0x16
  12:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  16:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    uxTopReadyPriority = tskIDLE_PRIORITY;
  1a:	56 96       	adiw	r26, 0x16	; 22
    xSchedulerRunning = pdFALSE;
  1c:	9c 91       	ld	r25, X
  1e:	89 17       	cp	r24, r25
    xPendedTicks = ( TickType_t ) 0U;
  20:	00 f0       	brcs	.+0      	; 0x22 <xTaskPriorityInherit+0x22>
  22:	00 c0       	rjmp	.+0      	; 0x24 <xTaskPriorityInherit+0x24>
  24:	2c 85       	ldd	r18, Y+12	; 0x0c
  26:	3d 85       	ldd	r19, Y+13	; 0x0d

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	37 fd       	sbrc	r19, 7
  2a:	00 c0       	rjmp	.+0      	; 0x2c <xTaskPriorityInherit+0x2c>
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	56 96       	adiw	r26, 0x16	; 22
  36:	9c 91       	ld	r25, X
  38:	24 e0       	ldi	r18, 0x04	; 4
  3a:	30 e0       	ldi	r19, 0x00	; 0

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	29 1b       	sub	r18, r25
  3e:	31 09       	sbc	r19, r1
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	3d 87       	std	Y+13, r19	; 0x0d
  42:	2c 87       	std	Y+12, r18	; 0x0c
  44:	29 e0       	ldi	r18, 0x09	; 9
  46:	82 9f       	mul	r24, r18
  48:	c0 01       	movw	r24, r0
  4a:	11 24       	eor	r1, r1
  4c:	80 50       	subi	r24, 0x00	; 0
  4e:	90 40       	sbci	r25, 0x00	; 0
  50:	2a 85       	ldd	r18, Y+10	; 0x0a
  52:	3b 85       	ldd	r19, Y+11	; 0x0b
  54:	28 17       	cp	r18, r24
  56:	39 07       	cpc	r19, r25
  58:	01 f4       	brne	.+0      	; 0x5a <xTaskPriorityInherit+0x5a>
  5a:	8e 01       	movw	r16, r28
  5c:	0e 5f       	subi	r16, 0xFE	; 254
  5e:	1f 4f       	sbci	r17, 0xFF	; 255
  60:	c8 01       	movw	r24, r16
  62:	0e 94 00 00 	call	0	; 0x0 <xTaskPriorityInherit>
  66:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  6a:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  6e:	e6 89       	ldd	r30, Z+22	; 0x16
  70:	ee 8b       	std	Y+22, r30	; 0x16
  72:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  76:	8e 17       	cp	r24, r30
  78:	00 f4       	brcc	.+0      	; 0x7a <xTaskPriorityInherit+0x7a>
  7a:	e0 93 00 00 	sts	0x0000, r30	; 0x800000 <__SREG__+0x7fffc1>
  7e:	89 e0       	ldi	r24, 0x09	; 9
  80:	8e 9f       	mul	r24, r30
  82:	f0 01       	movw	r30, r0
  84:	11 24       	eor	r1, r1
  86:	e0 50       	subi	r30, 0x00	; 0
  88:	f0 40       	sbci	r31, 0x00	; 0
  8a:	a1 81       	ldd	r26, Z+1	; 0x01
  8c:	b2 81       	ldd	r27, Z+2	; 0x02
  8e:	bd 83       	std	Y+5, r27	; 0x05
  90:	ac 83       	std	Y+4, r26	; 0x04
  92:	14 96       	adiw	r26, 0x04	; 4
  94:	2d 91       	ld	r18, X+
  96:	3c 91       	ld	r19, X
  98:	15 97       	sbiw	r26, 0x05	; 5
  9a:	3f 83       	std	Y+7, r19	; 0x07
  9c:	2e 83       	std	Y+6, r18	; 0x06
  9e:	14 96       	adiw	r26, 0x04	; 4
  a0:	ed 91       	ld	r30, X+
  a2:	fc 91       	ld	r31, X
  a4:	15 97       	sbiw	r26, 0x05	; 5
  a6:	13 83       	std	Z+3, r17	; 0x03
  a8:	02 83       	std	Z+2, r16	; 0x02
  aa:	15 96       	adiw	r26, 0x05	; 5
  ac:	1c 93       	st	X, r17
  ae:	0e 93       	st	-X, r16
  b0:	14 97       	sbiw	r26, 0x04	; 4
  b2:	ee 89       	ldd	r30, Y+22	; 0x16
  b4:	e8 9f       	mul	r30, r24
  b6:	f0 01       	movw	r30, r0
  b8:	11 24       	eor	r1, r1
  ba:	e0 50       	subi	r30, 0x00	; 0
  bc:	f0 40       	sbci	r31, 0x00	; 0
  be:	fb 87       	std	Y+11, r31	; 0x0b
  c0:	ea 87       	std	Y+10, r30	; 0x0a
  c2:	80 81       	ld	r24, Z
  c4:	8f 5f       	subi	r24, 0xFF	; 255
  c6:	80 83       	st	Z, r24
  c8:	81 e0       	ldi	r24, 0x01	; 1
  ca:	df 91       	pop	r29
  cc:	cf 91       	pop	r28
  ce:	1f 91       	pop	r17
  d0:	0f 91       	pop	r16
  d2:	08 95       	ret
  d4:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  d8:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  dc:	56 96       	adiw	r26, 0x16	; 22
  de:	8c 91       	ld	r24, X
  e0:	8e 8b       	std	Y+22, r24	; 0x16
  e2:	00 c0       	rjmp	.+0      	; 0xe4 <xTaskPriorityInherit+0xe4>
  e4:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  e8:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  ec:	81 e0       	ldi	r24, 0x01	; 1
  ee:	29 a5       	ldd	r18, Y+41	; 0x29
  f0:	56 96       	adiw	r26, 0x16	; 22
  f2:	9c 91       	ld	r25, X
  f4:	29 17       	cp	r18, r25
  f6:	00 f0       	brcs	.+0      	; 0xf8 <xTaskPriorityInherit+0xf8>
  f8:	80 e0       	ldi	r24, 0x00	; 0
  fa:	00 c0       	rjmp	.+0      	; 0xfc <__SREG__+0xbd>

Disassembly of section .text.hot.xTaskPriorityDisinherit:

00000000 <xTaskPriorityDisinherit>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	ec 01       	movw	r28, r24
   a:	89 2b       	or	r24, r25
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	01 f4       	brne	.+0      	; 0xe <xTaskPriorityDisinherit+0xe>
   e:	80 e0       	ldi	r24, 0x00	; 0
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	df 91       	pop	r29
  12:	cf 91       	pop	r28
  14:	1f 91       	pop	r17
  16:	0f 91       	pop	r16
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	08 95       	ret
  1a:	8a a5       	ldd	r24, Y+42	; 0x2a
    xSchedulerRunning = pdFALSE;
  1c:	81 50       	subi	r24, 0x01	; 1
  1e:	8a a7       	std	Y+42, r24	; 0x2a
    xPendedTicks = ( TickType_t ) 0U;
  20:	2e 89       	ldd	r18, Y+22	; 0x16
  22:	99 a5       	ldd	r25, Y+41	; 0x29
  24:	29 17       	cp	r18, r25
  26:	01 f0       	breq	.+0      	; 0x28 <xTaskPriorityDisinherit+0x28>

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	81 11       	cpse	r24, r1
  2a:	00 c0       	rjmp	.+0      	; 0x2c <xTaskPriorityDisinherit+0x2c>
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	8e 01       	movw	r16, r28
  2e:	0e 5f       	subi	r16, 0xFE	; 254
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	1f 4f       	sbci	r17, 0xFF	; 255
  32:	c8 01       	movw	r24, r16
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	0e 94 00 00 	call	0	; 0x0 <xTaskPriorityDisinherit>
  38:	89 a5       	ldd	r24, Y+41	; 0x29
  3a:	8e 8b       	std	Y+22, r24	; 0x16

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	48 2f       	mov	r20, r24
  3e:	50 e0       	ldi	r21, 0x00	; 0
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	24 e0       	ldi	r18, 0x04	; 4
  42:	30 e0       	ldi	r19, 0x00	; 0
  44:	24 1b       	sub	r18, r20
  46:	35 0b       	sbc	r19, r21
  48:	3d 87       	std	Y+13, r19	; 0x0d
  4a:	2c 87       	std	Y+12, r18	; 0x0c
  4c:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  50:	98 17       	cp	r25, r24
  52:	00 f4       	brcc	.+0      	; 0x54 <xTaskPriorityDisinherit+0x54>
  54:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  58:	89 e0       	ldi	r24, 0x09	; 9
  5a:	84 9f       	mul	r24, r20
  5c:	d0 01       	movw	r26, r0
  5e:	85 9f       	mul	r24, r21
  60:	b0 0d       	add	r27, r0
  62:	11 24       	eor	r1, r1
  64:	a0 50       	subi	r26, 0x00	; 0
  66:	b0 40       	sbci	r27, 0x00	; 0
  68:	11 96       	adiw	r26, 0x01	; 1
  6a:	0d 90       	ld	r0, X+
  6c:	bc 91       	ld	r27, X
  6e:	a0 2d       	mov	r26, r0
  70:	bd 83       	std	Y+5, r27	; 0x05
  72:	ac 83       	std	Y+4, r26	; 0x04
  74:	14 96       	adiw	r26, 0x04	; 4
  76:	2d 91       	ld	r18, X+
  78:	3c 91       	ld	r19, X
  7a:	15 97       	sbiw	r26, 0x05	; 5
  7c:	3f 83       	std	Y+7, r19	; 0x07
  7e:	2e 83       	std	Y+6, r18	; 0x06
  80:	14 96       	adiw	r26, 0x04	; 4
  82:	ed 91       	ld	r30, X+
  84:	fc 91       	ld	r31, X
  86:	15 97       	sbiw	r26, 0x05	; 5
  88:	13 83       	std	Z+3, r17	; 0x03
  8a:	02 83       	std	Z+2, r16	; 0x02
  8c:	15 96       	adiw	r26, 0x05	; 5
  8e:	1c 93       	st	X, r17
  90:	0e 93       	st	-X, r16
  92:	14 97       	sbiw	r26, 0x04	; 4
  94:	ee 89       	ldd	r30, Y+22	; 0x16
  96:	e8 9f       	mul	r30, r24
  98:	f0 01       	movw	r30, r0
  9a:	11 24       	eor	r1, r1
  9c:	e0 50       	subi	r30, 0x00	; 0
  9e:	f0 40       	sbci	r31, 0x00	; 0
  a0:	fb 87       	std	Y+11, r31	; 0x0b
  a2:	ea 87       	std	Y+10, r30	; 0x0a
  a4:	80 81       	ld	r24, Z
  a6:	8f 5f       	subi	r24, 0xFF	; 255
  a8:	80 83       	st	Z, r24
  aa:	81 e0       	ldi	r24, 0x01	; 1
  ac:	00 c0       	rjmp	.+0      	; 0xae <__SREG__+0x6f>

Disassembly of section .text.hot.vTaskPriorityDisinheritAfterTimeout:

00000000 <vTaskPriorityDisinheritAfterTimeout>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	ec 01       	movw	r28, r24
   a:	89 2b       	or	r24, r25
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	01 f4       	brne	.+0      	; 0xe <vTaskPriorityDisinheritAfterTimeout+0xe>
   e:	00 c0       	rjmp	.+0      	; 0x10 <vTaskPriorityDisinheritAfterTimeout+0x10>
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	99 a5       	ldd	r25, Y+41	; 0x29
  12:	96 17       	cp	r25, r22
  14:	00 f4       	brcc	.+0      	; 0x16 <vTaskPriorityDisinheritAfterTimeout+0x16>
  16:	96 2f       	mov	r25, r22
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	8e 89       	ldd	r24, Y+22	; 0x16
  1a:	89 17       	cp	r24, r25
    xSchedulerRunning = pdFALSE;
  1c:	01 f4       	brne	.+0      	; 0x1e <vTaskPriorityDisinheritAfterTimeout+0x1e>
  1e:	00 c0       	rjmp	.+0      	; 0x20 <vTaskPriorityDisinheritAfterTimeout+0x20>
    xPendedTicks = ( TickType_t ) 0U;
  20:	2a a5       	ldd	r18, Y+42	; 0x2a
  22:	21 30       	cpi	r18, 0x01	; 1
  24:	01 f0       	breq	.+0      	; 0x26 <vTaskPriorityDisinheritAfterTimeout+0x26>
  26:	00 c0       	rjmp	.+0      	; 0x28 <vTaskPriorityDisinheritAfterTimeout+0x28>

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	9e 8b       	std	Y+22, r25	; 0x16
  2a:	2c 85       	ldd	r18, Y+12	; 0x0c
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	3d 85       	ldd	r19, Y+13	; 0x0d
  2e:	37 fd       	sbrc	r19, 7
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	00 c0       	rjmp	.+0      	; 0x32 <vTaskPriorityDisinheritAfterTimeout+0x32>
  32:	24 e0       	ldi	r18, 0x04	; 4
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	30 e0       	ldi	r19, 0x00	; 0
  36:	29 1b       	sub	r18, r25
  38:	31 09       	sbc	r19, r1
  3a:	3d 87       	std	Y+13, r19	; 0x0d

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	2c 87       	std	Y+12, r18	; 0x0c
  3e:	29 e0       	ldi	r18, 0x09	; 9
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	82 9f       	mul	r24, r18
  42:	c0 01       	movw	r24, r0
  44:	11 24       	eor	r1, r1
  46:	80 50       	subi	r24, 0x00	; 0
  48:	90 40       	sbci	r25, 0x00	; 0
  4a:	2a 85       	ldd	r18, Y+10	; 0x0a
  4c:	3b 85       	ldd	r19, Y+11	; 0x0b
  4e:	28 17       	cp	r18, r24
  50:	39 07       	cpc	r19, r25
  52:	01 f4       	brne	.+0      	; 0x54 <vTaskPriorityDisinheritAfterTimeout+0x54>
  54:	8e 01       	movw	r16, r28
  56:	0e 5f       	subi	r16, 0xFE	; 254
  58:	1f 4f       	sbci	r17, 0xFF	; 255
  5a:	c8 01       	movw	r24, r16
  5c:	0e 94 00 00 	call	0	; 0x0 <vTaskPriorityDisinheritAfterTimeout>
  60:	ae 89       	ldd	r26, Y+22	; 0x16
  62:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  66:	8a 17       	cp	r24, r26
  68:	00 f4       	brcc	.+0      	; 0x6a <vTaskPriorityDisinheritAfterTimeout+0x6a>
  6a:	a0 93 00 00 	sts	0x0000, r26	; 0x800000 <__SREG__+0x7fffc1>
  6e:	89 e0       	ldi	r24, 0x09	; 9
  70:	8a 9f       	mul	r24, r26
  72:	d0 01       	movw	r26, r0
  74:	11 24       	eor	r1, r1
  76:	a0 50       	subi	r26, 0x00	; 0
  78:	b0 40       	sbci	r27, 0x00	; 0
  7a:	11 96       	adiw	r26, 0x01	; 1
  7c:	0d 90       	ld	r0, X+
  7e:	bc 91       	ld	r27, X
  80:	a0 2d       	mov	r26, r0
  82:	bd 83       	std	Y+5, r27	; 0x05
  84:	ac 83       	std	Y+4, r26	; 0x04
  86:	14 96       	adiw	r26, 0x04	; 4
  88:	2d 91       	ld	r18, X+
  8a:	3c 91       	ld	r19, X
  8c:	15 97       	sbiw	r26, 0x05	; 5
  8e:	3f 83       	std	Y+7, r19	; 0x07
  90:	2e 83       	std	Y+6, r18	; 0x06
  92:	14 96       	adiw	r26, 0x04	; 4
  94:	ed 91       	ld	r30, X+
  96:	fc 91       	ld	r31, X
  98:	15 97       	sbiw	r26, 0x05	; 5
  9a:	13 83       	std	Z+3, r17	; 0x03
  9c:	02 83       	std	Z+2, r16	; 0x02
  9e:	15 96       	adiw	r26, 0x05	; 5
  a0:	1c 93       	st	X, r17
  a2:	0e 93       	st	-X, r16
  a4:	14 97       	sbiw	r26, 0x04	; 4
  a6:	ee 89       	ldd	r30, Y+22	; 0x16
  a8:	e8 9f       	mul	r30, r24
  aa:	f0 01       	movw	r30, r0
  ac:	11 24       	eor	r1, r1
  ae:	e0 50       	subi	r30, 0x00	; 0
  b0:	f0 40       	sbci	r31, 0x00	; 0
  b2:	fb 87       	std	Y+11, r31	; 0x0b
  b4:	ea 87       	std	Y+10, r30	; 0x0a
  b6:	80 81       	ld	r24, Z
  b8:	8f 5f       	subi	r24, 0xFF	; 255
  ba:	80 83       	st	Z, r24
  bc:	df 91       	pop	r29
  be:	cf 91       	pop	r28
  c0:	1f 91       	pop	r17
  c2:	0f 91       	pop	r16
  c4:	08 95       	ret

Disassembly of section .text.hot.uxTaskResetEventItemValue:

00000000 <uxTaskResetEventItemValue>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	84 85       	ldd	r24, Z+12	; 0x0c
   a:	95 85       	ldd	r25, Z+13	; 0x0d
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  14:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xSchedulerRunning = pdFALSE;
  1c:	56 96       	adiw	r26, 0x16	; 22
  1e:	4c 91       	ld	r20, X
    xPendedTicks = ( TickType_t ) 0U;
  20:	24 e0       	ldi	r18, 0x04	; 4
  22:	30 e0       	ldi	r19, 0x00	; 0
  24:	24 1b       	sub	r18, r20
  26:	31 09       	sbc	r19, r1

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	35 87       	std	Z+13, r19	; 0x0d
  2a:	24 87       	std	Z+12, r18	; 0x0c
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	08 95       	ret

Disassembly of section .text.hot.pvTaskIncrementMutexHeldCount:

00000000 <pvTaskIncrementMutexHeldCount>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	00 97       	sbiw	r24, 0x00	; 0
   a:	01 f0       	breq	.+0      	; 0xc <pvTaskIncrementMutexHeldCount+0xc>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	fc 01       	movw	r30, r24
   e:	22 a5       	ldd	r18, Z+42	; 0x2a
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	2f 5f       	subi	r18, 0xFF	; 255
  12:	22 a7       	std	Z+42, r18	; 0x2a
  14:	08 95       	ret

Disassembly of section .text.hot.ulTaskGenericNotifyTake:

00000000 <ulTaskGenericNotifyTake>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	c8 2f       	mov	r28, r24
  12:	e6 2e       	mov	r14, r22
  14:	6a 01       	movw	r12, r20
  16:	0e 94 00 00 	call	0	; 0x0 <ulTaskGenericNotifyTake>
    uxTopReadyPriority = tskIDLE_PRIORITY;
  1a:	0f b6       	in	r0, 0x3f	; 63
    xSchedulerRunning = pdFALSE;
  1c:	f8 94       	cli
  1e:	0f 92       	push	r0
    xPendedTicks = ( TickType_t ) 0U;
  20:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  24:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	d0 e0       	ldi	r29, 0x00	; 0
  2a:	8e 01       	movw	r16, r28
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	00 0f       	add	r16, r16
  2e:	11 1f       	adc	r17, r17
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	00 0f       	add	r16, r16
  32:	11 1f       	adc	r17, r17
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	e0 0f       	add	r30, r16
  36:	f1 1f       	adc	r31, r17
  38:	83 a5       	ldd	r24, Z+43	; 0x2b
  3a:	94 a5       	ldd	r25, Z+44	; 0x2c

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	a5 a5       	ldd	r26, Z+45	; 0x2d
  3e:	b6 a5       	ldd	r27, Z+46	; 0x2e
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	89 2b       	or	r24, r25
  42:	8a 2b       	or	r24, r26
  44:	8b 2b       	or	r24, r27
  46:	01 f4       	brne	.+0      	; 0x48 <ulTaskGenericNotifyTake+0x48>
  48:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  4c:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  50:	ec 0f       	add	r30, r28
  52:	fd 1f       	adc	r31, r29
  54:	81 e0       	ldi	r24, 0x01	; 1
  56:	87 a7       	std	Z+47, r24	; 0x2f
  58:	ff 24       	eor	r15, r15
  5a:	f3 94       	inc	r15
  5c:	c1 14       	cp	r12, r1
  5e:	d1 04       	cpc	r13, r1
  60:	01 f4       	brne	.+0      	; 0x62 <ulTaskGenericNotifyTake+0x62>
  62:	f1 2c       	mov	r15, r1
  64:	0f 90       	pop	r0
  66:	0f be       	out	0x3f, r0	; 63
  68:	21 e0       	ldi	r18, 0x01	; 1
  6a:	f2 12       	cpse	r15, r18
  6c:	00 c0       	rjmp	.+0      	; 0x6e <ulTaskGenericNotifyTake+0x6e>
  6e:	61 e0       	ldi	r22, 0x01	; 1
  70:	c6 01       	movw	r24, r12
  72:	0e 94 00 00 	call	0	; 0x0 <ulTaskGenericNotifyTake>
  76:	0e 94 00 00 	call	0	; 0x0 <ulTaskGenericNotifyTake>
  7a:	91 e0       	ldi	r25, 0x01	; 1
  7c:	f9 12       	cpse	r15, r25
  7e:	00 c0       	rjmp	.+0      	; 0x80 <ulTaskGenericNotifyTake+0x80>
  80:	81 11       	cpse	r24, r1
  82:	00 c0       	rjmp	.+0      	; 0x84 <ulTaskGenericNotifyTake+0x84>
  84:	0e 94 00 00 	call	0	; 0x0 <ulTaskGenericNotifyTake>
  88:	0f b6       	in	r0, 0x3f	; 63
  8a:	f8 94       	cli
  8c:	0f 92       	push	r0
  8e:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  92:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  96:	e0 0f       	add	r30, r16
  98:	f1 1f       	adc	r31, r17
  9a:	63 a5       	ldd	r22, Z+43	; 0x2b
  9c:	74 a5       	ldd	r23, Z+44	; 0x2c
  9e:	85 a5       	ldd	r24, Z+45	; 0x2d
  a0:	96 a5       	ldd	r25, Z+46	; 0x2e
  a2:	61 15       	cp	r22, r1
  a4:	71 05       	cpc	r23, r1
  a6:	81 05       	cpc	r24, r1
  a8:	91 05       	cpc	r25, r1
  aa:	01 f0       	breq	.+0      	; 0xac <ulTaskGenericNotifyTake+0xac>
  ac:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  b0:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  b4:	02 0f       	add	r16, r18
  b6:	13 1f       	adc	r17, r19
  b8:	ee 20       	and	r14, r14
  ba:	01 f0       	breq	.+0      	; 0xbc <ulTaskGenericNotifyTake+0xbc>
  bc:	f8 01       	movw	r30, r16
  be:	13 a6       	std	Z+43, r1	; 0x2b
  c0:	14 a6       	std	Z+44, r1	; 0x2c
  c2:	15 a6       	std	Z+45, r1	; 0x2d
  c4:	16 a6       	std	Z+46, r1	; 0x2e
  c6:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  ca:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  ce:	c2 0f       	add	r28, r18
  d0:	d3 1f       	adc	r29, r19
  d2:	1f a6       	std	Y+47, r1	; 0x2f
  d4:	0f 90       	pop	r0
  d6:	0f be       	out	0x3f, r0	; 63
  d8:	df 91       	pop	r29
  da:	cf 91       	pop	r28
  dc:	1f 91       	pop	r17
  de:	0f 91       	pop	r16
  e0:	ff 90       	pop	r15
  e2:	ef 90       	pop	r14
  e4:	df 90       	pop	r13
  e6:	cf 90       	pop	r12
  e8:	08 95       	ret
  ea:	6b 01       	movw	r12, r22
  ec:	7c 01       	movw	r14, r24
  ee:	f1 e0       	ldi	r31, 0x01	; 1
  f0:	cf 1a       	sub	r12, r31
  f2:	d1 08       	sbc	r13, r1
  f4:	e1 08       	sbc	r14, r1
  f6:	f1 08       	sbc	r15, r1
  f8:	f8 01       	movw	r30, r16
  fa:	c3 a6       	std	Z+43, r12	; 0x2b
  fc:	d4 a6       	std	Z+44, r13	; 0x2c
  fe:	e5 a6       	std	Z+45, r14	; 0x2d
 100:	f6 a6       	std	Z+46, r15	; 0x2e
 102:	00 c0       	rjmp	.+0      	; 0x104 <__SREG__+0xc5>

Disassembly of section .text.hot.xTaskGenericNotifyWait:

00000000 <xTaskGenericNotifyWait>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	4f 92       	push	r4
   2:	5f 92       	push	r5
   4:	6f 92       	push	r6
   6:	7f 92       	push	r7
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	8f 92       	push	r8
   a:	9f 92       	push	r9
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	af 92       	push	r10
   e:	bf 92       	push	r11
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	cf 92       	push	r12
  12:	df 92       	push	r13
  14:	ef 92       	push	r14
  16:	ff 92       	push	r15
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	0f 93       	push	r16
  1a:	1f 93       	push	r17
    xSchedulerRunning = pdFALSE;
  1c:	cf 93       	push	r28
  1e:	df 93       	push	r29
    xPendedTicks = ( TickType_t ) 0U;
  20:	c8 2f       	mov	r28, r24
  22:	2a 01       	movw	r4, r20
  24:	3b 01       	movw	r6, r22
  26:	48 01       	movw	r8, r16

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	59 01       	movw	r10, r18
  2a:	0e 94 00 00 	call	0	; 0x0 <xTaskGenericNotifyWait>
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2e:	0f b6       	in	r0, 0x3f	; 63
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	f8 94       	cli
  32:	0f 92       	push	r0
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  38:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	d0 e0       	ldi	r29, 0x00	; 0
  3e:	ec 0f       	add	r30, r28
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	fd 1f       	adc	r31, r29
  42:	87 a5       	ldd	r24, Z+47	; 0x2f
  44:	82 30       	cpi	r24, 0x02	; 2
  46:	01 f0       	breq	.+0      	; 0x48 <xTaskGenericNotifyWait+0x48>
  48:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  4c:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  50:	ce 01       	movw	r24, r28
  52:	88 0f       	add	r24, r24
  54:	99 1f       	adc	r25, r25
  56:	88 0f       	add	r24, r24
  58:	99 1f       	adc	r25, r25
  5a:	e8 0f       	add	r30, r24
  5c:	f9 1f       	adc	r31, r25
  5e:	83 a5       	ldd	r24, Z+43	; 0x2b
  60:	94 a5       	ldd	r25, Z+44	; 0x2c
  62:	a5 a5       	ldd	r26, Z+45	; 0x2d
  64:	b6 a5       	ldd	r27, Z+46	; 0x2e
  66:	40 94       	com	r4
  68:	50 94       	com	r5
  6a:	60 94       	com	r6
  6c:	70 94       	com	r7
  6e:	84 21       	and	r24, r4
  70:	95 21       	and	r25, r5
  72:	a6 21       	and	r26, r6
  74:	b7 21       	and	r27, r7
  76:	83 a7       	std	Z+43, r24	; 0x2b
  78:	94 a7       	std	Z+44, r25	; 0x2c
  7a:	a5 a7       	std	Z+45, r26	; 0x2d
  7c:	b6 a7       	std	Z+46, r27	; 0x2e
  7e:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  82:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  86:	ec 0f       	add	r30, r28
  88:	fd 1f       	adc	r31, r29
  8a:	81 e0       	ldi	r24, 0x01	; 1
  8c:	87 a7       	std	Z+47, r24	; 0x2f
  8e:	11 e0       	ldi	r17, 0x01	; 1
  90:	c1 14       	cp	r12, r1
  92:	d1 04       	cpc	r13, r1
  94:	01 f4       	brne	.+0      	; 0x96 <xTaskGenericNotifyWait+0x96>
  96:	10 e0       	ldi	r17, 0x00	; 0
  98:	0f 90       	pop	r0
  9a:	0f be       	out	0x3f, r0	; 63
  9c:	11 30       	cpi	r17, 0x01	; 1
  9e:	01 f4       	brne	.+0      	; 0xa0 <xTaskGenericNotifyWait+0xa0>
  a0:	61 e0       	ldi	r22, 0x01	; 1
  a2:	c6 01       	movw	r24, r12
  a4:	0e 94 00 00 	call	0	; 0x0 <xTaskGenericNotifyWait>
  a8:	0e 94 00 00 	call	0	; 0x0 <xTaskGenericNotifyWait>
  ac:	11 30       	cpi	r17, 0x01	; 1
  ae:	01 f4       	brne	.+0      	; 0xb0 <xTaskGenericNotifyWait+0xb0>
  b0:	81 11       	cpse	r24, r1
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <xTaskGenericNotifyWait+0xb4>
  b4:	0e 94 00 00 	call	0	; 0x0 <xTaskGenericNotifyWait>
  b8:	0f b6       	in	r0, 0x3f	; 63
  ba:	f8 94       	cli
  bc:	0f 92       	push	r0
  be:	e1 14       	cp	r14, r1
  c0:	f1 04       	cpc	r15, r1
  c2:	01 f0       	breq	.+0      	; 0xc4 <xTaskGenericNotifyWait+0xc4>
  c4:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  c8:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  cc:	ce 01       	movw	r24, r28
  ce:	88 0f       	add	r24, r24
  d0:	99 1f       	adc	r25, r25
  d2:	88 0f       	add	r24, r24
  d4:	99 1f       	adc	r25, r25
  d6:	e8 0f       	add	r30, r24
  d8:	f9 1f       	adc	r31, r25
  da:	83 a5       	ldd	r24, Z+43	; 0x2b
  dc:	94 a5       	ldd	r25, Z+44	; 0x2c
  de:	a5 a5       	ldd	r26, Z+45	; 0x2d
  e0:	b6 a5       	ldd	r27, Z+46	; 0x2e
  e2:	f7 01       	movw	r30, r14
  e4:	80 83       	st	Z, r24
  e6:	91 83       	std	Z+1, r25	; 0x01
  e8:	a2 83       	std	Z+2, r26	; 0x02
  ea:	b3 83       	std	Z+3, r27	; 0x03
  ec:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  f0:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  f4:	ec 0f       	add	r30, r28
  f6:	fd 1f       	adc	r31, r29
  f8:	87 a5       	ldd	r24, Z+47	; 0x2f
  fa:	82 30       	cpi	r24, 0x02	; 2
  fc:	01 f4       	brne	.+0      	; 0xfe <xTaskGenericNotifyWait+0xfe>
  fe:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 102:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 106:	ce 01       	movw	r24, r28
 108:	88 0f       	add	r24, r24
 10a:	99 1f       	adc	r25, r25
 10c:	88 0f       	add	r24, r24
 10e:	99 1f       	adc	r25, r25
 110:	e8 0f       	add	r30, r24
 112:	f9 1f       	adc	r31, r25
 114:	83 a5       	ldd	r24, Z+43	; 0x2b
 116:	94 a5       	ldd	r25, Z+44	; 0x2c
 118:	a5 a5       	ldd	r26, Z+45	; 0x2d
 11a:	b6 a5       	ldd	r27, Z+46	; 0x2e
 11c:	80 94       	com	r8
 11e:	90 94       	com	r9
 120:	a0 94       	com	r10
 122:	b0 94       	com	r11
 124:	88 21       	and	r24, r8
 126:	99 21       	and	r25, r9
 128:	aa 21       	and	r26, r10
 12a:	bb 21       	and	r27, r11
 12c:	83 a7       	std	Z+43, r24	; 0x2b
 12e:	94 a7       	std	Z+44, r25	; 0x2c
 130:	a5 a7       	std	Z+45, r26	; 0x2d
 132:	b6 a7       	std	Z+46, r27	; 0x2e
 134:	81 e0       	ldi	r24, 0x01	; 1
 136:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 13a:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 13e:	c2 0f       	add	r28, r18
 140:	d3 1f       	adc	r29, r19
 142:	1f a6       	std	Y+47, r1	; 0x2f
 144:	0f 90       	pop	r0
 146:	0f be       	out	0x3f, r0	; 63
 148:	df 91       	pop	r29
 14a:	cf 91       	pop	r28
 14c:	1f 91       	pop	r17
 14e:	0f 91       	pop	r16
 150:	ff 90       	pop	r15
 152:	ef 90       	pop	r14
 154:	df 90       	pop	r13
 156:	cf 90       	pop	r12
 158:	bf 90       	pop	r11
 15a:	af 90       	pop	r10
 15c:	9f 90       	pop	r9
 15e:	8f 90       	pop	r8
 160:	7f 90       	pop	r7
 162:	6f 90       	pop	r6
 164:	5f 90       	pop	r5
 166:	4f 90       	pop	r4
 168:	08 95       	ret
 16a:	80 e0       	ldi	r24, 0x00	; 0
 16c:	00 c0       	rjmp	.+0      	; 0x16e <__SREG__+0x12f>

Disassembly of section .text.hot.xTaskGenericNotify:

00000000 <xTaskGenericNotify>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
   6:	bf 92       	push	r11
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	cf 92       	push	r12
   a:	df 92       	push	r13
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	ef 92       	push	r14
   e:	ff 92       	push	r15
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	0f 93       	push	r16
  12:	1f 93       	push	r17
  14:	cf 93       	push	r28
  16:	df 93       	push	r29
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	dc 01       	movw	r26, r24
  1a:	0f b6       	in	r0, 0x3f	; 63
    xSchedulerRunning = pdFALSE;
  1c:	f8 94       	cli
  1e:	0f 92       	push	r0
    xPendedTicks = ( TickType_t ) 0U;
  20:	70 e0       	ldi	r23, 0x00	; 0
  22:	e1 14       	cp	r14, r1
  24:	f1 04       	cpc	r15, r1
  26:	01 f0       	breq	.+0      	; 0x28 <xTaskGenericNotify+0x28>

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	fb 01       	movw	r30, r22
  2a:	ee 0f       	add	r30, r30
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	ff 1f       	adc	r31, r31
  2e:	ee 0f       	add	r30, r30
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	ff 1f       	adc	r31, r31
  32:	e8 0f       	add	r30, r24
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	f9 1f       	adc	r31, r25
  36:	83 a4       	ldd	r8, Z+43	; 0x2b
  38:	94 a4       	ldd	r9, Z+44	; 0x2c
  3a:	a5 a4       	ldd	r10, Z+45	; 0x2d

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	b6 a4       	ldd	r11, Z+46	; 0x2e
  3e:	e7 01       	movw	r28, r14
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	88 82       	st	Y, r8
  42:	99 82       	std	Y+1, r9	; 0x01
  44:	aa 82       	std	Y+2, r10	; 0x02
  46:	bb 82       	std	Y+3, r11	; 0x03
  48:	fd 01       	movw	r30, r26
  4a:	e6 0f       	add	r30, r22
  4c:	f7 1f       	adc	r31, r23
  4e:	87 a5       	ldd	r24, Z+47	; 0x2f
  50:	92 e0       	ldi	r25, 0x02	; 2
  52:	97 a7       	std	Z+47, r25	; 0x2f
  54:	02 30       	cpi	r16, 0x02	; 2
  56:	11 05       	cpc	r17, r1
  58:	01 f4       	brne	.+0      	; 0x5a <xTaskGenericNotify+0x5a>
  5a:	00 c0       	rjmp	.+0      	; 0x5c <xTaskGenericNotify+0x5c>
  5c:	00 f4       	brcc	.+0      	; 0x5e <xTaskGenericNotify+0x5e>
  5e:	01 30       	cpi	r16, 0x01	; 1
  60:	11 05       	cpc	r17, r1
  62:	01 f0       	breq	.+0      	; 0x64 <xTaskGenericNotify+0x64>
  64:	81 30       	cpi	r24, 0x01	; 1
  66:	01 f4       	brne	.+0      	; 0x68 <xTaskGenericNotify+0x68>
  68:	00 c0       	rjmp	.+0      	; 0x6a <xTaskGenericNotify+0x6a>
  6a:	81 e0       	ldi	r24, 0x01	; 1
  6c:	0f 90       	pop	r0
  6e:	0f be       	out	0x3f, r0	; 63
  70:	df 91       	pop	r29
  72:	cf 91       	pop	r28
  74:	1f 91       	pop	r17
  76:	0f 91       	pop	r16
  78:	ff 90       	pop	r15
  7a:	ef 90       	pop	r14
  7c:	df 90       	pop	r13
  7e:	cf 90       	pop	r12
  80:	bf 90       	pop	r11
  82:	af 90       	pop	r10
  84:	9f 90       	pop	r9
  86:	8f 90       	pop	r8
  88:	08 95       	ret
  8a:	03 30       	cpi	r16, 0x03	; 3
  8c:	11 05       	cpc	r17, r1
  8e:	01 f0       	breq	.+0      	; 0x90 <xTaskGenericNotify+0x90>
  90:	04 30       	cpi	r16, 0x04	; 4
  92:	11 05       	cpc	r17, r1
  94:	01 f4       	brne	.+0      	; 0x96 <xTaskGenericNotify+0x96>
  96:	82 30       	cpi	r24, 0x02	; 2
  98:	01 f4       	brne	.+0      	; 0x9a <xTaskGenericNotify+0x9a>
  9a:	00 c0       	rjmp	.+0      	; 0x9c <xTaskGenericNotify+0x9c>
  9c:	66 0f       	add	r22, r22
  9e:	77 1f       	adc	r23, r23
  a0:	66 0f       	add	r22, r22
  a2:	77 1f       	adc	r23, r23
  a4:	fd 01       	movw	r30, r26
  a6:	e6 0f       	add	r30, r22
  a8:	f7 1f       	adc	r31, r23
  aa:	23 a7       	std	Z+43, r18	; 0x2b
  ac:	34 a7       	std	Z+44, r19	; 0x2c
  ae:	45 a7       	std	Z+45, r20	; 0x2d
  b0:	56 a7       	std	Z+46, r21	; 0x2e
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <xTaskGenericNotify+0xb4>
  b4:	66 0f       	add	r22, r22
  b6:	77 1f       	adc	r23, r23
  b8:	66 0f       	add	r22, r22
  ba:	77 1f       	adc	r23, r23
  bc:	fd 01       	movw	r30, r26
  be:	e6 0f       	add	r30, r22
  c0:	f7 1f       	adc	r31, r23
  c2:	c3 a4       	ldd	r12, Z+43	; 0x2b
  c4:	d4 a4       	ldd	r13, Z+44	; 0x2c
  c6:	e5 a4       	ldd	r14, Z+45	; 0x2d
  c8:	f6 a4       	ldd	r15, Z+46	; 0x2e
  ca:	c2 2a       	or	r12, r18
  cc:	d3 2a       	or	r13, r19
  ce:	e4 2a       	or	r14, r20
  d0:	f5 2a       	or	r15, r21
  d2:	c3 a6       	std	Z+43, r12	; 0x2b
  d4:	d4 a6       	std	Z+44, r13	; 0x2c
  d6:	e5 a6       	std	Z+45, r14	; 0x2d
  d8:	f6 a6       	std	Z+46, r15	; 0x2e
  da:	00 c0       	rjmp	.+0      	; 0xdc <xTaskGenericNotify+0xdc>
  dc:	66 0f       	add	r22, r22
  de:	77 1f       	adc	r23, r23
  e0:	66 0f       	add	r22, r22
  e2:	77 1f       	adc	r23, r23
  e4:	fd 01       	movw	r30, r26
  e6:	e6 0f       	add	r30, r22
  e8:	f7 1f       	adc	r31, r23
  ea:	43 a5       	ldd	r20, Z+43	; 0x2b
  ec:	54 a5       	ldd	r21, Z+44	; 0x2c
  ee:	65 a5       	ldd	r22, Z+45	; 0x2d
  f0:	76 a5       	ldd	r23, Z+46	; 0x2e
  f2:	4f 5f       	subi	r20, 0xFF	; 255
  f4:	5f 4f       	sbci	r21, 0xFF	; 255
  f6:	6f 4f       	sbci	r22, 0xFF	; 255
  f8:	7f 4f       	sbci	r23, 0xFF	; 255
  fa:	43 a7       	std	Z+43, r20	; 0x2b
  fc:	54 a7       	std	Z+44, r21	; 0x2c
  fe:	65 a7       	std	Z+45, r22	; 0x2d
 100:	76 a7       	std	Z+46, r23	; 0x2e
 102:	00 c0       	rjmp	.+0      	; 0x104 <xTaskGenericNotify+0x104>
 104:	1a 96       	adiw	r26, 0x0a	; 10
 106:	ed 91       	ld	r30, X+
 108:	fc 91       	ld	r31, X
 10a:	1b 97       	sbiw	r26, 0x0b	; 11
 10c:	14 96       	adiw	r26, 0x04	; 4
 10e:	8d 91       	ld	r24, X+
 110:	9c 91       	ld	r25, X
 112:	15 97       	sbiw	r26, 0x05	; 5
 114:	16 96       	adiw	r26, 0x06	; 6
 116:	2d 91       	ld	r18, X+
 118:	3c 91       	ld	r19, X
 11a:	17 97       	sbiw	r26, 0x07	; 7
 11c:	ec 01       	movw	r28, r24
 11e:	3d 83       	std	Y+5, r19	; 0x05
 120:	2c 83       	std	Y+4, r18	; 0x04
 122:	16 96       	adiw	r26, 0x06	; 6
 124:	cd 91       	ld	r28, X+
 126:	dc 91       	ld	r29, X
 128:	17 97       	sbiw	r26, 0x07	; 7
 12a:	9b 83       	std	Y+3, r25	; 0x03
 12c:	8a 83       	std	Y+2, r24	; 0x02
 12e:	9d 01       	movw	r18, r26
 130:	2e 5f       	subi	r18, 0xFE	; 254
 132:	3f 4f       	sbci	r19, 0xFF	; 255
 134:	81 81       	ldd	r24, Z+1	; 0x01
 136:	92 81       	ldd	r25, Z+2	; 0x02
 138:	82 17       	cp	r24, r18
 13a:	93 07       	cpc	r25, r19
 13c:	01 f4       	brne	.+0      	; 0x13e <xTaskGenericNotify+0x13e>
 13e:	d2 83       	std	Z+2, r29	; 0x02
 140:	c1 83       	std	Z+1, r28	; 0x01
 142:	1b 96       	adiw	r26, 0x0b	; 11
 144:	1c 92       	st	X, r1
 146:	1e 92       	st	-X, r1
 148:	1a 97       	sbiw	r26, 0x0a	; 10
 14a:	80 81       	ld	r24, Z
 14c:	81 50       	subi	r24, 0x01	; 1
 14e:	80 83       	st	Z, r24
 150:	56 96       	adiw	r26, 0x16	; 22
 152:	cc 91       	ld	r28, X
 154:	56 97       	sbiw	r26, 0x16	; 22
 156:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 15a:	8c 17       	cp	r24, r28
 15c:	00 f4       	brcc	.+0      	; 0x15e <xTaskGenericNotify+0x15e>
 15e:	c0 93 00 00 	sts	0x0000, r28	; 0x800000 <__SREG__+0x7fffc1>
 162:	49 e0       	ldi	r20, 0x09	; 9
 164:	4c 9f       	mul	r20, r28
 166:	e0 01       	movw	r28, r0
 168:	11 24       	eor	r1, r1
 16a:	c0 50       	subi	r28, 0x00	; 0
 16c:	d0 40       	sbci	r29, 0x00	; 0
 16e:	09 80       	ldd	r0, Y+1	; 0x01
 170:	da 81       	ldd	r29, Y+2	; 0x02
 172:	c0 2d       	mov	r28, r0
 174:	15 96       	adiw	r26, 0x05	; 5
 176:	dc 93       	st	X, r29
 178:	ce 93       	st	-X, r28
 17a:	14 97       	sbiw	r26, 0x04	; 4
 17c:	8c 81       	ldd	r24, Y+4	; 0x04
 17e:	9d 81       	ldd	r25, Y+5	; 0x05
 180:	17 96       	adiw	r26, 0x07	; 7
 182:	9c 93       	st	X, r25
 184:	8e 93       	st	-X, r24
 186:	16 97       	sbiw	r26, 0x06	; 6
 188:	8c 81       	ldd	r24, Y+4	; 0x04
 18a:	9d 81       	ldd	r25, Y+5	; 0x05
 18c:	fc 01       	movw	r30, r24
 18e:	33 83       	std	Z+3, r19	; 0x03
 190:	22 83       	std	Z+2, r18	; 0x02
 192:	3d 83       	std	Y+5, r19	; 0x05
 194:	2c 83       	std	Y+4, r18	; 0x04
 196:	56 96       	adiw	r26, 0x16	; 22
 198:	9c 91       	ld	r25, X
 19a:	56 97       	sbiw	r26, 0x16	; 22
 19c:	94 9f       	mul	r25, r20
 19e:	f0 01       	movw	r30, r0
 1a0:	11 24       	eor	r1, r1
 1a2:	e0 50       	subi	r30, 0x00	; 0
 1a4:	f0 40       	sbci	r31, 0x00	; 0
 1a6:	1b 96       	adiw	r26, 0x0b	; 11
 1a8:	fc 93       	st	X, r31
 1aa:	ee 93       	st	-X, r30
 1ac:	1a 97       	sbiw	r26, 0x0a	; 10
 1ae:	80 81       	ld	r24, Z
 1b0:	8f 5f       	subi	r24, 0xFF	; 255
 1b2:	80 83       	st	Z, r24
 1b4:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1b8:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1bc:	86 89       	ldd	r24, Z+22	; 0x16
 1be:	89 17       	cp	r24, r25
 1c0:	00 f0       	brcs	.+0      	; 0x1c2 <xTaskGenericNotify+0x1c2>
 1c2:	00 c0       	rjmp	.+0      	; 0x1c4 <xTaskGenericNotify+0x1c4>
 1c4:	0e 94 00 00 	call	0	; 0x0 <xTaskGenericNotify>
 1c8:	00 c0       	rjmp	.+0      	; 0x1ca <xTaskGenericNotify+0x1ca>
 1ca:	80 e0       	ldi	r24, 0x00	; 0
 1cc:	00 c0       	rjmp	.+0      	; 0x1ce <__SREG__+0x18f>

Disassembly of section .text.hot.xTaskGenericNotifyFromISR:

00000000 <xTaskGenericNotifyFromISR>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
   6:	bf 92       	push	r11
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	cf 92       	push	r12
   a:	df 92       	push	r13
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	ef 92       	push	r14
   e:	ff 92       	push	r15
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	0f 93       	push	r16
  12:	1f 93       	push	r17
  14:	cf 93       	push	r28
  16:	df 93       	push	r29
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	dc 01       	movw	r26, r24
  1a:	70 e0       	ldi	r23, 0x00	; 0
    xSchedulerRunning = pdFALSE;
  1c:	e1 14       	cp	r14, r1
  1e:	f1 04       	cpc	r15, r1
    xPendedTicks = ( TickType_t ) 0U;
  20:	01 f0       	breq	.+0      	; 0x22 <xTaskGenericNotifyFromISR+0x22>
  22:	fb 01       	movw	r30, r22
  24:	ee 0f       	add	r30, r30
  26:	ff 1f       	adc	r31, r31

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	ee 0f       	add	r30, r30
  2a:	ff 1f       	adc	r31, r31
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	e8 0f       	add	r30, r24
  2e:	f9 1f       	adc	r31, r25
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	83 a4       	ldd	r8, Z+43	; 0x2b
  32:	94 a4       	ldd	r9, Z+44	; 0x2c
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	a5 a4       	ldd	r10, Z+45	; 0x2d
  36:	b6 a4       	ldd	r11, Z+46	; 0x2e
  38:	e7 01       	movw	r28, r14
  3a:	88 82       	st	Y, r8

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	99 82       	std	Y+1, r9	; 0x01
  3e:	aa 82       	std	Y+2, r10	; 0x02
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	bb 82       	std	Y+3, r11	; 0x03
  42:	fd 01       	movw	r30, r26
  44:	e6 0f       	add	r30, r22
  46:	f7 1f       	adc	r31, r23
  48:	87 a5       	ldd	r24, Z+47	; 0x2f
  4a:	92 e0       	ldi	r25, 0x02	; 2
  4c:	97 a7       	std	Z+47, r25	; 0x2f
  4e:	02 30       	cpi	r16, 0x02	; 2
  50:	11 05       	cpc	r17, r1
  52:	01 f0       	breq	.+0      	; 0x54 <xTaskGenericNotifyFromISR+0x54>
  54:	00 f4       	brcc	.+0      	; 0x56 <xTaskGenericNotifyFromISR+0x56>
  56:	01 30       	cpi	r16, 0x01	; 1
  58:	11 05       	cpc	r17, r1
  5a:	01 f0       	breq	.+0      	; 0x5c <xTaskGenericNotifyFromISR+0x5c>
  5c:	81 30       	cpi	r24, 0x01	; 1
  5e:	01 f4       	brne	.+0      	; 0x60 <xTaskGenericNotifyFromISR+0x60>
  60:	00 c0       	rjmp	.+0      	; 0x62 <xTaskGenericNotifyFromISR+0x62>
  62:	81 e0       	ldi	r24, 0x01	; 1
  64:	df 91       	pop	r29
  66:	cf 91       	pop	r28
  68:	1f 91       	pop	r17
  6a:	0f 91       	pop	r16
  6c:	ff 90       	pop	r15
  6e:	ef 90       	pop	r14
  70:	df 90       	pop	r13
  72:	cf 90       	pop	r12
  74:	bf 90       	pop	r11
  76:	af 90       	pop	r10
  78:	9f 90       	pop	r9
  7a:	8f 90       	pop	r8
  7c:	08 95       	ret
  7e:	03 30       	cpi	r16, 0x03	; 3
  80:	11 05       	cpc	r17, r1
  82:	01 f0       	breq	.+0      	; 0x84 <xTaskGenericNotifyFromISR+0x84>
  84:	04 30       	cpi	r16, 0x04	; 4
  86:	11 05       	cpc	r17, r1
  88:	01 f4       	brne	.+0      	; 0x8a <xTaskGenericNotifyFromISR+0x8a>
  8a:	82 30       	cpi	r24, 0x02	; 2
  8c:	01 f4       	brne	.+0      	; 0x8e <xTaskGenericNotifyFromISR+0x8e>
  8e:	00 c0       	rjmp	.+0      	; 0x90 <xTaskGenericNotifyFromISR+0x90>
  90:	66 0f       	add	r22, r22
  92:	77 1f       	adc	r23, r23
  94:	66 0f       	add	r22, r22
  96:	77 1f       	adc	r23, r23
  98:	fd 01       	movw	r30, r26
  9a:	e6 0f       	add	r30, r22
  9c:	f7 1f       	adc	r31, r23
  9e:	23 a7       	std	Z+43, r18	; 0x2b
  a0:	34 a7       	std	Z+44, r19	; 0x2c
  a2:	45 a7       	std	Z+45, r20	; 0x2d
  a4:	56 a7       	std	Z+46, r21	; 0x2e
  a6:	00 c0       	rjmp	.+0      	; 0xa8 <xTaskGenericNotifyFromISR+0xa8>
  a8:	66 0f       	add	r22, r22
  aa:	77 1f       	adc	r23, r23
  ac:	66 0f       	add	r22, r22
  ae:	77 1f       	adc	r23, r23
  b0:	fd 01       	movw	r30, r26
  b2:	e6 0f       	add	r30, r22
  b4:	f7 1f       	adc	r31, r23
  b6:	83 a4       	ldd	r8, Z+43	; 0x2b
  b8:	94 a4       	ldd	r9, Z+44	; 0x2c
  ba:	a5 a4       	ldd	r10, Z+45	; 0x2d
  bc:	b6 a4       	ldd	r11, Z+46	; 0x2e
  be:	82 2a       	or	r8, r18
  c0:	93 2a       	or	r9, r19
  c2:	a4 2a       	or	r10, r20
  c4:	b5 2a       	or	r11, r21
  c6:	83 a6       	std	Z+43, r8	; 0x2b
  c8:	94 a6       	std	Z+44, r9	; 0x2c
  ca:	a5 a6       	std	Z+45, r10	; 0x2d
  cc:	b6 a6       	std	Z+46, r11	; 0x2e
  ce:	00 c0       	rjmp	.+0      	; 0xd0 <xTaskGenericNotifyFromISR+0xd0>
  d0:	66 0f       	add	r22, r22
  d2:	77 1f       	adc	r23, r23
  d4:	66 0f       	add	r22, r22
  d6:	77 1f       	adc	r23, r23
  d8:	fd 01       	movw	r30, r26
  da:	e6 0f       	add	r30, r22
  dc:	f7 1f       	adc	r31, r23
  de:	43 a5       	ldd	r20, Z+43	; 0x2b
  e0:	54 a5       	ldd	r21, Z+44	; 0x2c
  e2:	65 a5       	ldd	r22, Z+45	; 0x2d
  e4:	76 a5       	ldd	r23, Z+46	; 0x2e
  e6:	4f 5f       	subi	r20, 0xFF	; 255
  e8:	5f 4f       	sbci	r21, 0xFF	; 255
  ea:	6f 4f       	sbci	r22, 0xFF	; 255
  ec:	7f 4f       	sbci	r23, 0xFF	; 255
  ee:	43 a7       	std	Z+43, r20	; 0x2b
  f0:	54 a7       	std	Z+44, r21	; 0x2c
  f2:	65 a7       	std	Z+45, r22	; 0x2d
  f4:	76 a7       	std	Z+46, r23	; 0x2e
  f6:	00 c0       	rjmp	.+0      	; 0xf8 <xTaskGenericNotifyFromISR+0xf8>
  f8:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  fc:	81 11       	cpse	r24, r1
  fe:	00 c0       	rjmp	.+0      	; 0x100 <xTaskGenericNotifyFromISR+0x100>
 100:	1a 96       	adiw	r26, 0x0a	; 10
 102:	ed 91       	ld	r30, X+
 104:	fc 91       	ld	r31, X
 106:	1b 97       	sbiw	r26, 0x0b	; 11
 108:	14 96       	adiw	r26, 0x04	; 4
 10a:	8d 91       	ld	r24, X+
 10c:	9c 91       	ld	r25, X
 10e:	15 97       	sbiw	r26, 0x05	; 5
 110:	16 96       	adiw	r26, 0x06	; 6
 112:	2d 91       	ld	r18, X+
 114:	3c 91       	ld	r19, X
 116:	17 97       	sbiw	r26, 0x07	; 7
 118:	ec 01       	movw	r28, r24
 11a:	3d 83       	std	Y+5, r19	; 0x05
 11c:	2c 83       	std	Y+4, r18	; 0x04
 11e:	16 96       	adiw	r26, 0x06	; 6
 120:	cd 91       	ld	r28, X+
 122:	dc 91       	ld	r29, X
 124:	17 97       	sbiw	r26, 0x07	; 7
 126:	9b 83       	std	Y+3, r25	; 0x03
 128:	8a 83       	std	Y+2, r24	; 0x02
 12a:	9d 01       	movw	r18, r26
 12c:	2e 5f       	subi	r18, 0xFE	; 254
 12e:	3f 4f       	sbci	r19, 0xFF	; 255
 130:	81 81       	ldd	r24, Z+1	; 0x01
 132:	92 81       	ldd	r25, Z+2	; 0x02
 134:	82 17       	cp	r24, r18
 136:	93 07       	cpc	r25, r19
 138:	01 f4       	brne	.+0      	; 0x13a <xTaskGenericNotifyFromISR+0x13a>
 13a:	d2 83       	std	Z+2, r29	; 0x02
 13c:	c1 83       	std	Z+1, r28	; 0x01
 13e:	1b 96       	adiw	r26, 0x0b	; 11
 140:	1c 92       	st	X, r1
 142:	1e 92       	st	-X, r1
 144:	1a 97       	sbiw	r26, 0x0a	; 10
 146:	80 81       	ld	r24, Z
 148:	81 50       	subi	r24, 0x01	; 1
 14a:	80 83       	st	Z, r24
 14c:	56 96       	adiw	r26, 0x16	; 22
 14e:	cc 91       	ld	r28, X
 150:	56 97       	sbiw	r26, 0x16	; 22
 152:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 156:	8c 17       	cp	r24, r28
 158:	00 f4       	brcc	.+0      	; 0x15a <xTaskGenericNotifyFromISR+0x15a>
 15a:	c0 93 00 00 	sts	0x0000, r28	; 0x800000 <__SREG__+0x7fffc1>
 15e:	89 e0       	ldi	r24, 0x09	; 9
 160:	8c 9f       	mul	r24, r28
 162:	e0 01       	movw	r28, r0
 164:	11 24       	eor	r1, r1
 166:	c0 50       	subi	r28, 0x00	; 0
 168:	d0 40       	sbci	r29, 0x00	; 0
 16a:	09 80       	ldd	r0, Y+1	; 0x01
 16c:	da 81       	ldd	r29, Y+2	; 0x02
 16e:	c0 2d       	mov	r28, r0
 170:	15 96       	adiw	r26, 0x05	; 5
 172:	dc 93       	st	X, r29
 174:	ce 93       	st	-X, r28
 176:	14 97       	sbiw	r26, 0x04	; 4
 178:	4c 81       	ldd	r20, Y+4	; 0x04
 17a:	5d 81       	ldd	r21, Y+5	; 0x05
 17c:	17 96       	adiw	r26, 0x07	; 7
 17e:	5c 93       	st	X, r21
 180:	4e 93       	st	-X, r20
 182:	16 97       	sbiw	r26, 0x06	; 6
 184:	ec 81       	ldd	r30, Y+4	; 0x04
 186:	fd 81       	ldd	r31, Y+5	; 0x05
 188:	33 83       	std	Z+3, r19	; 0x03
 18a:	22 83       	std	Z+2, r18	; 0x02
 18c:	3d 83       	std	Y+5, r19	; 0x05
 18e:	2c 83       	std	Y+4, r18	; 0x04
 190:	56 96       	adiw	r26, 0x16	; 22
 192:	ec 91       	ld	r30, X
 194:	56 97       	sbiw	r26, 0x16	; 22
 196:	e8 9f       	mul	r30, r24
 198:	f0 01       	movw	r30, r0
 19a:	11 24       	eor	r1, r1
 19c:	e0 50       	subi	r30, 0x00	; 0
 19e:	f0 40       	sbci	r31, 0x00	; 0
 1a0:	1b 96       	adiw	r26, 0x0b	; 11
 1a2:	fc 93       	st	X, r31
 1a4:	ee 93       	st	-X, r30
 1a6:	1a 97       	sbiw	r26, 0x0a	; 10
 1a8:	80 81       	ld	r24, Z
 1aa:	8f 5f       	subi	r24, 0xFF	; 255
 1ac:	80 83       	st	Z, r24
 1ae:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1b2:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1b6:	56 96       	adiw	r26, 0x16	; 22
 1b8:	9c 91       	ld	r25, X
 1ba:	86 89       	ldd	r24, Z+22	; 0x16
 1bc:	89 17       	cp	r24, r25
 1be:	00 f0       	brcs	.+0      	; 0x1c0 <xTaskGenericNotifyFromISR+0x1c0>
 1c0:	00 c0       	rjmp	.+0      	; 0x1c2 <xTaskGenericNotifyFromISR+0x1c2>
 1c2:	c1 14       	cp	r12, r1
 1c4:	d1 04       	cpc	r13, r1
 1c6:	01 f0       	breq	.+0      	; 0x1c8 <xTaskGenericNotifyFromISR+0x1c8>
 1c8:	81 e0       	ldi	r24, 0x01	; 1
 1ca:	f6 01       	movw	r30, r12
 1cc:	80 83       	st	Z, r24
 1ce:	81 e0       	ldi	r24, 0x01	; 1
 1d0:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
 1d4:	00 c0       	rjmp	.+0      	; 0x1d6 <xTaskGenericNotifyFromISR+0x1d6>
 1d6:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1da:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 1de:	1f 96       	adiw	r26, 0x0f	; 15
 1e0:	fc 93       	st	X, r31
 1e2:	ee 93       	st	-X, r30
 1e4:	1e 97       	sbiw	r26, 0x0e	; 14
 1e6:	84 81       	ldd	r24, Z+4	; 0x04
 1e8:	95 81       	ldd	r25, Z+5	; 0x05
 1ea:	51 96       	adiw	r26, 0x11	; 17
 1ec:	9c 93       	st	X, r25
 1ee:	8e 93       	st	-X, r24
 1f0:	50 97       	sbiw	r26, 0x10	; 16
 1f2:	c4 81       	ldd	r28, Z+4	; 0x04
 1f4:	d5 81       	ldd	r29, Z+5	; 0x05
 1f6:	cd 01       	movw	r24, r26
 1f8:	0c 96       	adiw	r24, 0x0c	; 12
 1fa:	9b 83       	std	Y+3, r25	; 0x03
 1fc:	8a 83       	std	Y+2, r24	; 0x02
 1fe:	95 83       	std	Z+5, r25	; 0x05
 200:	84 83       	std	Z+4, r24	; 0x04
 202:	80 e0       	ldi	r24, 0x00	; 0
 204:	90 e0       	ldi	r25, 0x00	; 0
 206:	55 96       	adiw	r26, 0x15	; 21
 208:	9c 93       	st	X, r25
 20a:	8e 93       	st	-X, r24
 20c:	54 97       	sbiw	r26, 0x14	; 20
 20e:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 212:	8f 5f       	subi	r24, 0xFF	; 255
 214:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
 218:	00 c0       	rjmp	.+0      	; 0x21a <xTaskGenericNotifyFromISR+0x21a>
 21a:	80 e0       	ldi	r24, 0x00	; 0
 21c:	00 c0       	rjmp	.+0      	; 0x21e <__SREG__+0x1df>

Disassembly of section .text.hot.vTaskGenericNotifyGiveFromISR:

00000000 <vTaskGenericNotifyGiveFromISR>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	fc 01       	movw	r30, r24
   a:	a6 2f       	mov	r26, r22
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	b0 e0       	ldi	r27, 0x00	; 0
   e:	ec 01       	movw	r28, r24
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	ca 0f       	add	r28, r26
  12:	db 1f       	adc	r29, r27
  14:	8f a5       	ldd	r24, Y+47	; 0x2f
  16:	92 e0       	ldi	r25, 0x02	; 2
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	9f a7       	std	Y+47, r25	; 0x2f
  1a:	aa 0f       	add	r26, r26
    xSchedulerRunning = pdFALSE;
  1c:	bb 1f       	adc	r27, r27
  1e:	aa 0f       	add	r26, r26
    xPendedTicks = ( TickType_t ) 0U;
  20:	bb 1f       	adc	r27, r27
  22:	ae 0f       	add	r26, r30
  24:	bf 1f       	adc	r27, r31
  26:	9b 96       	adiw	r26, 0x2b	; 43

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	0d 91       	ld	r16, X+
  2a:	1d 91       	ld	r17, X+
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	2d 91       	ld	r18, X+
  2e:	3c 91       	ld	r19, X
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	9e 97       	sbiw	r26, 0x2e	; 46
  32:	0f 5f       	subi	r16, 0xFF	; 255
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	1f 4f       	sbci	r17, 0xFF	; 255
  36:	2f 4f       	sbci	r18, 0xFF	; 255
  38:	3f 4f       	sbci	r19, 0xFF	; 255
  3a:	9b 96       	adiw	r26, 0x2b	; 43

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	0d 93       	st	X+, r16
  3e:	1d 93       	st	X+, r17
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	2d 93       	st	X+, r18
  42:	3c 93       	st	X, r19
  44:	9e 97       	sbiw	r26, 0x2e	; 46
  46:	81 30       	cpi	r24, 0x01	; 1
  48:	01 f0       	breq	.+0      	; 0x4a <vTaskGenericNotifyGiveFromISR+0x4a>
  4a:	00 c0       	rjmp	.+0      	; 0x4c <vTaskGenericNotifyGiveFromISR+0x4c>
  4c:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  50:	81 11       	cpse	r24, r1
  52:	00 c0       	rjmp	.+0      	; 0x54 <vTaskGenericNotifyGiveFromISR+0x54>
  54:	a2 85       	ldd	r26, Z+10	; 0x0a
  56:	b3 85       	ldd	r27, Z+11	; 0x0b
  58:	84 81       	ldd	r24, Z+4	; 0x04
  5a:	95 81       	ldd	r25, Z+5	; 0x05
  5c:	26 81       	ldd	r18, Z+6	; 0x06
  5e:	37 81       	ldd	r19, Z+7	; 0x07
  60:	ec 01       	movw	r28, r24
  62:	3d 83       	std	Y+5, r19	; 0x05
  64:	2c 83       	std	Y+4, r18	; 0x04
  66:	c6 81       	ldd	r28, Z+6	; 0x06
  68:	d7 81       	ldd	r29, Z+7	; 0x07
  6a:	9b 83       	std	Y+3, r25	; 0x03
  6c:	8a 83       	std	Y+2, r24	; 0x02
  6e:	cf 01       	movw	r24, r30
  70:	02 96       	adiw	r24, 0x02	; 2
  72:	11 96       	adiw	r26, 0x01	; 1
  74:	2d 91       	ld	r18, X+
  76:	3c 91       	ld	r19, X
  78:	12 97       	sbiw	r26, 0x02	; 2
  7a:	28 17       	cp	r18, r24
  7c:	39 07       	cpc	r19, r25
  7e:	01 f4       	brne	.+0      	; 0x80 <vTaskGenericNotifyGiveFromISR+0x80>
  80:	12 96       	adiw	r26, 0x02	; 2
  82:	dc 93       	st	X, r29
  84:	ce 93       	st	-X, r28
  86:	11 97       	sbiw	r26, 0x01	; 1
  88:	13 86       	std	Z+11, r1	; 0x0b
  8a:	12 86       	std	Z+10, r1	; 0x0a
  8c:	2c 91       	ld	r18, X
  8e:	21 50       	subi	r18, 0x01	; 1
  90:	2c 93       	st	X, r18
  92:	c6 89       	ldd	r28, Z+22	; 0x16
  94:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  98:	2c 17       	cp	r18, r28
  9a:	00 f4       	brcc	.+0      	; 0x9c <vTaskGenericNotifyGiveFromISR+0x9c>
  9c:	c0 93 00 00 	sts	0x0000, r28	; 0x800000 <__SREG__+0x7fffc1>
  a0:	29 e0       	ldi	r18, 0x09	; 9
  a2:	2c 9f       	mul	r18, r28
  a4:	e0 01       	movw	r28, r0
  a6:	11 24       	eor	r1, r1
  a8:	c0 50       	subi	r28, 0x00	; 0
  aa:	d0 40       	sbci	r29, 0x00	; 0
  ac:	09 80       	ldd	r0, Y+1	; 0x01
  ae:	da 81       	ldd	r29, Y+2	; 0x02
  b0:	c0 2d       	mov	r28, r0
  b2:	d5 83       	std	Z+5, r29	; 0x05
  b4:	c4 83       	std	Z+4, r28	; 0x04
  b6:	6c 81       	ldd	r22, Y+4	; 0x04
  b8:	7d 81       	ldd	r23, Y+5	; 0x05
  ba:	77 83       	std	Z+7, r23	; 0x07
  bc:	66 83       	std	Z+6, r22	; 0x06
  be:	ac 81       	ldd	r26, Y+4	; 0x04
  c0:	bd 81       	ldd	r27, Y+5	; 0x05
  c2:	13 96       	adiw	r26, 0x03	; 3
  c4:	9c 93       	st	X, r25
  c6:	8e 93       	st	-X, r24
  c8:	12 97       	sbiw	r26, 0x02	; 2
  ca:	9d 83       	std	Y+5, r25	; 0x05
  cc:	8c 83       	std	Y+4, r24	; 0x04
  ce:	a6 89       	ldd	r26, Z+22	; 0x16
  d0:	a2 9f       	mul	r26, r18
  d2:	d0 01       	movw	r26, r0
  d4:	11 24       	eor	r1, r1
  d6:	a0 50       	subi	r26, 0x00	; 0
  d8:	b0 40       	sbci	r27, 0x00	; 0
  da:	b3 87       	std	Z+11, r27	; 0x0b
  dc:	a2 87       	std	Z+10, r26	; 0x0a
  de:	8c 91       	ld	r24, X
  e0:	8f 5f       	subi	r24, 0xFF	; 255
  e2:	8c 93       	st	X, r24
  e4:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  e8:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  ec:	96 89       	ldd	r25, Z+22	; 0x16
  ee:	56 96       	adiw	r26, 0x16	; 22
  f0:	8c 91       	ld	r24, X
  f2:	89 17       	cp	r24, r25
  f4:	00 f4       	brcc	.+0      	; 0xf6 <vTaskGenericNotifyGiveFromISR+0xf6>
  f6:	41 15       	cp	r20, r1
  f8:	51 05       	cpc	r21, r1
  fa:	01 f0       	breq	.+0      	; 0xfc <vTaskGenericNotifyGiveFromISR+0xfc>
  fc:	81 e0       	ldi	r24, 0x01	; 1
  fe:	fa 01       	movw	r30, r20
 100:	80 83       	st	Z, r24
 102:	81 e0       	ldi	r24, 0x01	; 1
 104:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
 108:	df 91       	pop	r29
 10a:	cf 91       	pop	r28
 10c:	1f 91       	pop	r17
 10e:	0f 91       	pop	r16
 110:	08 95       	ret
 112:	a0 91 00 00 	lds	r26, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 116:	b0 91 00 00 	lds	r27, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 11a:	b7 87       	std	Z+15, r27	; 0x0f
 11c:	a6 87       	std	Z+14, r26	; 0x0e
 11e:	14 96       	adiw	r26, 0x04	; 4
 120:	8d 91       	ld	r24, X+
 122:	9c 91       	ld	r25, X
 124:	15 97       	sbiw	r26, 0x05	; 5
 126:	91 8b       	std	Z+17, r25	; 0x11
 128:	80 8b       	std	Z+16, r24	; 0x10
 12a:	14 96       	adiw	r26, 0x04	; 4
 12c:	cd 91       	ld	r28, X+
 12e:	dc 91       	ld	r29, X
 130:	15 97       	sbiw	r26, 0x05	; 5
 132:	cf 01       	movw	r24, r30
 134:	0c 96       	adiw	r24, 0x0c	; 12
 136:	9b 83       	std	Y+3, r25	; 0x03
 138:	8a 83       	std	Y+2, r24	; 0x02
 13a:	15 96       	adiw	r26, 0x05	; 5
 13c:	9c 93       	st	X, r25
 13e:	8e 93       	st	-X, r24
 140:	14 97       	sbiw	r26, 0x04	; 4
 142:	80 e0       	ldi	r24, 0x00	; 0
 144:	90 e0       	ldi	r25, 0x00	; 0
 146:	95 8b       	std	Z+21, r25	; 0x15
 148:	84 8b       	std	Z+20, r24	; 0x14
 14a:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 14e:	8f 5f       	subi	r24, 0xFF	; 255
 150:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
 154:	00 c0       	rjmp	.+0      	; 0x156 <__SREG__+0x117>

Disassembly of section .text.hot.xTaskGenericNotifyStateClear:

00000000 <xTaskGenericNotifyStateClear>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	00 97       	sbiw	r24, 0x00	; 0
   2:	01 f4       	brne	.+0      	; 0x4 <xTaskGenericNotifyStateClear+0x4>
   4:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	0f b6       	in	r0, 0x3f	; 63
   e:	f8 94       	cli
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	0f 92       	push	r0
  12:	fc 01       	movw	r30, r24
  14:	e6 0f       	add	r30, r22
  16:	f1 1d       	adc	r31, r1
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	87 a5       	ldd	r24, Z+47	; 0x2f
  1a:	82 30       	cpi	r24, 0x02	; 2
    xSchedulerRunning = pdFALSE;
  1c:	01 f4       	brne	.+0      	; 0x1e <xTaskGenericNotifyStateClear+0x1e>
  1e:	17 a6       	std	Z+47, r1	; 0x2f
    xPendedTicks = ( TickType_t ) 0U;
  20:	81 e0       	ldi	r24, 0x01	; 1
  22:	0f 90       	pop	r0
  24:	0f be       	out	0x3f, r0	; 63
  26:	08 95       	ret

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	80 e0       	ldi	r24, 0x00	; 0
  2a:	00 c0       	rjmp	.+0      	; 0x2c <__zero_reg__+0x2b>

Disassembly of section .text.hot.ulTaskGenericNotifyValueClear:

00000000 <ulTaskGenericNotifyValueClear>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	00 97       	sbiw	r24, 0x00	; 0
   a:	01 f4       	brne	.+0      	; 0xc <ulTaskGenericNotifyValueClear+0xc>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  14:	0f b6       	in	r0, 0x3f	; 63
  16:	f8 94       	cli
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	0f 92       	push	r0
  1a:	74 e0       	ldi	r23, 0x04	; 4
    xSchedulerRunning = pdFALSE;
  1c:	67 9f       	mul	r22, r23
  1e:	f0 01       	movw	r30, r0
    xPendedTicks = ( TickType_t ) 0U;
  20:	11 24       	eor	r1, r1
  22:	e8 0f       	add	r30, r24
  24:	f9 1f       	adc	r31, r25
  26:	63 a5       	ldd	r22, Z+43	; 0x2b

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	74 a5       	ldd	r23, Z+44	; 0x2c
  2a:	85 a5       	ldd	r24, Z+45	; 0x2d
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	96 a5       	ldd	r25, Z+46	; 0x2e
  2e:	c3 a4       	ldd	r12, Z+43	; 0x2b
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	d4 a4       	ldd	r13, Z+44	; 0x2c
  32:	e5 a4       	ldd	r14, Z+45	; 0x2d
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	f6 a4       	ldd	r15, Z+46	; 0x2e
  36:	20 95       	com	r18
  38:	30 95       	com	r19
  3a:	40 95       	com	r20

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	50 95       	com	r21
  3e:	c2 22       	and	r12, r18
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	d3 22       	and	r13, r19
  42:	e4 22       	and	r14, r20
  44:	f5 22       	and	r15, r21
  46:	c3 a6       	std	Z+43, r12	; 0x2b
  48:	d4 a6       	std	Z+44, r13	; 0x2c
  4a:	e5 a6       	std	Z+45, r14	; 0x2d
  4c:	f6 a6       	std	Z+46, r15	; 0x2e
  4e:	0f 90       	pop	r0
  50:	0f be       	out	0x3f, r0	; 63
  52:	ff 90       	pop	r15
  54:	ef 90       	pop	r14
  56:	df 90       	pop	r13
  58:	cf 90       	pop	r12
  5a:	08 95       	ret

Disassembly of section .text.hot.vTaskResetState:

00000000 <vTaskResetState>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
   0:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
   4:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
    }
    #endif /* #if ( configNUMBER_OF_CORES == 1 ) */

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
   8:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
        FreeRTOS_errno = 0;
    }
    #endif /* #if ( configUSE_POSIX_ERRNO == 1 ) */

    /* Other file private variables. */
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
   c:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  10:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  14:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
    uxTopReadyPriority = tskIDLE_PRIORITY;
  18:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
    xSchedulerRunning = pdFALSE;
  1c:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
    xPendedTicks = ( TickType_t ) 0U;
  20:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  24:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>

    for( xCoreID = 0; xCoreID < configNUMBER_OF_CORES; xCoreID++ )
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
  28:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
    }

    xNumOfOverflows = ( BaseType_t ) 0;
  2c:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
    uxTaskNumber = ( UBaseType_t ) 0U;
  30:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
    xNextTaskUnblockTime = ( TickType_t ) 0U;
  34:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
  38:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
  3c:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
  40:	08 95       	ret

timers.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000016a4  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000279c  00000000  00000000  000016d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.hot.prvCheckForValidListAndQueue 00000052  00000000  00000000  00003e74  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.hot.prvInsertTimerInActiveList 00000054  00000000  00000000  00003ec6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.hot.prvReloadTimer 00000048  00000000  00000000  00003f1a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.hot.prvProcessExpiredTimer 00000054  00000000  00000000  00003f62  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.hot.prvSwitchTimerLists 0000003c  00000000  00000000  00003fb6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.hot.prvTimerTask 000001cc  00000000  00000000  00003ff2  2**1
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .rodata.xTimerCreateTimerTask.str1.1 00000008  00000000  00000000  000041be  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 12 .text.hot.xTimerCreateTimerTask 00000040  00000000  00000000  000041c6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.hot.xTimerCreate 0000006e  00000000  00000000  00004206  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text.hot.xTimerGenericCommandFromTask 00000068  00000000  00000000  00004274  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text.hot.xTimerGenericCommandFromISR 0000004c  00000000  00000000  000042dc  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 16 .text.hot.xTimerGetTimerDaemonTaskHandle 0000000a  00000000  00000000  00004328  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 17 .text.hot.xTimerGetPeriod 00000008  00000000  00000000  00004332  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .text.hot.vTimerSetReloadMode 0000001c  00000000  00000000  0000433a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 19 .text.hot.xTimerGetReloadMode 00000016  00000000  00000000  00004356  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 20 .text.hot.uxTimerGetReloadMode 00000004  00000000  00000000  0000436c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 21 .text.hot.xTimerGetExpiryTime 00000008  00000000  00000000  00004370  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .text.hot.pcTimerGetName 00000008  00000000  00000000  00004378  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .text.hot.xTimerIsTimerActive 00000012  00000000  00000000  00004380  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .text.hot.pvTimerGetTimerID 00000012  00000000  00000000  00004392  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 25 .text.hot.vTimerSetTimerID 00000012  00000000  00000000  000043a4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 26 .text.hot.vTimerResetState 00000012  00000000  00000000  000043b6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 27 .bss.xLastTime.2296 00000002  00000000  00000000  000043c8  2**0
                  ALLOC
 28 .bss.xTimerTaskHandle 00000002  00000000  00000000  000043c8  2**0
                  ALLOC
 29 .bss.xTimerQueue 00000002  00000000  00000000  000043c8  2**0
                  ALLOC
 30 .bss.pxOverflowTimerList 00000002  00000000  00000000  000043c8  2**0
                  ALLOC
 31 .bss.pxCurrentTimerList 00000002  00000000  00000000  000043c8  2**0
                  ALLOC
 32 .bss.xActiveTimerList2 00000009  00000000  00000000  000043c8  2**0
                  ALLOC
 33 .bss.xActiveTimerList1 00000009  00000000  00000000  000043c8  2**0
                  ALLOC
 34 .comment      00000012  00000000  00000000  000043c8  2**0
                  CONTENTS, READONLY
 35 .avr.prop     00000016  00000000  00000000  000043da  2**0
                  CONTENTS, RELOC, READONLY

Disassembly of section .text.hot.prvCheckForValidListAndQueue:

00000000 <prvCheckForValidListAndQueue>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
    void vTimerResetState( void )
    {
        xTimerQueue = NULL;
   0:	0f b6       	in	r0, 0x3f	; 63
   2:	f8 94       	cli
   4:	0f 92       	push	r0
   6:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        xTimerTaskHandle = NULL;
   a:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   e:	89 2b       	or	r24, r25
    }
  10:	01 f4       	brne	.+0      	; 0x12 <prvCheckForValidListAndQueue+0x12>
  12:	80 e0       	ldi	r24, 0x00	; 0
  14:	90 e0       	ldi	r25, 0x00	; 0
  16:	0e 94 00 00 	call	0	; 0x0 <prvCheckForValidListAndQueue>
  1a:	80 e0       	ldi	r24, 0x00	; 0
  1c:	90 e0       	ldi	r25, 0x00	; 0
  1e:	0e 94 00 00 	call	0	; 0x0 <prvCheckForValidListAndQueue>
  22:	80 e0       	ldi	r24, 0x00	; 0
  24:	90 e0       	ldi	r25, 0x00	; 0
  26:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
  2a:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  2e:	80 e0       	ldi	r24, 0x00	; 0
  30:	90 e0       	ldi	r25, 0x00	; 0
  32:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
  36:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  3a:	40 e0       	ldi	r20, 0x00	; 0
  3c:	65 e0       	ldi	r22, 0x05	; 5
  3e:	8a e0       	ldi	r24, 0x0A	; 10
  40:	0e 94 00 00 	call	0	; 0x0 <prvCheckForValidListAndQueue>
  44:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
  48:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  4c:	0f 90       	pop	r0
  4e:	0f be       	out	0x3f, r0	; 63
  50:	08 95       	ret

Disassembly of section .text.hot.prvInsertTimerInActiveList:

00000000 <prvInsertTimerInActiveList>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
    void vTimerResetState( void )
    {
        xTimerQueue = NULL;
   0:	fc 01       	movw	r30, r24
   2:	73 83       	std	Z+3, r23	; 0x03
   4:	62 83       	std	Z+2, r22	; 0x02
   6:	91 87       	std	Z+9, r25	; 0x09
        xTimerTaskHandle = NULL;
   8:	80 87       	std	Z+8, r24	; 0x08
   a:	46 17       	cp	r20, r22
   c:	57 07       	cpc	r21, r23
   e:	00 f0       	brcs	.+0      	; 0x10 <prvInsertTimerInActiveList+0x10>
    }
  10:	42 1b       	sub	r20, r18
  12:	53 0b       	sbc	r21, r19
  14:	84 85       	ldd	r24, Z+12	; 0x0c
  16:	95 85       	ldd	r25, Z+13	; 0x0d
  18:	48 17       	cp	r20, r24
  1a:	59 07       	cpc	r21, r25
  1c:	00 f4       	brcc	.+0      	; 0x1e <prvInsertTimerInActiveList+0x1e>
  1e:	bf 01       	movw	r22, r30
  20:	6e 5f       	subi	r22, 0xFE	; 254
  22:	7f 4f       	sbci	r23, 0xFF	; 255
  24:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  28:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  2c:	0e 94 00 00 	call	0	; 0x0 <prvInsertTimerInActiveList>
  30:	80 e0       	ldi	r24, 0x00	; 0
  32:	08 95       	ret
  34:	42 17       	cp	r20, r18
  36:	53 07       	cpc	r21, r19
  38:	00 f4       	brcc	.+0      	; 0x3a <prvInsertTimerInActiveList+0x3a>
  3a:	62 17       	cp	r22, r18
  3c:	73 07       	cpc	r23, r19
  3e:	00 f4       	brcc	.+0      	; 0x40 <prvInsertTimerInActiveList+0x40>
  40:	bf 01       	movw	r22, r30
  42:	6e 5f       	subi	r22, 0xFE	; 254
  44:	7f 4f       	sbci	r23, 0xFF	; 255
  46:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  4a:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  4e:	00 c0       	rjmp	.+0      	; 0x50 <prvInsertTimerInActiveList+0x50>
  50:	81 e0       	ldi	r24, 0x01	; 1
  52:	08 95       	ret

Disassembly of section .text.hot.prvReloadTimer:

00000000 <prvReloadTimer>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
    void vTimerResetState( void )
    {
        xTimerQueue = NULL;
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
        xTimerTaskHandle = NULL;
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	ec 01       	movw	r28, r24
   e:	8b 01       	movw	r16, r22
    }
  10:	7a 01       	movw	r14, r20
  12:	6c 85       	ldd	r22, Y+12	; 0x0c
  14:	7d 85       	ldd	r23, Y+13	; 0x0d
  16:	60 0f       	add	r22, r16
  18:	71 1f       	adc	r23, r17
  1a:	98 01       	movw	r18, r16
  1c:	a7 01       	movw	r20, r14
  1e:	ce 01       	movw	r24, r28
  20:	0e 94 00 00 	call	0	; 0x0 <prvReloadTimer>
  24:	81 11       	cpse	r24, r1
  26:	00 c0       	rjmp	.+0      	; 0x28 <prvReloadTimer+0x28>
  28:	df 91       	pop	r29
  2a:	cf 91       	pop	r28
  2c:	1f 91       	pop	r17
  2e:	0f 91       	pop	r16
  30:	ff 90       	pop	r15
  32:	ef 90       	pop	r14
  34:	08 95       	ret
  36:	8c 85       	ldd	r24, Y+12	; 0x0c
  38:	9d 85       	ldd	r25, Y+13	; 0x0d
  3a:	08 0f       	add	r16, r24
  3c:	19 1f       	adc	r17, r25
  3e:	e8 89       	ldd	r30, Y+16	; 0x10
  40:	f9 89       	ldd	r31, Y+17	; 0x11
  42:	ce 01       	movw	r24, r28
  44:	09 95       	icall
  46:	00 c0       	rjmp	.+0      	; 0x48 <__SREG__+0x9>

Disassembly of section .text.hot.prvProcessExpiredTimer:

00000000 <prvProcessExpiredTimer>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
    void vTimerResetState( void )
    {
        xTimerQueue = NULL;
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
        xTimerTaskHandle = NULL;
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	8c 01       	movw	r16, r24
   e:	7b 01       	movw	r14, r22
    }
  10:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  14:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  18:	05 80       	ldd	r0, Z+5	; 0x05
  1a:	f6 81       	ldd	r31, Z+6	; 0x06
  1c:	e0 2d       	mov	r30, r0
  1e:	c6 81       	ldd	r28, Z+6	; 0x06
  20:	d7 81       	ldd	r29, Z+7	; 0x07
  22:	ce 01       	movw	r24, r28
  24:	02 96       	adiw	r24, 0x02	; 2
  26:	0e 94 00 00 	call	0	; 0x0 <prvProcessExpiredTimer>
  2a:	8a 89       	ldd	r24, Y+18	; 0x12
  2c:	82 ff       	sbrs	r24, 2
  2e:	00 c0       	rjmp	.+0      	; 0x30 <prvProcessExpiredTimer+0x30>
  30:	a7 01       	movw	r20, r14
  32:	b8 01       	movw	r22, r16
  34:	ce 01       	movw	r24, r28
  36:	0e 94 00 00 	call	0	; 0x0 <prvProcessExpiredTimer>
  3a:	e8 89       	ldd	r30, Y+16	; 0x10
  3c:	f9 89       	ldd	r31, Y+17	; 0x11
  3e:	ce 01       	movw	r24, r28
  40:	df 91       	pop	r29
  42:	cf 91       	pop	r28
  44:	1f 91       	pop	r17
  46:	0f 91       	pop	r16
  48:	ff 90       	pop	r15
  4a:	ef 90       	pop	r14
  4c:	09 94       	ijmp
  4e:	8e 7f       	andi	r24, 0xFE	; 254
  50:	8a 8b       	std	Y+18, r24	; 0x12
  52:	00 c0       	rjmp	.+0      	; 0x54 <__SREG__+0x15>

Disassembly of section .text.hot.prvSwitchTimerLists:

00000000 <prvSwitchTimerLists>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
    void vTimerResetState( void )
    {
        xTimerQueue = NULL;
   0:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        xTimerTaskHandle = NULL;
   8:	80 81       	ld	r24, Z
   a:	81 11       	cpse	r24, r1
   c:	00 c0       	rjmp	.+0      	; 0xe <prvSwitchTimerLists+0xe>
   e:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
  12:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  16:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
  1a:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>
  1e:	f0 93 00 00 	sts	0x0000, r31	; 0x800000 <__SREG__+0x7fffc1>
  22:	e0 93 00 00 	sts	0x0000, r30	; 0x800000 <__SREG__+0x7fffc1>
  26:	08 95       	ret
  28:	05 80       	ldd	r0, Z+5	; 0x05
  2a:	f6 81       	ldd	r31, Z+6	; 0x06
  2c:	e0 2d       	mov	r30, r0
  2e:	6f ef       	ldi	r22, 0xFF	; 255
  30:	7f ef       	ldi	r23, 0xFF	; 255
  32:	80 81       	ld	r24, Z
  34:	91 81       	ldd	r25, Z+1	; 0x01
  36:	0e 94 00 00 	call	0	; 0x0 <prvSwitchTimerLists>
  3a:	00 c0       	rjmp	.+0      	; 0x3c <__zero_reg__+0x3b>

Disassembly of section .text.hot.prvTimerTask:

00000000 <prvTimerTask>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
    void vTimerResetState( void )
    {
        xTimerQueue = NULL;
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	00 d0       	rcall	.+0      	; 0x6 <prvTimerTask+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <prvTimerTask+0x8>
        xTimerTaskHandle = NULL;
   8:	1f 92       	push	r1
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	85 e0       	ldi	r24, 0x05	; 5
    }
  10:	b8 2e       	mov	r11, r24
  12:	ce 01       	movw	r24, r28
  14:	01 96       	adiw	r24, 0x01	; 1
  16:	7c 01       	movw	r14, r24
  18:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  1c:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  20:	a0 80       	ld	r10, Z
  22:	10 e0       	ldi	r17, 0x00	; 0
  24:	00 e0       	ldi	r16, 0x00	; 0
  26:	aa 20       	and	r10, r10
  28:	01 f0       	breq	.+0      	; 0x2a <prvTimerTask+0x2a>
  2a:	05 80       	ldd	r0, Z+5	; 0x05
  2c:	f6 81       	ldd	r31, Z+6	; 0x06
  2e:	e0 2d       	mov	r30, r0
  30:	00 81       	ld	r16, Z
  32:	11 81       	ldd	r17, Z+1	; 0x01
  34:	0e 94 00 00 	call	0	; 0x0 <prvTimerTask>
  38:	0e 94 00 00 	call	0	; 0x0 <prvTimerTask>
  3c:	6c 01       	movw	r12, r24
  3e:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  42:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  46:	c8 16       	cp	r12, r24
  48:	d9 06       	cpc	r13, r25
  4a:	00 f0       	brcs	.+0      	; 0x4c <prvTimerTask+0x4c>
  4c:	00 c0       	rjmp	.+0      	; 0x4e <prvTimerTask+0x4e>
  4e:	0e 94 00 00 	call	0	; 0x0 <prvTimerTask>
  52:	d0 92 00 00 	sts	0x0000, r13	; 0x800000 <__SREG__+0x7fffc1>
  56:	c0 92 00 00 	sts	0x0000, r12	; 0x800000 <__SREG__+0x7fffc1>
  5a:	0e 94 00 00 	call	0	; 0x0 <prvTimerTask>
  5e:	d7 01       	movw	r26, r14
  60:	eb 2d       	mov	r30, r11
  62:	1d 92       	st	X+, r1
  64:	ea 95       	dec	r30
  66:	01 f4       	brne	.+0      	; 0x68 <prvTimerTask+0x68>
  68:	50 e0       	ldi	r21, 0x00	; 0
  6a:	40 e0       	ldi	r20, 0x00	; 0
  6c:	b7 01       	movw	r22, r14
  6e:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  72:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  76:	0e 94 00 00 	call	0	; 0x0 <prvTimerTask>
  7a:	88 23       	and	r24, r24
  7c:	01 f0       	breq	.+0      	; 0x7e <prvTimerTask+0x7e>
  7e:	89 81       	ldd	r24, Y+1	; 0x01
  80:	87 fd       	sbrc	r24, 7
  82:	00 c0       	rjmp	.+0      	; 0x84 <prvTimerTask+0x84>
  84:	0c 81       	ldd	r16, Y+4	; 0x04
  86:	1d 81       	ldd	r17, Y+5	; 0x05
  88:	d8 01       	movw	r26, r16
  8a:	1a 96       	adiw	r26, 0x0a	; 10
  8c:	8d 91       	ld	r24, X+
  8e:	9c 91       	ld	r25, X
  90:	89 2b       	or	r24, r25
  92:	01 f0       	breq	.+0      	; 0x94 <prvTimerTask+0x94>
  94:	c8 01       	movw	r24, r16
  96:	02 96       	adiw	r24, 0x02	; 2
  98:	0e 94 00 00 	call	0	; 0x0 <prvTimerTask>
  9c:	0e 94 00 00 	call	0	; 0x0 <prvTimerTask>
  a0:	6c 01       	movw	r12, r24
  a2:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  a6:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  aa:	c8 16       	cp	r12, r24
  ac:	d9 06       	cpc	r13, r25
  ae:	00 f4       	brcc	.+0      	; 0xb0 <prvTimerTask+0xb0>
  b0:	0e 94 00 00 	call	0	; 0x0 <prvTimerTask>
  b4:	d0 92 00 00 	sts	0x0000, r13	; 0x800000 <__SREG__+0x7fffc1>
  b8:	c0 92 00 00 	sts	0x0000, r12	; 0x800000 <__SREG__+0x7fffc1>
  bc:	e9 81       	ldd	r30, Y+1	; 0x01
  be:	e1 50       	subi	r30, 0x01	; 1
  c0:	e9 30       	cpi	r30, 0x09	; 9
  c2:	00 f4       	brcc	.+0      	; 0xc4 <prvTimerTask+0xc4>
  c4:	0e 2e       	mov	r0, r30
  c6:	00 0c       	add	r0, r0
  c8:	ff 0b       	sbc	r31, r31
  ca:	e0 50       	subi	r30, 0x00	; 0
  cc:	f0 40       	sbci	r31, 0x00	; 0
  ce:	d8 01       	movw	r26, r16
  d0:	52 96       	adiw	r26, 0x12	; 18
  d2:	8c 91       	ld	r24, X
  d4:	52 97       	sbiw	r26, 0x12	; 18
  d6:	0c 94 00 00 	jmp	0	; 0x0 <prvTimerTask>
	...
  ea:	00 00       	nop
  ec:	d0 92 00 00 	sts	0x0000, r13	; 0x800000 <__SREG__+0x7fffc1>
  f0:	c0 92 00 00 	sts	0x0000, r12	; 0x800000 <__SREG__+0x7fffc1>
  f4:	aa 20       	and	r10, r10
  f6:	01 f0       	breq	.+0      	; 0xf8 <prvTimerTask+0xf8>
  f8:	c0 16       	cp	r12, r16
  fa:	d1 06       	cpc	r13, r17
  fc:	00 f0       	brcs	.+0      	; 0xfe <prvTimerTask+0xfe>
  fe:	0e 94 00 00 	call	0	; 0x0 <prvTimerTask>
 102:	b6 01       	movw	r22, r12
 104:	c8 01       	movw	r24, r16
 106:	0e 94 00 00 	call	0	; 0x0 <prvTimerTask>
 10a:	00 c0       	rjmp	.+0      	; 0x10c <prvTimerTask+0x10c>
 10c:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 110:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 114:	41 e0       	ldi	r20, 0x01	; 1
 116:	80 81       	ld	r24, Z
 118:	81 11       	cpse	r24, r1
 11a:	40 e0       	ldi	r20, 0x00	; 0
 11c:	b8 01       	movw	r22, r16
 11e:	6c 19       	sub	r22, r12
 120:	7d 09       	sbc	r23, r13
 122:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 126:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
 12a:	0e 94 00 00 	call	0	; 0x0 <prvTimerTask>
 12e:	0e 94 00 00 	call	0	; 0x0 <prvTimerTask>
 132:	81 11       	cpse	r24, r1
 134:	00 c0       	rjmp	.+0      	; 0x136 <prvTimerTask+0x136>
 136:	0e 94 00 00 	call	0	; 0x0 <prvTimerTask>
 13a:	00 c0       	rjmp	.+0      	; 0x13c <prvTimerTask+0x13c>
 13c:	81 60       	ori	r24, 0x01	; 1
 13e:	f8 01       	movw	r30, r16
 140:	82 8b       	std	Z+18, r24	; 0x12
 142:	2a 81       	ldd	r18, Y+2	; 0x02
 144:	3b 81       	ldd	r19, Y+3	; 0x03
 146:	64 85       	ldd	r22, Z+12	; 0x0c
 148:	75 85       	ldd	r23, Z+13	; 0x0d
 14a:	62 0f       	add	r22, r18
 14c:	73 1f       	adc	r23, r19
 14e:	a6 01       	movw	r20, r12
 150:	c8 01       	movw	r24, r16
 152:	0e 94 00 00 	call	0	; 0x0 <prvTimerTask>
 156:	88 23       	and	r24, r24
 158:	01 f4       	brne	.+0      	; 0x15a <prvTimerTask+0x15a>
 15a:	00 c0       	rjmp	.+0      	; 0x15c <prvTimerTask+0x15c>
 15c:	d8 01       	movw	r26, r16
 15e:	52 96       	adiw	r26, 0x12	; 18
 160:	8c 91       	ld	r24, X
 162:	52 97       	sbiw	r26, 0x12	; 18
 164:	82 ff       	sbrs	r24, 2
 166:	00 c0       	rjmp	.+0      	; 0x168 <prvTimerTask+0x168>
 168:	6a 81       	ldd	r22, Y+2	; 0x02
 16a:	7b 81       	ldd	r23, Y+3	; 0x03
 16c:	1c 96       	adiw	r26, 0x0c	; 12
 16e:	8d 91       	ld	r24, X+
 170:	9c 91       	ld	r25, X
 172:	68 0f       	add	r22, r24
 174:	79 1f       	adc	r23, r25
 176:	a6 01       	movw	r20, r12
 178:	c8 01       	movw	r24, r16
 17a:	0e 94 00 00 	call	0	; 0x0 <prvTimerTask>
 17e:	d8 01       	movw	r26, r16
 180:	50 96       	adiw	r26, 0x10	; 16
 182:	ed 91       	ld	r30, X+
 184:	fc 91       	ld	r31, X
 186:	c8 01       	movw	r24, r16
 188:	09 95       	icall
 18a:	00 c0       	rjmp	.+0      	; 0x18c <prvTimerTask+0x18c>
 18c:	8e 7f       	andi	r24, 0xFE	; 254
 18e:	f8 01       	movw	r30, r16
 190:	82 8b       	std	Z+18, r24	; 0x12
 192:	00 c0       	rjmp	.+0      	; 0x194 <prvTimerTask+0x194>
 194:	81 60       	ori	r24, 0x01	; 1
 196:	52 96       	adiw	r26, 0x12	; 18
 198:	8c 93       	st	X, r24
 19a:	52 97       	sbiw	r26, 0x12	; 18
 19c:	6a 81       	ldd	r22, Y+2	; 0x02
 19e:	7b 81       	ldd	r23, Y+3	; 0x03
 1a0:	1d 96       	adiw	r26, 0x0d	; 13
 1a2:	7c 93       	st	X, r23
 1a4:	6e 93       	st	-X, r22
 1a6:	1c 97       	sbiw	r26, 0x0c	; 12
 1a8:	6c 0d       	add	r22, r12
 1aa:	7d 1d       	adc	r23, r13
 1ac:	96 01       	movw	r18, r12
 1ae:	a6 01       	movw	r20, r12
 1b0:	c8 01       	movw	r24, r16
 1b2:	0e 94 00 00 	call	0	; 0x0 <prvTimerTask>
 1b6:	00 c0       	rjmp	.+0      	; 0x1b8 <prvTimerTask+0x1b8>
 1b8:	81 fd       	sbrc	r24, 1
 1ba:	00 c0       	rjmp	.+0      	; 0x1bc <prvTimerTask+0x1bc>
 1bc:	c8 01       	movw	r24, r16
 1be:	0e 94 00 00 	call	0	; 0x0 <prvTimerTask>
 1c2:	00 c0       	rjmp	.+0      	; 0x1c4 <prvTimerTask+0x1c4>
 1c4:	8e 7f       	andi	r24, 0xFE	; 254
 1c6:	f8 01       	movw	r30, r16
 1c8:	82 8b       	std	Z+18, r24	; 0x12
 1ca:	00 c0       	rjmp	.+0      	; 0x1cc <__SREG__+0x18d>

Disassembly of section .text.hot.xTimerCreateTimerTask:

00000000 <xTimerCreateTimerTask>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
    void vTimerResetState( void )
    {
        xTimerQueue = NULL;
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	0e 94 00 00 	call	0	; 0x0 <xTimerCreateTimerTask>
        xTimerTaskHandle = NULL;
   a:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   e:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
    }
  12:	89 2b       	or	r24, r25
  14:	01 f0       	breq	.+0      	; 0x16 <xTimerCreateTimerTask+0x16>
  16:	80 e0       	ldi	r24, 0x00	; 0
  18:	e8 2e       	mov	r14, r24
  1a:	80 e0       	ldi	r24, 0x00	; 0
  1c:	f8 2e       	mov	r15, r24
  1e:	03 e0       	ldi	r16, 0x03	; 3
  20:	30 e0       	ldi	r19, 0x00	; 0
  22:	20 e0       	ldi	r18, 0x00	; 0
  24:	4c e5       	ldi	r20, 0x5C	; 92
  26:	50 e0       	ldi	r21, 0x00	; 0
  28:	60 e0       	ldi	r22, 0x00	; 0
  2a:	70 e0       	ldi	r23, 0x00	; 0
  2c:	80 e0       	ldi	r24, 0x00	; 0
  2e:	90 e0       	ldi	r25, 0x00	; 0
  30:	0e 94 00 00 	call	0	; 0x0 <xTimerCreateTimerTask>
  34:	0f 91       	pop	r16
  36:	ff 90       	pop	r15
  38:	ef 90       	pop	r14
  3a:	08 95       	ret
  3c:	80 e0       	ldi	r24, 0x00	; 0
  3e:	00 c0       	rjmp	.+0      	; 0x40 <__SREG__+0x1>

Disassembly of section .text.hot.xTimerCreate:

00000000 <xTimerCreate>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
    void vTimerResetState( void )
    {
        xTimerQueue = NULL;
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
   6:	bf 92       	push	r11
        xTimerTaskHandle = NULL;
   8:	cf 92       	push	r12
   a:	df 92       	push	r13
   c:	ff 92       	push	r15
   e:	0f 93       	push	r16
    }
  10:	1f 93       	push	r17
  12:	cf 93       	push	r28
  14:	df 93       	push	r29
  16:	4c 01       	movw	r8, r24
  18:	5b 01       	movw	r10, r22
  1a:	f4 2e       	mov	r15, r20
  1c:	69 01       	movw	r12, r18
  1e:	83 e1       	ldi	r24, 0x13	; 19
  20:	90 e0       	ldi	r25, 0x00	; 0
  22:	0e 94 00 00 	call	0	; 0x0 <xTimerCreate>
  26:	ec 01       	movw	r28, r24
  28:	89 2b       	or	r24, r25
  2a:	01 f0       	breq	.+0      	; 0x2c <xTimerCreate+0x2c>
  2c:	1a 8a       	std	Y+18, r1	; 0x12
  2e:	0e 94 00 00 	call	0	; 0x0 <xTimerCreate>
  32:	99 82       	std	Y+1, r9	; 0x01
  34:	88 82       	st	Y, r8
  36:	bd 86       	std	Y+13, r11	; 0x0d
  38:	ac 86       	std	Y+12, r10	; 0x0c
  3a:	df 86       	std	Y+15, r13	; 0x0f
  3c:	ce 86       	std	Y+14, r12	; 0x0e
  3e:	19 8b       	std	Y+17, r17	; 0x11
  40:	08 8b       	std	Y+16, r16	; 0x10
  42:	ce 01       	movw	r24, r28
  44:	02 96       	adiw	r24, 0x02	; 2
  46:	0e 94 00 00 	call	0	; 0x0 <xTimerCreate>
  4a:	ff 20       	and	r15, r15
  4c:	01 f0       	breq	.+0      	; 0x4e <xTimerCreate+0x4e>
  4e:	8a 89       	ldd	r24, Y+18	; 0x12
  50:	84 60       	ori	r24, 0x04	; 4
  52:	8a 8b       	std	Y+18, r24	; 0x12
  54:	ce 01       	movw	r24, r28
  56:	df 91       	pop	r29
  58:	cf 91       	pop	r28
  5a:	1f 91       	pop	r17
  5c:	0f 91       	pop	r16
  5e:	ff 90       	pop	r15
  60:	df 90       	pop	r13
  62:	cf 90       	pop	r12
  64:	bf 90       	pop	r11
  66:	af 90       	pop	r10
  68:	9f 90       	pop	r9
  6a:	8f 90       	pop	r8
  6c:	08 95       	ret

Disassembly of section .text.hot.xTimerGenericCommandFromTask:

00000000 <xTimerGenericCommandFromTask>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
    void vTimerResetState( void )
    {
        xTimerQueue = NULL;
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
        xTimerTaskHandle = NULL;
   8:	00 d0       	rcall	.+0      	; 0xa <xTimerGenericCommandFromTask+0xa>
   a:	00 d0       	rcall	.+0      	; 0xc <xTimerGenericCommandFromTask+0xc>
   c:	1f 92       	push	r1
   e:	cd b7       	in	r28, 0x3d	; 61
    }
  10:	de b7       	in	r29, 0x3e	; 62
  12:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  16:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  1a:	23 2b       	or	r18, r19
  1c:	01 f4       	brne	.+0      	; 0x1e <xTimerGenericCommandFromTask+0x1e>
  1e:	80 e0       	ldi	r24, 0x00	; 0
  20:	0f 90       	pop	r0
  22:	0f 90       	pop	r0
  24:	0f 90       	pop	r0
  26:	0f 90       	pop	r0
  28:	0f 90       	pop	r0
  2a:	df 91       	pop	r29
  2c:	cf 91       	pop	r28
  2e:	1f 91       	pop	r17
  30:	0f 91       	pop	r16
  32:	08 95       	ret
  34:	69 83       	std	Y+1, r22	; 0x01
  36:	5b 83       	std	Y+3, r21	; 0x03
  38:	4a 83       	std	Y+2, r20	; 0x02
  3a:	9d 83       	std	Y+5, r25	; 0x05
  3c:	8c 83       	std	Y+4, r24	; 0x04
  3e:	66 30       	cpi	r22, 0x06	; 6
  40:	04 f4       	brge	.+0      	; 0x42 <xTimerGenericCommandFromTask+0x42>
  42:	0e 94 00 00 	call	0	; 0x0 <xTimerGenericCommandFromTask>
  46:	e0 91 00 00 	lds	r30, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  4a:	f0 91 00 00 	lds	r31, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  4e:	20 e0       	ldi	r18, 0x00	; 0
  50:	a8 01       	movw	r20, r16
  52:	82 30       	cpi	r24, 0x02	; 2
  54:	01 f0       	breq	.+0      	; 0x56 <xTimerGenericCommandFromTask+0x56>
  56:	50 e0       	ldi	r21, 0x00	; 0
  58:	40 e0       	ldi	r20, 0x00	; 0
  5a:	be 01       	movw	r22, r28
  5c:	6f 5f       	subi	r22, 0xFF	; 255
  5e:	7f 4f       	sbci	r23, 0xFF	; 255
  60:	cf 01       	movw	r24, r30
  62:	0e 94 00 00 	call	0	; 0x0 <xTimerGenericCommandFromTask>
  66:	00 c0       	rjmp	.+0      	; 0x68 <__SREG__+0x29>

Disassembly of section .text.hot.xTimerGenericCommandFromISR:

00000000 <xTimerGenericCommandFromISR>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
    void vTimerResetState( void )
    {
        xTimerQueue = NULL;
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	00 d0       	rcall	.+0      	; 0x6 <xTimerGenericCommandFromISR+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <xTimerGenericCommandFromISR+0x8>
        xTimerTaskHandle = NULL;
   8:	1f 92       	push	r1
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	fc 01       	movw	r30, r24
    }
  10:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  14:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
  18:	00 97       	sbiw	r24, 0x00	; 0
  1a:	01 f4       	brne	.+0      	; 0x1c <xTimerGenericCommandFromISR+0x1c>
  1c:	80 e0       	ldi	r24, 0x00	; 0
  1e:	0f 90       	pop	r0
  20:	0f 90       	pop	r0
  22:	0f 90       	pop	r0
  24:	0f 90       	pop	r0
  26:	0f 90       	pop	r0
  28:	df 91       	pop	r29
  2a:	cf 91       	pop	r28
  2c:	08 95       	ret
  2e:	69 83       	std	Y+1, r22	; 0x01
  30:	5b 83       	std	Y+3, r21	; 0x03
  32:	4a 83       	std	Y+2, r20	; 0x02
  34:	fd 83       	std	Y+5, r31	; 0x05
  36:	ec 83       	std	Y+4, r30	; 0x04
  38:	66 30       	cpi	r22, 0x06	; 6
  3a:	04 f0       	brlt	.+0      	; 0x3c <xTimerGenericCommandFromISR+0x3c>
  3c:	a9 01       	movw	r20, r18
  3e:	20 e0       	ldi	r18, 0x00	; 0
  40:	be 01       	movw	r22, r28
  42:	6f 5f       	subi	r22, 0xFF	; 255
  44:	7f 4f       	sbci	r23, 0xFF	; 255
  46:	0e 94 00 00 	call	0	; 0x0 <xTimerGenericCommandFromISR>
  4a:	00 c0       	rjmp	.+0      	; 0x4c <__SREG__+0xd>

Disassembly of section .text.hot.xTimerGetTimerDaemonTaskHandle:

00000000 <xTimerGetTimerDaemonTaskHandle>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
    void vTimerResetState( void )
    {
        xTimerQueue = NULL;
   0:	80 91 00 00 	lds	r24, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   4:	90 91 00 00 	lds	r25, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
        xTimerTaskHandle = NULL;
   8:	08 95       	ret

Disassembly of section .text.hot.xTimerGetPeriod:

00000000 <xTimerGetPeriod>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
    void vTimerResetState( void )
    {
        xTimerQueue = NULL;
   0:	fc 01       	movw	r30, r24
   2:	84 85       	ldd	r24, Z+12	; 0x0c
   4:	95 85       	ldd	r25, Z+13	; 0x0d
   6:	08 95       	ret

Disassembly of section .text.hot.vTimerSetReloadMode:

00000000 <vTimerSetReloadMode>:
   0:	fc 01       	movw	r30, r24
   2:	0f b6       	in	r0, 0x3f	; 63
   4:	f8 94       	cli
   6:	0f 92       	push	r0
        xTimerTaskHandle = NULL;
   8:	92 89       	ldd	r25, Z+18	; 0x12
   a:	66 23       	and	r22, r22
   c:	01 f0       	breq	.+0      	; 0xe <vTimerSetReloadMode+0xe>
   e:	94 60       	ori	r25, 0x04	; 4
    }
  10:	92 8b       	std	Z+18, r25	; 0x12
  12:	0f 90       	pop	r0
  14:	0f be       	out	0x3f, r0	; 63
  16:	08 95       	ret
  18:	9b 7f       	andi	r25, 0xFB	; 251
  1a:	00 c0       	rjmp	.+0      	; 0x1c <__zero_reg__+0x1b>

Disassembly of section .text.hot.xTimerGetReloadMode:

00000000 <xTimerGetReloadMode>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
    void vTimerResetState( void )
    {
        xTimerQueue = NULL;
   0:	0f b6       	in	r0, 0x3f	; 63
   2:	f8 94       	cli
   4:	0f 92       	push	r0
   6:	fc 01       	movw	r30, r24
        xTimerTaskHandle = NULL;
   8:	82 89       	ldd	r24, Z+18	; 0x12
   a:	82 fb       	bst	r24, 2
   c:	88 27       	eor	r24, r24
   e:	80 f9       	bld	r24, 0
    }
  10:	0f 90       	pop	r0
  12:	0f be       	out	0x3f, r0	; 63
  14:	08 95       	ret

Disassembly of section .text.hot.uxTimerGetReloadMode:

00000000 <uxTimerGetReloadMode>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
    void vTimerResetState( void )
    {
        xTimerQueue = NULL;
   0:	0c 94 00 00 	jmp	0	; 0x0 <uxTimerGetReloadMode>

Disassembly of section .text.hot.xTimerGetExpiryTime:

00000000 <xTimerGetExpiryTime>:
   0:	fc 01       	movw	r30, r24
   2:	82 81       	ldd	r24, Z+2	; 0x02
   4:	93 81       	ldd	r25, Z+3	; 0x03
   6:	08 95       	ret

Disassembly of section .text.hot.pcTimerGetName:

00000000 <pcTimerGetName>:
   0:	fc 01       	movw	r30, r24
   2:	80 81       	ld	r24, Z
   4:	91 81       	ldd	r25, Z+1	; 0x01
   6:	08 95       	ret

Disassembly of section .text.hot.xTimerIsTimerActive:

00000000 <xTimerIsTimerActive>:
   0:	0f b6       	in	r0, 0x3f	; 63
   2:	f8 94       	cli
   4:	0f 92       	push	r0
   6:	fc 01       	movw	r30, r24
        xTimerTaskHandle = NULL;
   8:	82 89       	ldd	r24, Z+18	; 0x12
   a:	81 70       	andi	r24, 0x01	; 1
   c:	0f 90       	pop	r0
   e:	0f be       	out	0x3f, r0	; 63
    }
  10:	08 95       	ret

Disassembly of section .text.hot.pvTimerGetTimerID:

00000000 <pvTimerGetTimerID>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
    void vTimerResetState( void )
    {
        xTimerQueue = NULL;
   0:	0f b6       	in	r0, 0x3f	; 63
   2:	f8 94       	cli
   4:	0f 92       	push	r0
   6:	fc 01       	movw	r30, r24
        xTimerTaskHandle = NULL;
   8:	86 85       	ldd	r24, Z+14	; 0x0e
   a:	97 85       	ldd	r25, Z+15	; 0x0f
   c:	0f 90       	pop	r0
   e:	0f be       	out	0x3f, r0	; 63
    }
  10:	08 95       	ret

Disassembly of section .text.hot.vTimerSetTimerID:

00000000 <vTimerSetTimerID>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
    void vTimerResetState( void )
    {
        xTimerQueue = NULL;
   0:	0f b6       	in	r0, 0x3f	; 63
   2:	f8 94       	cli
   4:	0f 92       	push	r0
   6:	fc 01       	movw	r30, r24
        xTimerTaskHandle = NULL;
   8:	77 87       	std	Z+15, r23	; 0x0f
   a:	66 87       	std	Z+14, r22	; 0x0e
   c:	0f 90       	pop	r0
   e:	0f be       	out	0x3f, r0	; 63
    }
  10:	08 95       	ret

Disassembly of section .text.hot.vTimerResetState:

00000000 <vTimerResetState>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
    void vTimerResetState( void )
    {
        xTimerQueue = NULL;
   0:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
   4:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
        xTimerTaskHandle = NULL;
   8:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
   c:	10 92 00 00 	sts	0x0000, r1	; 0x800000 <__SREG__+0x7fffc1>
    }
  10:	08 95       	ret

variantHooks.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000b28  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000023eb  00000000  00000000  00000b5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.initVariant 00000022  00000000  00000000  00002f47  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.vApplicationIdleHook 00000004  00000000  00000000  00002f69  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text._Z15prvSetMainLedOnv 00000006  00000000  00000000  00002f6d  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text._Z15prvBlinkMainLedv 00000004  00000000  00000000  00002f73  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .text.vApplicationMallocFailedHook 0000001c  00000000  00000000  00002f77  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.vApplicationStackOverflowHook 0000001c  00000000  00000000  00002f93  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .comment      00000012  00000000  00000000  00002faf  2**0
                  CONTENTS, READONLY

Disassembly of section .text.initVariant:

00000000 <initVariant>:

void vApplicationStackOverflowHook( TaskHandle_t xTask __attribute__ ((unused)),
                                    char * pcTaskName __attribute__ ((unused)) )
{

    prvSetMainLedOn(); // Main LED on.
   0:	20 91 00 00 	lds	r18, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
   4:	30 91 00 00 	lds	r19, 0x0000	; 0x800000 <__SREG__+0x7fffc1>
   8:	8f ef       	ldi	r24, 0xFF	; 255
   a:	98 e0       	ldi	r25, 0x08	; 8
   c:	82 1b       	sub	r24, r18
   e:	93 0b       	sbc	r25, r19
  10:	90 93 00 00 	sts	0x0000, r25	; 0x800000 <__SREG__+0x7fffc1>
  14:	80 93 00 00 	sts	0x0000, r24	; 0x800000 <__SREG__+0x7fffc1>

    for(;;)
    {
        _delay_ms(2000);
        prvBlinkMainLed();  // Main LED slow blink.
  18:	0e 94 00 00 	call	0	; 0x0 <initVariant>
  1c:	0e 94 00 00 	call	0	; 0x0 <initVariant>
  20:	08 95       	ret

Disassembly of section .text.vApplicationIdleHook:

00000000 <vApplicationIdleHook>:

void vApplicationStackOverflowHook( TaskHandle_t xTask __attribute__ ((unused)),
                                    char * pcTaskName __attribute__ ((unused)) )
{

    prvSetMainLedOn(); // Main LED on.
   0:	0c 94 00 00 	jmp	0	; 0x0 <vApplicationIdleHook>

Disassembly of section .text._Z15prvSetMainLedOnv:

00000000 <_Z15prvSetMainLedOnv>:
   0:	25 9a       	sbi	0x04, 5	; 4
   2:	2d 9a       	sbi	0x05, 5	; 5
   4:	08 95       	ret

Disassembly of section .text._Z15prvBlinkMainLedv:

00000000 <_Z15prvBlinkMainLedv>:
   0:	1d 9a       	sbi	0x03, 5	; 3
   2:	08 95       	ret

Disassembly of section .text.vApplicationMallocFailedHook:

00000000 <vApplicationMallocFailedHook>:
   0:	0e 94 00 00 	call	0	; 0x0 <vApplicationMallocFailedHook>
   4:	2f ef       	ldi	r18, 0xFF	; 255
   6:	80 e7       	ldi	r24, 0x70	; 112
   8:	92 e0       	ldi	r25, 0x02	; 2
   a:	21 50       	subi	r18, 0x01	; 1
   c:	80 40       	sbci	r24, 0x00	; 0
   e:	90 40       	sbci	r25, 0x00	; 0
  10:	01 f4       	brne	.+0      	; 0x12 <vApplicationMallocFailedHook+0x12>
  12:	00 c0       	rjmp	.+0      	; 0x14 <vApplicationMallocFailedHook+0x14>
  14:	00 00       	nop

    for(;;)
    {
        _delay_ms(2000);
        prvBlinkMainLed();  // Main LED slow blink.
  16:	0e 94 00 00 	call	0	; 0x0 <vApplicationMallocFailedHook>
  1a:	00 c0       	rjmp	.+0      	; 0x1c <__zero_reg__+0x1b>

Disassembly of section .text.vApplicationStackOverflowHook:

00000000 <vApplicationStackOverflowHook>:

void vApplicationStackOverflowHook( TaskHandle_t xTask __attribute__ ((unused)),
                                    char * pcTaskName __attribute__ ((unused)) )
{

    prvSetMainLedOn(); // Main LED on.
   0:	0e 94 00 00 	call	0	; 0x0 <vApplicationStackOverflowHook>
   4:	2f ef       	ldi	r18, 0xFF	; 255
   6:	87 ea       	ldi	r24, 0xA7	; 167
   8:	91 e6       	ldi	r25, 0x61	; 97
   a:	21 50       	subi	r18, 0x01	; 1
   c:	80 40       	sbci	r24, 0x00	; 0
   e:	90 40       	sbci	r25, 0x00	; 0
  10:	01 f4       	brne	.+0      	; 0x12 <vApplicationStackOverflowHook+0x12>
  12:	00 c0       	rjmp	.+0      	; 0x14 <vApplicationStackOverflowHook+0x14>
  14:	00 00       	nop

    for(;;)
    {
        _delay_ms(2000);
        prvBlinkMainLed();  // Main LED slow blink.
  16:	0e 94 00 00 	call	0	; 0x0 <vApplicationStackOverflowHook>
  1a:	00 c0       	rjmp	.+0      	; 0x1c <__zero_reg__+0x1b>

EEPROM.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000624  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000f80  00000000  00000000  00000658  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text._ZN11EEPROMClass4readEi 00000006  00000000  00000000  000015d8  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text._ZN11EEPROMClass5writeEih 00000008  00000000  00000000  000015de  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .bss.EEPROM   00000001  00000000  00000000  000015e6  2**0
                  ALLOC
  8 .comment      00000012  00000000  00000000  000015e6  2**0
                  CONTENTS, READONLY

Disassembly of section .text._ZN11EEPROMClass4readEi:

00000000 <_ZN11EEPROMClass4readEi>:
{
	return eeprom_read_byte((unsigned char *) address);
}

void EEPROMClass::write(int address, uint8_t value)
{
   0:	cb 01       	movw	r24, r22
	eeprom_write_byte((unsigned char *) address, value);
   2:	0c 94 00 00 	jmp	0	; 0x0 <_ZN11EEPROMClass4readEi>

Disassembly of section .text._ZN11EEPROMClass5writeEih:

00000000 <_ZN11EEPROMClass5writeEih>:
{
	return eeprom_read_byte((unsigned char *) address);
}

void EEPROMClass::write(int address, uint8_t value)
{
   0:	cb 01       	movw	r24, r22
	eeprom_write_byte((unsigned char *) address, value);
   2:	64 2f       	mov	r22, r20
   4:	0c 94 00 00 	jmp	0	; 0x0 <_ZN11EEPROMClass5writeEih>
